 - Better module abstraction.
    - This works as long as you keep your chain of abstract modules
      linear, although it's a bit of a pain.
    - If you try to have a diamond
      of abstract module inclusions, everything falls apart because you have
      no way to specify that the two inclusions of the same abstract module
      are the same.

- Better state machine abstraction.
    - State machine refinement is not the same as Dafny module refinement.
      If I build state machine X using state machine Y as a subcomponent,
      and then I create refinement Y' of Y, I can't automatically get an X'
      which has Y replaced with Y'. Instead I have to write a lot of boilerplate.

- Better way to specify implemenation vs spec files with including files.

- Sequence comprehension syntax

- Type aliasing is a bit broken.
    - type foo = parent.bar
    - diamond problem -- sometimes Dafny can't see type equivalence where we expect it
    - if parent.bar is a datatype, its constructors aren't aliased in at foo.

- It seems like a bug that Dafny lets you mention a generic type in a parameter list without
    mentioning the <actual types>

- How do we program generically over algebraic datatypes? Would like to
    have a datatype with an associated < method. We see the (==) trait,
    but ... how do we write our own?

- current code uses 'type' abstraction for Values; it will require lots
    of code to instantiate the Betree for specific Values.
    Prior code used <>-generics for Values, which was wordy and gross
    in a different way.
    Rob wants the best of both worlds.
    
- non-stupid implementation of sequences

- include-root

- better error messages
  - output line itself in addition to line numbers
  - anon wtf?

- auto-cast uint64 to ints
- methods on datatypes (because we don't necessarily want to use a class)

- d6d75b81577205ab31aafa4761a97a9b6ef72d1e timeout/instability with no smoking guns in the profiler
