#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
mod pervasive {


    //! The "standard library" for [Verus](https://github.com/verus-lang/verus).
    //! Contains various utilities and datatypes for proofs,
    //! as well as runtime functionality with specifications.
    //! For an introduction to Verus, see [the tutorial](https://verus-lang.github.io/verus/guide/).
    //!
    //! **Note about using the library:** A current limitation of Verus is that it does not
    //! support multi-crate projects. Therefore, this library needs to be embedded as a
    //! a _module_ in every user crate.
    //! See [this page](https://verus-lang.github.io/verus/guide/pervasive.html) for more details.
    //! We expect these hacks to go away once Verus has proper multi-crate support.
    pub mod map {
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[allow(unused_imports)]
        use crate::pervasive::set::*;
        use core::marker;
        #[doc = " `Map<K, V>` is an abstract map type for specifications."]
        #[doc =
          " To use a \"map\" in compiled code, use an `exec` type like HashMap (TODO)"]
        #[doc = " that has a `Map<K, V>` as its specification type."]
        #[doc = ""]
        #[doc =
          " An object `map: Map<K, V>` has a _domain_, a set of keys given by [`map.dom()`](Map::dom),"]
        #[doc =
          " and a mapping for keys in the domain to values, given by [`map[key]`](Map::index)."]
        #[doc =
          " Alternatively, a map can be thought of as a set of `(K, V)` pairs where each key"]
        #[doc = " appears in at most entry."]
        #[doc = ""]
        #[doc = " In general, a map might be infinite."]
        #[doc =
          " To work specifically with finite maps, see the [`self.finite()`](Set::finite) predicate."]
        #[doc = ""]
        #[doc = " Maps can be constructed in a few different ways:"]
        #[doc = "  * [`Map::empty()`] constructs an empty map."]
        #[doc =
          "  * [`Map::new`] and [`Map::total`] construct a map given functions that specify its domain and the mapping"]
        #[doc = "     from keys to values (a _map comprehension_)."]
        #[doc =
          "  * The [`map!`] macro, to construct small maps of a fixed size."]
        #[doc =
          "  * By manipulating an existing map with [`Map::insert`] or [`Map::remove`]."]
        #[doc = ""]
        #[doc =
          " To prove that two maps are equal, it is usually easiest to use the [`assert_maps_equal!`] macro."]
        #[verifier(external_body)]
        #[proof]
        pub struct Map<#[verifier(maybe_negative)] K,
                       #[verifier(strictly_positive)] V> {
            dummy: marker::PhantomData<(K, V)>,
        }
        impl <K, V> Map<K, V> {
            #[doc = " An empty map."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn empty() -> Map<K, V> {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Gives a `Map<K, V>` whose domain contains every key, and maps each key"]
            #[doc = " to the value given by `fv`."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn total(fv: impl Fn(K) -> V) -> Map<K, V> {
                Set::full().mk_map(fv)
            }
            #[doc =
              " Gives a `Map<K, V>` whose domain is given by the boolean predicate on keys `fk`,"]
            #[doc = " and maps each key to the value given by `fv`."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn new(fk: impl Fn(K) -> bool, fv: impl Fn(K) -> V)
             -> Map<K, V> {
                Set::new(fk).mk_map(fv)
            }
            #[doc = " The domain of the map as a set."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn dom(self) -> Set<K> {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Gets the value that the given key `key` maps to."]
            #[doc =
              " For keys not in the domain, the result is meaningless and arbitrary."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn index(self, key: K) -> V {
                ::builtin::recommends([self.dom().contains(key)]);
                ::core::panicking::panic("not implemented")
            }
            #[doc = " `[]` operator, synonymous with `index`"]
            #[verifier(inline)]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn spec_index(self, key: K) -> V {
                ::builtin::recommends([self.dom().contains(key)]);
                self.index(key)
            }
            #[doc = " Inserts the given (key, value) pair into the map."]
            #[doc = ""]
            #[doc =
              " If the key is already present from the map, then its existing value is overwritten"]
            #[doc = " by the new value."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn insert(self, key: K, value: V) -> Map<K, V> {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Removes the given key and its associated value from the map."]
            #[doc = ""]
            #[doc =
              " If the key is already absent from the map, then the map is left unchanged."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn remove(self, key: K) -> Map<K, V> {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Returns true if the two maps are pointwise equal, i.e.,"]
            #[doc =
              " they have the same domains and the corresponding values are equal"]
            #[doc =
              " for each key. This is equivalent to the maps being actually equal"]
            #[doc = " by [`axiom_map_ext_equal`]."]
            #[doc = ""]
            #[doc =
              " To prove that two maps are equal via extensionality, it is generally easier"]
            #[doc =
              " to use the [`assert_maps_equal!`] macro, rather than using `ext_equal` directly."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn ext_equal(self, m2: Map<K, V>) -> bool {
                (self.dom().ext_equal(m2.dom())) &&
                    ((::builtin::forall(|k: K|
                                            #[auto_trigger] (::builtin::imply(self.dom().contains(k),
                                                                              ::builtin::equal(self.spec_index(k),
                                                                                               m2.spec_index(k)))))))
            }
            #[doc =
              " Returns true if the key `k` is in the domain of `self`, and it maps to the value `v`."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn contains_pair(self, k: K, v: V) -> bool {
                self.dom().contains(k) &&
                    ::builtin::equal(self.spec_index(k), v)
            }
            #[doc =
              " Returns true if `m1` is _contained in_ `m2`, i.e., the domain of `m1` is a subset"]
            #[doc =
              " of the domain of `m2`, and they agree on all values in `m1`."]
            #[doc = ""]
            #[doc = " ## Example"]
            #[doc = ""]
            #[doc = " ```rust"]
            #[doc = " assert("]
            #[doc =
              "    map![1 => 10, 2 => 11].le(map![1 => 10, 2 => 11, 3 => 12])"]
            #[doc = " );"]
            #[doc = " ```"]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn le(self, m2: Self) -> bool {
                ::builtin::forall(|k: K|
                                      ::builtin::imply(#[trigger] self.dom().contains(k),
                                                       #[trigger] m2.dom().contains(k)
                                                           &&
                                                           ::builtin::equal(self.spec_index(k),
                                                                            m2.spec_index(k))))
            }
            #[doc = " Gives the union of two maps, defined as:"]
            #[doc = "  * The domain is the union of the two input maps."]
            #[doc =
              "  * For a given key in _both_ input maps, it maps to the same value that it maps to in the _right_ map (`m2`)."]
            #[doc =
              "  * For any other key in either input map (but not both), it maps to the same value"]
            #[doc = "    as it does in that map."]
            #[doc = ""]
            #[doc = " ## Example"]
            #[doc = ""]
            #[doc = " ```rust"]
            #[doc = " assert_maps_equal!("]
            #[doc =
              "    map![1 => 10, 2 => 11].union_prefer_right(map![1 => 20, 3 => 13]),"]
            #[doc = "    map![1 => 20, 2 => 11, 3 => 13],"]
            #[doc = " );"]
            #[doc = " ```"]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn union_prefer_right(self, m2: Self) -> Self {
                Self::new(::builtin::closure_to_fn_spec(|k: K|
                                                            self.dom().contains(k)
                                                                ||
                                                                m2.dom().contains(k)),
                          ::builtin::closure_to_fn_spec(|k: K|
                                                            if m2.dom().contains(k)
                                                               {
                                                                m2.spec_index(k)
                                                            } else {
                                                                self.spec_index(k)
                                                            }))
            }
            #[doc =
              " Removes the given keys and their associated values from the map."]
            #[doc = ""]
            #[doc =
              " Ignores any key in `keys` which is not in the domain of `self`."]
            #[doc = ""]
            #[doc = " ## Example"]
            #[doc = ""]
            #[doc = " ```rust"]
            #[doc = " assert_maps_equal!("]
            #[doc =
              "    map![1 => 10, 2 => 11, 3 => 12].remove_keys(set!{2, 3, 4}),"]
            #[doc = "    map![1 => 10],"]
            #[doc = " );"]
            #[doc = " ```"]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn remove_keys(self, keys: Set<K>) -> Self {
                Self::new(::builtin::closure_to_fn_spec(|k: K|
                                                            self.dom().contains(k)
                                                                &&
                                                                !keys.contains(k)),
                          ::builtin::closure_to_fn_spec(|k: K|
                                                            self.spec_index(k)))
            }
            #[doc =
              " Returns `true` if the two given maps agree on all keys that their domains"]
            #[doc = " share in common."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn agrees(self, m2: Self) -> bool {
                ::builtin::forall(|k|
                                      #[auto_trigger] (::builtin::imply(self.dom().contains(k)
                                                                            &&
                                                                            m2.dom().contains(k),
                                                                        ::builtin::equal(self.spec_index(k),
                                                                                         m2.spec_index(k)))))
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            #[verifier(returns(proof))]
            #[proof]
            pub fn tracked_empty() -> Self {
                ::builtin::ensures(|out_v: Self|
                                       [::builtin::equal(out_v,
                                                         Map::empty())]);
                ::core::panicking::panic("not implemented");
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            #[proof]
            pub fn tracked_insert(#[proof] &mut self, key: K,
                                  #[proof] value: V) {
                ::builtin::ensures([::builtin::equal(*self,
                                                     Map::insert(*old(self),
                                                                 key,
                                                                 value))]);
                ::core::panicking::panic("not implemented");
            }
            #[doc = " todo fill in documentation"]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            #[verifier(returns(proof))]
            #[proof]
            pub fn tracked_remove(#[proof] &mut self, key: K) -> V {
                ::builtin::requires([old(self).dom().contains(key)]);
                ::builtin::ensures(|v: V|
                                       [::builtin::equal(*self,
                                                         Map::remove(*old(self),
                                                                     key)),
                                        ::builtin::equal(v,
                                                         old(self).spec_index(key))]);
                ::core::panicking::panic("not implemented");
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            #[verifier(returns(proof))]
            #[proof]
            pub fn tracked_map_keys<J>(#[proof] old_map: Map<K, V>,
                                       key_map: Map<J, K>) -> Map<J, V> {
                ::builtin::requires([::builtin::forall(|j|
                                                           #[auto_trigger] (::builtin::imply(key_map.dom().contains(j),
                                                                                             old_map.dom().contains(key_map.index(j))))),
                                     ::builtin::forall(|j1, j2|
                                                           #[auto_trigger] (::builtin::imply(!equal(j1,
                                                                                                    j2)
                                                                                                 &&
                                                                                                 key_map.dom().contains(j1)
                                                                                                 &&
                                                                                                 key_map.dom().contains(j2),
                                                                                             !equal(key_map.index(j1),
                                                                                                    key_map.index(j2)))))]);
                ::builtin::ensures(|new_map: Map<J, V>|
                                       [::builtin::forall(|j|
                                                              ::builtin::spec_eq((#[trigger] new_map.dom().contains(j)),
                                                                                 (key_map.dom().contains(j)))),
                                        ::builtin::forall(|j|
                                                              ::builtin::imply(key_map.dom().contains(j),
                                                                               new_map.dom().contains(j)
                                                                                   &&
                                                                                   ::builtin::equal(#[trigger] new_map.index(j),
                                                                                                    old_map.index(key_map.index(j)))))]);
                ::core::panicking::panic("not implemented");
            }
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_map_empty<K, V>() {
            ::builtin::ensures([::builtin::equal(#[trigger] Map::<K,
                                                                  V>::empty().dom(),
                                                 Set::empty())]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_map_insert_domain<K, V>(m: Map<K, V>, key: K, value: V) {
            ::builtin::ensures([::builtin::equal(#[trigger] m.insert(key,
                                                                     value).dom(),
                                                 m.dom().insert(key))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_map_insert_same<K, V>(m: Map<K, V>, key: K, value: V) {
            ::builtin::ensures([::builtin::equal(#[trigger] m.insert(key,
                                                                     value).spec_index(key),
                                                 value)]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_map_insert_different<K,
                                          V>(m: Map<K, V>, key1: K, key2: K,
                                             value: V) {
            ::builtin::requires([m.dom().contains(key1),
                                 !::builtin::equal(key1, key2)]);
            ::builtin::ensures([::builtin::equal(m.insert(key2,
                                                          value).spec_index(key1),
                                                 m.spec_index(key1))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_map_remove_domain<K, V>(m: Map<K, V>, key: K) {
            ::builtin::ensures([::builtin::equal(#[trigger] m.remove(key).dom(),
                                                 m.dom().remove(key))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_map_remove_different<K,
                                          V>(m: Map<K, V>, key1: K, key2: K) {
            ::builtin::requires([m.dom().contains(key1),
                                 !::builtin::equal(key1, key2)]);
            ::builtin::ensures([::builtin::equal(m.remove(key2).spec_index(key1),
                                                 m.spec_index(key1))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_map_ext_equal<K, V>(m1: Map<K, V>, m2: Map<K, V>) {
            ::builtin::ensures([::builtin::spec_eq(m1.ext_equal(m2),
                                                   (::builtin::equal(m1,
                                                                     m2)))]);
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! map_internal {
            [$($key : expr => $value : expr), * $(,) ?] =>
            {
                $crate :: pervasive :: map :: Map :: empty()
                $(.insert($key, $value)) *
            }
        }
        #[doc =
          " Create a map using syntax like `map![key1 => val1, key2 => val, ...]`."]
        #[doc = ""]
        #[doc =
          " This is equivalent to `Map::empty().insert(key1, val1).insert(key2, val2)...`."]
        #[doc = ""]
        #[doc =
          " Note that this does _not_ require all keys to be distinct. In the case that two"]
        #[doc =
          " or more keys are equal, the resulting map uses the value of the rightmost entry."]
        #[macro_export]
        macro_rules! map {
            [$($tail : tt) *] =>
            {
                :: builtin_macros :: verus_proof_macro_exprs!
                ($crate :: pervasive :: map :: map_internal! ($($tail) *))
            } ;
        }
        #[doc(hidden)]
        #[verifier(inline)]
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn check_argument_is_map<K, V>(m: Map<K, V>) -> Map<K, V> { m }
        #[doc(hidden)]
        pub use map_internal;
        pub use map;
        #[doc =
          " Prove two maps `map1` and `map2` are equal by proving that their values are equal at each key."]
        #[doc = ""]
        #[doc =
          " More precisely, `assert_maps_equal!` requires that for each key `k`:"]
        #[doc =
          "  * `map1` contains `k` in its domain if and only if `map2` does (`map1.dom().contains(k) <==> map2.dom().contains(k)`)"]
        #[doc =
          "  * If they contain `k` in their domains, then their values are equal (`map1.dom().contains(k) && map2.dom().contains(k) ==> map1[k] === map2[k]`)"]
        #[doc = ""]
        #[doc =
          " The property that equality follows from these facts is often called _extensionality_."]
        #[doc = ""]
        #[doc = " `assert_maps_equal!` can handle many trivial-looking"]
        #[doc = " identities without any additional help:"]
        #[doc = ""]
        #[doc = " ```rust"]
        #[doc = " proof fn insert_remove(m: Map<int, int>, k: int, v: int)"]
        #[doc = "     requires !m.dom().contains(k)"]
        #[doc = "     ensures m.insert(k, v).remove(k) === m"]
        #[doc = " {"]
        #[doc = "     let m2 = m.insert(k, v).remove(k);"]
        #[doc = "     assert_maps_equal!(m, m2);"]
        #[doc = "     assert(m === m2);"]
        #[doc = " }"]
        #[doc = " ```"]
        #[doc = " "]
        #[doc =
          " For more complex cases, a proof may be required for each key:"]
        #[doc = ""]
        #[doc = " ```rust"]
        #[doc = " proof fn bitvector_maps() {"]
        #[doc = "     let m1 = Map::<u64, u64>::new("]
        #[doc = "         |key: u64| key & 31 == key,"]
        #[doc = "         |key: u64| key | 5);"]
        #[doc = " "]
        #[doc = "     let m2 = Map::<u64, u64>::new("]
        #[doc = "         |key: u64| key < 32,"]
        #[doc = "         |key: u64| 5 | key);"]
        #[doc = " "]
        #[doc = "     assert_maps_equal!(m1, m2, key => {"]
        #[doc =
          "         // Show that the domains of m1 and m2 are the same by showing their predicates"]
        #[doc = "         // are equivalent."]
        #[doc =
          "         assert_bit_vector((key & 31 == key) <==> (key < 32));"]
        #[doc = " "]
        #[doc =
          "         // Show that the values are the same by showing that these expressions"]
        #[doc = "         // are equivalent."]
        #[doc = "         assert_bit_vector(key | 5 == 5 | key);"]
        #[doc = "     });"]
        #[doc = " }"]
        #[doc = " ```"]
        #[macro_export]
        macro_rules! assert_maps_equal {
            [$($tail : tt) *] =>
            {
                :: builtin_macros :: verus_proof_macro_exprs!
                ($crate :: pervasive :: map :: assert_maps_equal_internal!
                 ($($tail) *))
            } ;
        }
        #[macro_export]
        #[doc(hidden)]
        macro_rules! assert_maps_equal_internal {
            ($m1 : expr, $m2 : expr $(,) ?) =>
            { assert_maps_equal_internal! ($m1, $m2, key => { }) } ;
            ($m1 : expr, $m2 : expr, $k : ident $(: $t : ty) ? => $bblock :
             block) =>
            {
                #[spec] let m1 = $crate :: pervasive :: map ::
                check_argument_is_map($m1) ; #[spec] let m2 = $crate ::
                pervasive :: map :: check_argument_is_map($m2) ; :: builtin ::
                assert_by(:: builtin :: equal(m1, m2),
                          {
                              :: builtin ::
                              assert_forall_by(| $k $(: $t) ? |
                                               {
                                                   :: builtin ::
                                                   ensures([:: builtin ::
                                                            imply(#[trigger]
                                                                  m1.dom().contains($k),
                                                                  m2.dom().contains($k))
                                                            && :: builtin ::
                                                            imply(m2.dom().contains($k),
                                                                  m1.dom().contains($k))
                                                            && :: builtin ::
                                                            imply(m1.dom().contains($k)
                                                                  &&
                                                                  m2.dom().contains($k),
                                                                  :: builtin
                                                                  ::
                                                                  equal(m1.index($k),
                                                                        m2.index($k)))])
                                                   ; { $bblock }
                                               }) ; $crate :: pervasive ::
                              assert(m1.ext_equal(m2)) ;
                          }) ;
            }
        }
        #[doc(hidden)]
        pub use assert_maps_equal_internal;
        pub use assert_maps_equal;
        impl <K, V> Map<K, V> {
            #[proof]
            #[verifier(verus_macro)]
            pub fn tracked_map_keys_in_place(#[proof] &mut self,
                                             key_map: Map<K, K>) {
                ::builtin::requires([::builtin::forall(|j|
                                                           #[auto_trigger] (::builtin::imply(key_map.dom().contains(j),
                                                                                             old(self).dom().contains(key_map.index(j))))),
                                     ::builtin::forall(|j1, j2|
                                                           #[auto_trigger] (::builtin::imply(!::builtin::equal(j1,
                                                                                                               j2)
                                                                                                 &&
                                                                                                 key_map.dom().contains(j1)
                                                                                                 &&
                                                                                                 key_map.dom().contains(j2),
                                                                                             !::builtin::equal(key_map.index(j1),
                                                                                                               key_map.index(j2)))))]);
                ::builtin::ensures([::builtin::forall(|j|
                                                          ::builtin::spec_eq(#[trigger] self.dom().contains(j),
                                                                             key_map.dom().contains(j))),
                                    ::builtin::forall(|j|
                                                          ::builtin::imply(key_map.dom().contains(j),
                                                                           self.dom().contains(j)
                                                                               &&
                                                                               ::builtin::equal(#[trigger] self.index(j),
                                                                                                old(self).index(key_map.index(j)))))]);
                #[proof]
                let mut tmp = Self::tracked_empty();
                crate::pervasive::modes::tracked_swap(&mut tmp, self);
                #[proof]
                let mut tmp = Self::tracked_map_keys(tmp, key_map);
                crate::pervasive::modes::tracked_swap(&mut tmp, self);
            }
        }
    }
    pub mod option {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        pub enum Option<A> { None, Some(A), }
        #[automatically_derived]
        impl <A> Option<A> {
            #[spec]
            #[verifier(is_variant("None"))]
            #[allow(non_snake_case)]
            pub fn is_None(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[verifier(is_variant("Some"))]
            #[allow(non_snake_case)]
            pub fn is_Some(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant("Some", 0))]
            pub fn get_Some_0(self) -> A {
                ::core::panicking::panic("not implemented")
            }
        }
        #[verifier(external)]
        impl <A: Clone> Clone for Option<A> {
            #[verifier(verus_macro)]
            fn clone(&self) -> Self {
                match self {
                    Option::None => Option::None,
                    Option::Some(a) => Option::Some(a.clone()),
                }
            }
        }
        impl <A: Copy> Copy for Option<A> { }
        impl <A> Option<A> {
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn or(self, optb: Option<A>) -> Option<A> {
                match self { Option::None => optb, Option::Some(s) => self, }
            }
            #[verifier(verus_macro)]
            pub fn unwrap(&self) -> &A {
                ::builtin::requires([self.is_Some()]);
                ::builtin::ensures(|a: &A|
                                       [::builtin::equal(*a,
                                                         self.get_Some_0())]);
                match self {
                    Option::Some(a) => a,
                    Option::None => unreached(),
                }
            }
            #[verifier(verus_macro)]
            #[verifier(returns(proof))]
            #[proof]
            pub fn tracked_unwrap(#[proof] self) -> A {
                ::builtin::requires([self.is_Some()]);
                ::builtin::ensures(|a: A|
                                       [::builtin::equal(a,
                                                         self.get_Some_0())]);
                match self {
                    Option::Some(a) => a,
                    Option::None => proof_from_false(),
                }
            }
        }
    }
    pub mod result {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        pub enum Result<T, E> { Ok(T), Err(E), }
        #[automatically_derived]
        impl <T, E> Result<T, E> {
            #[spec]
            #[verifier(is_variant("Ok"))]
            #[allow(non_snake_case)]
            pub fn is_Ok(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant("Ok", 0))]
            pub fn get_Ok_0(self) -> T {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[verifier(is_variant("Err"))]
            #[allow(non_snake_case)]
            pub fn is_Err(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant("Err", 0))]
            pub fn get_Err_0(self) -> E {
                ::core::panicking::panic("not implemented")
            }
        }
    }
    pub mod seq {
        use core::{marker};
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[doc = " `Seq<A>` is a sequence type for specifications."]
        #[doc =
          " To use a \"sequence\" in compiled code, use an `exec` type like [`vec::Vec`]"]
        #[doc = " that has `Seq<A>` as its specification type."]
        #[doc = ""]
        #[doc =
          " An object `seq: Seq<A>` has a length, given by [`seq.len()`](Seq::len),"]
        #[doc =
          " and a value at each `i` for `0 <= i < seq.len()`, given by [`seq[i]`](Seq::index)."]
        #[doc = ""]
        #[doc = " Sequences can be constructed in a few different ways:"]
        #[doc =
          "  * [`Seq::empty`] construct an empty sequence (`len() == 0`)"]
        #[doc =
          "  * [`Seq::new`] construct a sequence of a given length, initialized according"]
        #[doc = "     to a given function mapping indices `i` to values `A`."]
        #[doc =
          "  * The [`seq!`] macro, to construct small sequences of a fixed size (analagous to the"]
        #[doc = "     [`std::vec!`] macro)."]
        #[doc =
          "  * By manipulating an existing sequence with [`Seq::push`], [`Seq::update`],"]
        #[doc = "    or [`Seq::add`]."]
        #[doc = ""]
        #[doc =
          " To prove that two sequences are equal, it is usually easiest to use the [`assert_seqs_equal!`] macro."]
        #[verifier(external_body)]
        pub struct Seq<#[verifier(strictly_positive)] A> {
            dummy: marker::PhantomData<A>,
        }
        impl <A> Seq<A> {
            #[doc = " An empty sequence (i.e., a sequence of length 0)."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn empty() -> Seq<A> {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Construct a sequence `s` of length `len` where entry `s[i]` is given by `f(i)`."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn new(len: nat, f: impl Fn(int) -> A) -> Seq<A> {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " The length of a sequence."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn len(self) -> nat {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Gets the value at the given index `i`."]
            #[doc = ""]
            #[doc =
              " If `i` is not in the range `[0, self.len())`, then the resulting value"]
            #[doc = " is meaningless and arbitrary."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn index(self, i: int) -> A {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                         i),
                                                                                              self.len()))]);
                ::core::panicking::panic("not implemented")
            }
            #[doc = " `[]` operator, synonymous with `index`"]
            #[verifier(inline)]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn spec_index(self, i: int) -> A {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                         i),
                                                                                              self.len()))]);
                self.index(i)
            }
            #[doc = " Appends the value `a` to the end of the sequence."]
            #[doc = " This always increases the length of the sequence by 1."]
            #[doc = ""]
            #[doc = " ## Example"]
            #[doc = ""]
            #[doc = " ```rust"]
            #[doc = " proof fn push_test() {"]
            #[doc = "     assert_seqs_equal!("]
            #[doc = "           seq![10, 11, 12].push(13),"]
            #[doc = "           seq![10, 11, 12, 13],"]
            #[doc = "     );"]
            #[doc = " }"]
            #[doc = " ```"]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn push(self, a: A) -> Seq<A> {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Updates the sequence at the given index, replacing the element with the given"]
            #[doc = " value, and leaves all other entries unchanged."]
            #[doc = ""]
            #[doc = " ## Example"]
            #[doc = ""]
            #[doc = " ```rust"]
            #[doc = " proof fn update_test() {"]
            #[doc = "     let s = seq![10, 11, 12, 13, 14];"]
            #[doc = "     let t = s.update(2, -5);"]
            #[doc = "     assert_seqs_equal!(t, seq![10, 11, -5, 13, 14]);"]
            #[doc = " }"]
            #[doc = " ```"]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn update(self, i: int, a: A) -> Seq<A> {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                         i),
                                                                                              self.len()))]);
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Returns `true` if the two sequences are pointwise equal, i.e.,"]
            #[doc =
              " they have the same length and the corresponding values are equal"]
            #[doc =
              " at each index. This is equivalent to the sequences being actually equal"]
            #[doc = " by [`axiom_seq_ext_equal`]."]
            #[doc = ""]
            #[doc =
              " To prove that two sequences are equal via extensionality, it is generally easier"]
            #[doc =
              " to use the [`assert_seqs_equal!`] macro, rather than using `ext_equal` directly."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn ext_equal(self, s2: Seq<A>) -> bool {
                (::builtin::spec_eq(self.len(), s2.len())) &&
                    ((::builtin::forall(|i: int|
                                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                                               i),
                                                                                                                    self.len())),
                                                             ::builtin::equal(self.spec_index(i),
                                                                              s2.spec_index(i))))))
            }
            #[doc = " Returns a sequence for the given subrange."]
            #[doc = ""]
            #[doc = " ## Example"]
            #[doc = ""]
            #[doc = " ```rust"]
            #[doc = " proof fn subrange_test() {"]
            #[doc = "     let s = seq![10, 11, 12, 13, 14];"]
            #[doc = "     //                  ^-------^"]
            #[doc = "     //          0   1   2   3   4   5"]
            #[doc = "     let sub = s.subrange(2, 4);"]
            #[doc = "     assert_seqs_equal!(sub, seq![12, 13]);"]
            #[doc = " }"]
            #[doc = " ```"]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn subrange(self, start_inclusive: int, end_exclusive: int)
             -> Seq<A> {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                                                    start_inclusive),
                                                                                                                         end_exclusive),
                                                                                              self.len()))]);
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Concatenates the sequences."]
            #[doc = ""]
            #[doc = " ## Example"]
            #[doc = ""]
            #[doc = " ```rust"]
            #[doc = " proof fn add_test() {"]
            #[doc = "     assert_seqs_equal!("]
            #[doc = "         seq![10, 11].push(seq![12, 13, 14]),"]
            #[doc = "         seq![10, 11, 12, 13, 14],"]
            #[doc = "     );"]
            #[doc = " }"]
            #[doc = " ```"]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn add(self, rhs: Seq<A>) -> Seq<A> {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " `+` operator, synonymous with `add`"]
            #[verifier(inline)]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn spec_add(self, rhs: Seq<A>) -> Seq<A> { self.add(rhs) }
            #[doc = " Returns the last element of the sequence."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn last(self) -> A {
                ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(self.len())]);
                self.spec_index((::builtin::spec_cast_integer::<_,
                                                                int>(self.len())).spec_sub(::builtin::spec_literal_nat("1")))
            }
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_empty<A>() {
            ::builtin::ensures([::builtin::spec_eq(#[trigger] Seq::<A>::empty().len(),
                                                   ::builtin::spec_literal_nat("0"))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_new_len<A>(len: nat,
                                    f: ::builtin::FnSpec<(int,), A>) {
            ::builtin::ensures([::builtin::spec_eq(#[trigger] Seq::new(len,
                                                                       f).len(),
                                                   len)]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_new_index<A>(len: nat,
                                      f: ::builtin::FnSpec<(int,), A>,
                                      i: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                   i),
                                                                                        len))]);
            ::builtin::ensures([::builtin::equal(Seq::new(len,
                                                          f).spec_index(i),
                                                 f(i))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_push_len<A>(s: Seq<A>, a: A) {
            ::builtin::ensures([::builtin::spec_eq(#[trigger] s.push(a).len(),
                                                   (s.len()).spec_add(::builtin::spec_literal_nat("1")))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_push_index_same<A>(s: Seq<A>, a: A, i: int) {
            ::builtin::requires([::builtin::spec_eq(i, s.len())]);
            ::builtin::ensures([::builtin::equal(#[trigger] s.push(a).spec_index(i),
                                                 a)]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_push_index_different<A>(s: Seq<A>, a: A, i: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                   i),
                                                                                        s.len()))]);
            ::builtin::ensures([::builtin::equal(s.push(a).spec_index(i),
                                                 s.spec_index(i))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_update_len<A>(s: Seq<A>, i: int, a: A) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                   i),
                                                                                        s.len()))]);
            ::builtin::ensures([::builtin::spec_eq(#[trigger] s.update(i,
                                                                       a).len(),
                                                   s.len())]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_update_same<A>(s: Seq<A>, i: int, a: A) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                   i),
                                                                                        s.len()))]);
            ::builtin::ensures([::builtin::equal(#[trigger] s.update(i,
                                                                     a).spec_index(i),
                                                 a)]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_update_different<A>(s: Seq<A>, i1: int, i2: int,
                                             a: A) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                   i1),
                                                                                        s.len())),
                                 ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                   i2),
                                                                                        s.len())),
                                 !::builtin::spec_eq(i1, i2)]);
            ::builtin::ensures([::builtin::equal(s.update(i2,
                                                          a).spec_index(i1),
                                                 s.spec_index(i1))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_ext_equal<A>(s1: Seq<A>, s2: Seq<A>) {
            ::builtin::ensures([::builtin::spec_eq(s1.ext_equal(s2),
                                                   (::builtin::equal(s1,
                                                                     s2)))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_subrange_len<A>(s: Seq<A>, j: int, k: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                                              j),
                                                                                                                   k),
                                                                                        s.len()))]);
            ::builtin::ensures([::builtin::spec_eq(#[trigger] s.subrange(j,
                                                                         k).len(),
                                                   (k).spec_sub(j))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_subrange_index<A>(s: Seq<A>, j: int, k: int,
                                           i: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                                              j),
                                                                                                                   k),
                                                                                        s.len())),
                                 ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                   i),
                                                                                        (k).spec_sub(j)))]);
            ::builtin::ensures([::builtin::equal(s.subrange(j,
                                                            k).spec_index(i),
                                                 s.spec_index((i).spec_add(j)))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_add_len<A>(s1: Seq<A>, s2: Seq<A>) {
            ::builtin::ensures([::builtin::spec_eq(#[trigger] s1.add(s2).len(),
                                                   (s1.len()).spec_add(s2.len()))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_add_index1<A>(s1: Seq<A>, s2: Seq<A>, i: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                   i),
                                                                                        s1.len()))]);
            ::builtin::ensures([::builtin::equal(s1.add(s2).spec_index(i),
                                                 s1.spec_index(i))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_seq_add_index2<A>(s1: Seq<A>, s2: Seq<A>, i: int) {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_le(s1.len()),
                                 (i).spec_lt((::builtin::spec_cast_integer::<_,
                                                                             int>(s1.len())).spec_add(s2.len()))]);
            ::builtin::ensures([::builtin::equal(s1.add(s2).spec_index(i),
                                                 s2.spec_index((i).spec_sub(s1.len())))]);
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! seq_internal {
            [$($elem : expr), * $(,) ?] =>
            { $crate :: pervasive :: seq :: Seq :: empty() $(.push($elem)) * }
        }
        #[doc = " Creates a [`Seq`] containing the given elements."]
        #[doc = ""]
        #[doc = " ## Example"]
        #[doc = ""]
        #[doc = " ```rust"]
        #[doc = " let s = seq![11, 12, 13];"]
        #[doc = ""]
        #[doc = " assert(s.len() == 3);"]
        #[doc = " assert(s[0] == 11);"]
        #[doc = " assert(s[1] == 12);"]
        #[doc = " assert(s[2] == 13);"]
        #[doc = " ```"]
        #[macro_export]
        macro_rules! seq {
            [$($tail : tt) *] =>
            {
                :: builtin_macros :: verus_proof_macro_exprs!
                ($crate :: pervasive :: seq :: seq_internal! ($($tail) *))
            } ;
        }
        #[doc(hidden)]
        pub use seq_internal;
        pub use seq;
    }
    pub mod seq_lib {
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[allow(unused_imports)]
        use crate::pervasive::seq::*;
        impl <A> Seq<A> {
            #[doc =
              " Applies the function `f` to each element of the sequence, and returns"]
            #[doc = " the resulting sequence."]
            #[doc =
              " The `int` parameter of `f` is the index of the element being mapped."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn map<B>(self, f: ::builtin::FnSpec<(int, A), B>) -> Seq<B> {
                Seq::new(self.len(),
                         ::builtin::closure_to_fn_spec(|i: int|
                                                           f(i,
                                                             self.spec_index(i))))
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn contains(self, needle: A) -> bool {
                ::builtin::exists(|i: int|
                                      ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                        i),
                                                                                             self.len()))
                                          &&
                                          ::builtin::equal(self.spec_index(i),
                                                           needle))
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn index_of(self, needle: A) -> int {
                ::builtin::choose(|i: int|
                                      ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                        i),
                                                                                             self.len()))
                                          &&
                                          ::builtin::equal(self.spec_index(i),
                                                           needle))
            }
            #[doc =
              " Drops the last element of a sequence and returns a sequence whose length is"]
            #[doc = " thereby 1 smaller."]
            #[doc = ""]
            #[doc =
              " If the input sequence is empty, the result is meaningless and arbitrary."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn drop_last(self) -> Seq<A> {
                ::builtin::recommends([(self.len()).spec_ge(::builtin::spec_literal_nat("1"))]);
                self.subrange(::builtin::spec_literal_integer("0"),
                              (::builtin::spec_cast_integer::<_,
                                                              int>(self.len())).spec_sub(::builtin::spec_literal_nat("1")))
            }
        }
        #[doc(hidden)]
        #[verifier(inline)]
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn check_argument_is_seq<A>(s: Seq<A>) -> Seq<A> { s }
        #[doc =
          " Prove two sequences `s1` and `s2` are equal by proving that their elements are equal at each index."]
        #[doc = ""]
        #[doc = " More precisely, `assert_seqs_equal!` requires:"]
        #[doc =
          "  * `s1` and `s2` have the same length (`s1.len() == s2.len()`), and"]
        #[doc =
          "  * for all `i` in the range `0 <= i < s1.len()`, we have `s1[i] === s2[i]`."]
        #[doc = ""]
        #[doc =
          " The property that equality follows from these facts is often called _extensionality_."]
        #[doc = ""]
        #[doc = " `assert_seqs_equal!` can handle many trivial-looking"]
        #[doc = " identities without any additional help:"]
        #[doc = ""]
        #[doc = " ```rust"]
        #[doc = " proof fn subrange_concat(s: Seq<u64>, i: int) {"]
        #[doc = "     requires(["]
        #[doc = "         0 <= i && i <= s.len(),"]
        #[doc = "     ]);"]
        #[doc = " "]
        #[doc = "     let t1 = s.subrange(0, i);"]
        #[doc = "     let t2 = s.subrange(i, s.len());"]
        #[doc = "     let t = t1.add(t2);"]
        #[doc = " "]
        #[doc = "     assert_seqs_equal!(s, t);"]
        #[doc = " "]
        #[doc = "     assert(s === t);"]
        #[doc = " }"]
        #[doc = " ```"]
        #[doc = ""]
        #[doc =
          " In more complex cases, a proof may be required for the equality of each element pair."]
        #[doc = " For example,"]
        #[doc = " "]
        #[doc = " ```rust"]
        #[doc = " proof fn bitvector_seqs() {"]
        #[doc = "     let s = Seq::<u64>::new(5, |i| i as u64);"]
        #[doc = "     let t = Seq::<u64>::new(5, |i| i as u64 | 0);"]
        #[doc = " "]
        #[doc = "     assert_seqs_equal!(s, t, i => {"]
        #[doc = "         // Need to show that s[i] == t[i]"]
        #[doc =
          "         // Prove that the elements are equal by appealing to a bitvector solver:"]
        #[doc = "         let j = i as u64;"]
        #[doc = "         assert_bit_vector(j | 0 == j);"]
        #[doc = "         assert(s[i] == t[i]);"]
        #[doc = "     });"]
        #[doc = " }"]
        #[doc = " ```"]
        #[macro_export]
        macro_rules! assert_seqs_equal {
            [$($tail : tt) *] =>
            {
                :: builtin_macros :: verus_proof_macro_exprs!
                ($crate :: pervasive :: seq_lib :: assert_seqs_equal_internal!
                 ($($tail) *))
            } ;
        }
        #[macro_export]
        #[doc(hidden)]
        macro_rules! assert_seqs_equal_internal {
            ($s1 : expr, $s2 : expr $(,) ?) =>
            { assert_seqs_equal_internal! ($s1, $s2, idx => { }) } ;
            ($s1 : expr, $s2 : expr, $idx : ident => $bblock : block) =>
            {
                #[spec] let s1 = $crate :: pervasive :: seq_lib ::
                check_argument_is_seq($s1) ; #[spec] let s2 = $crate ::
                pervasive :: seq_lib :: check_argument_is_seq($s2) ; ::
                builtin ::
                assert_by(:: builtin :: equal(s1, s2),
                          {
                              $crate :: pervasive ::
                              assert(s1.len() == s2.len()) ; :: builtin ::
                              assert_forall_by(| $idx : :: builtin :: int |
                                               {
                                                   :: builtin ::
                                                   requires(:: builtin_macros
                                                            ::
                                                            verus_proof_expr!
                                                            (0 <= $idx && $idx
                                                             < s1.len())) ; ::
                                                   builtin ::
                                                   ensures(:: builtin ::
                                                           equal(s1.index($idx),
                                                                 s2.index($idx)))
                                                   ; { $bblock }
                                               }) ; $crate :: pervasive ::
                              assert(s1.ext_equal(s2)) ;
                          }) ;
            }
        }
        #[doc(hidden)]
        pub use assert_seqs_equal_internal;
        pub use assert_seqs_equal;
    }
    pub mod set {
        use core::marker;
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[allow(unused_imports)]
        use crate::pervasive::map::*;
        #[doc = " `Set<A>` is a set type for specifications."]
        #[doc = ""]
        #[doc =
          " An object `set: Set<A>` is a subset of the set of all values `a: A`."]
        #[doc =
          " Equivalently, it can be thought of as a boolean predicate on `A`."]
        #[doc = ""]
        #[doc = " In general, a set might be infinite."]
        #[doc =
          " To work specifically with finite sets, see the [`self.finite()`](Set::finite) predicate."]
        #[doc = " "]
        #[doc = " Sets can be constructed in a few different ways:"]
        #[doc = "  * [`Set::empty`] gives an empty set"]
        #[doc = "  * [`Set::full`] gives the set of all elements in `A`"]
        #[doc = "  * [`Set::new`] constructs a set from a boolean predicate"]
        #[doc =
          "  * The [`set!`] macro, to construct small sets of a fixed size"]
        #[doc =
          "  * By manipulating an existing sequence with [`Set::union`], [`Set::intersect`],"]
        #[doc =
          "    [`Set::difference`], [`Set::complement`], [`Set::filter`], [`Set::insert`],"]
        #[doc = "    or [`Set::remove`]."]
        #[doc = ""]
        #[doc =
          " To prove that two sequences are equal, it is usually easiest to use the [`assert_seqs_equal!`] macro."]
        #[verifier(external_body)]
        pub struct Set<#[verifier(maybe_negative)] A> {
            dummy: marker::PhantomData<A>,
        }
        impl <A> Set<A> {
            #[doc = " The \"empty\" set. "]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn empty() -> Set<A> {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Set whose membership is determined by the given boolean predicate."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn new<F: Fn(A) -> bool>(f: F) -> Set<A> {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " The \"full\" set, i.e., set containing every element of type `A`."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn full() -> Set<A> { Set::empty().complement() }
            #[doc =
              " Predicate indicating if the set contains the given element."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn contains(self, a: A) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Returns `true` if for every value `a: A`, it is either in both input sets or neither."]
            #[doc = " This is equivalent to the sets being actually equal"]
            #[doc = " by [`axiom_set_ext_equal`]."]
            #[doc = ""]
            #[doc =
              " To prove that two sets are equal via extensionality, it is generally easier"]
            #[doc =
              " to use the [`assert_sets_equal!`] macro, rather than using `ext_equal` directly."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn ext_equal(self, s2: Set<A>) -> bool {
                ::builtin::forall(|a: A|
                                      ::builtin::spec_eq(self.contains(a),
                                                         s2.contains(a)))
            }
            #[doc =
              " Returns `true` if the first argument is a subset of the second."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn subset_of(self, s2: Set<A>) -> bool {
                ::builtin::forall(|a: A|
                                      ::builtin::imply(self.contains(a),
                                                       s2.contains(a)))
            }
            #[doc = " Returns a new set with the given element inserted."]
            #[doc =
              " If that element is already in the set, then an identical set is returned."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn insert(self, a: A) -> Set<A> {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Returns a new set with the given element removed."]
            #[doc =
              " If that element is already absent from the set, then an identical set is returned."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn remove(self, a: A) -> Set<A> {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Union of two sets."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn union(self, s2: Set<A>) -> Set<A> {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " `+` operator, synonymous with `union`"]
            #[verifier(inline)]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn spec_add(self, s2: Set<A>) -> Set<A> { self.union(s2) }
            #[doc = " Intersection of two sets."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn intersect(self, s2: Set<A>) -> Set<A> {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Set difference, i.e., the set of all elements in the first one but not in the second."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn difference(self, s2: Set<A>) -> Set<A> {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Set complement (within the space of all possible elements in `A`)."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn complement(self) -> Set<A> {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Set of all elements in the given set which satisfy the predicate `f`."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn filter<F: Fn(A) -> bool>(self, f: F) -> Set<A> {
                self.intersect(Self::new(f))
            }
            #[doc = " Returns `true` if the set is finite."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn finite(self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Cardinality of the set. (Only meaningful if a set is finite.)"]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn len(self) -> nat {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Chooses an arbitrary element of the set."]
            #[doc = ""]
            #[doc = " This is often useful for proofs by induction."]
            #[doc = ""]
            #[doc =
              " (Note that, although the result is arbitrary, it is still a _deterministic_ function"]
            #[doc = " like any other `spec` function.)"]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn choose(self) -> A {
                ::builtin::choose(|a: A| self.contains(a))
            }
            #[doc =
              " Creates a [`Map`](map::Map) whose domain is the given set."]
            #[doc =
              " The values of the map are given by `f`, a function of the keys."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn mk_map<V, F: Fn(A) -> V>(self, f: F) -> Map<A, V> {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Returns `true` if the sets are disjoint, i.e., if their interesection is"]
            #[doc = " the empty set."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn disjoint(self, s2: Self) -> bool {
                ::builtin::forall(|a: A|
                                      ::builtin::imply(self.contains(a),
                                                       !s2.contains(a)))
            }
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_empty<A>(a: A) {
            ::builtin::ensures([!Set::empty().contains(a)]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_new<A>(f: ::builtin::FnSpec<(A,), bool>, a: A) {
            ::builtin::ensures([::builtin::spec_eq(Set::new(f).contains(a),
                                                   f(a))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_insert_same<A>(s: Set<A>, a: A) {
            ::builtin::ensures([#[trigger] s.insert(a).contains(a)]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_insert_different<A>(s: Set<A>, a1: A, a2: A) {
            ::builtin::requires([!::builtin::equal(a1, a2)]);
            ::builtin::ensures([::builtin::spec_eq(s.insert(a2).contains(a1),
                                                   s.contains(a1))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_remove_same<A>(s: Set<A>, a: A) {
            ::builtin::ensures([!(#[trigger] s.remove(a).contains(a))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_remove_different<A>(s: Set<A>, a1: A, a2: A) {
            ::builtin::requires([!::builtin::equal(a1, a2)]);
            ::builtin::ensures([::builtin::spec_eq(s.remove(a2).contains(a1),
                                                   s.contains(a1))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_union<A>(s1: Set<A>, s2: Set<A>, a: A) {
            ::builtin::ensures([::builtin::spec_eq(s1.union(s2).contains(a),
                                                   (s1.contains(a) ||
                                                        s2.contains(a)))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_intersect<A>(s1: Set<A>, s2: Set<A>, a: A) {
            ::builtin::ensures([::builtin::spec_eq(s1.intersect(s2).contains(a),
                                                   (s1.contains(a) &&
                                                        s2.contains(a)))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_difference<A>(s1: Set<A>, s2: Set<A>, a: A) {
            ::builtin::ensures([::builtin::spec_eq(s1.difference(s2).contains(a),
                                                   (s1.contains(a) &&
                                                        !s2.contains(a)))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_complement<A>(s: Set<A>, a: A) {
            ::builtin::ensures([::builtin::spec_eq(s.complement().contains(a),
                                                   !s.contains(a))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_ext_equal<A>(s1: Set<A>, s2: Set<A>) {
            ::builtin::ensures([::builtin::spec_eq(s1.ext_equal(s2),
                                                   (::builtin::equal(s1,
                                                                     s2)))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_mk_map_domain<K,
                                   V>(s: Set<K>,
                                      f: ::builtin::FnSpec<(K,), V>) {
            ::builtin::ensures([::builtin::equal(#[trigger] s.mk_map(f).dom(),
                                                 s)]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_mk_map_index<K,
                                  V>(s: Set<K>, f: ::builtin::FnSpec<(K,), V>,
                                     key: K) {
            ::builtin::requires([s.contains(key)]);
            ::builtin::ensures([::builtin::equal(s.mk_map(f).spec_index(key),
                                                 f(key))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_empty_finite<A>() {
            ::builtin::ensures([#[trigger] Set::<A>::empty().finite()]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_insert_finite<A>(s: Set<A>, a: A) {
            ::builtin::requires([s.finite()]);
            ::builtin::ensures([#[trigger] s.insert(a).finite()]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_remove_finite<A>(s: Set<A>, a: A) {
            ::builtin::requires([s.finite()]);
            ::builtin::ensures([#[trigger] s.remove(a).finite()]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_union_finite<A>(s1: Set<A>, s2: Set<A>) {
            ::builtin::requires([s1.finite(), s2.finite()]);
            ::builtin::ensures([#[trigger] s1.union(s2).finite()]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_intersect_finite<A>(s1: Set<A>, s2: Set<A>) {
            ::builtin::requires([s1.finite() || s2.finite()]);
            ::builtin::ensures([#[trigger] s1.intersect(s2).finite()]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_difference_finite<A>(s1: Set<A>, s2: Set<A>) {
            ::builtin::requires([s1.finite()]);
            ::builtin::ensures([#[trigger] s1.difference(s2).finite()]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_choose_finite<A>(s: Set<A>) {
            ::builtin::requires([!s.finite()]);
            ::builtin::ensures([#[trigger] s.contains(s.choose())]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_empty_len<A>() {
            ::builtin::ensures([::builtin::spec_eq(#[trigger] Set::<A>::empty().len(),
                                                   ::builtin::spec_literal_nat("0"))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_insert_len<A>(s: Set<A>, a: A) {
            ::builtin::requires([s.finite()]);
            ::builtin::ensures([::builtin::spec_eq(#[trigger] s.insert(a).len(),
                                                   (s.len()).spec_add((if s.contains(a)
                                                                          {
                                                                           ::builtin::spec_literal_int("0")
                                                                       } else {
                                                                           ::builtin::spec_literal_integer("1")
                                                                       })))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_remove_len<A>(s: Set<A>, a: A) {
            ::builtin::requires([s.finite()]);
            ::builtin::ensures([::builtin::spec_eq(s.len(),
                                                   (#[trigger] s.remove(a).len()).spec_add((if s.contains(a)
                                                                                               {
                                                                                                ::builtin::spec_literal_int("1")
                                                                                            } else {
                                                                                                ::builtin::spec_literal_integer("0")
                                                                                            })))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_set_choose_len<A>(s: Set<A>) {
            ::builtin::requires([s.finite(),
                                 !::builtin::spec_eq(#[trigger] s.len(),
                                                     ::builtin::spec_literal_nat("0"))]);
            ::builtin::ensures([#[trigger] s.contains(s.choose())]);
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! set_internal {
            [$($elem : expr), * $(,) ?] =>
            {
                $crate :: pervasive :: set :: Set :: empty() $(.insert($elem))
                *
            } ;
        }
        #[macro_export]
        macro_rules! set {
            [$($tail : tt) *] =>
            {
                :: builtin_macros :: verus_proof_macro_exprs!
                ($crate :: pervasive :: set :: set_internal! ($($tail) *))
            } ;
        }
        pub use set_internal;
        pub use set;
    }
    pub mod set_lib {
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[allow(unused_imports)]
        use crate::pervasive::set::*;
        impl <A> Set<A> {
            #[verifier(verus_macro)]
            #[proof]
            pub fn is_empty(self) -> bool {
                ::builtin::requires([self.finite()]);
                ::builtin::ensures(|b: bool|
                                       [::builtin::spec_eq((b),
                                                           (self.finite() &&
                                                                ::builtin::spec_eq(self.len(),
                                                                                   ::builtin::spec_literal_nat("0")))),
                                        ::builtin::spec_eq((b),
                                                           (self.ext_equal(Set::empty())))]);
                if self.finite() &&
                       ::builtin::spec_eq(self.len(),
                                          ::builtin::spec_literal_nat("0")) {
                    lemma_len0_is_empty::<A>(self);
                }
                self.ext_equal(Set::empty())
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn map<B>(self, f: ::builtin::FnSpec<(A,), B>) -> Set<B> {
                Set::new(::builtin::closure_to_fn_spec(|a: B|
                                                           ::builtin::exists(|x:
                                                                                  A|
                                                                                 self.contains(x)
                                                                                     &&
                                                                                     ::builtin::equal(a,
                                                                                                      f(x)))))
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn fold<E>(self, init: E, f: ::builtin::FnSpec<(E, A), E>)
             -> E {
                ::builtin::decreases((self.len(),));
                if self.finite() {
                    if ::builtin::spec_eq(self.len(),
                                          ::builtin::spec_literal_nat("0")) {
                        init
                    } else {
                        let a = self.choose();
                        self.remove(a).fold(f(init, a), f)
                    }
                } else { arbitrary() }
            }
        }
        #[verifier(verus_macro)]
        #[proof]
        pub fn lemma_len0_is_empty<A>(s: Set<A>) {
            ::builtin::requires([s.finite(),
                                 ::builtin::spec_eq(s.len(),
                                                    ::builtin::spec_literal_nat("0"))]);
            ::builtin::ensures([::builtin::equal(s, Set::empty())]);
            if ::builtin::exists(|a: A| s.contains(a)) {
                ::builtin::assert_(::builtin::spec_eq((s.remove(s.choose()).len()).spec_add(::builtin::spec_literal_nat("1")),
                                                      ::builtin::spec_literal_nat("0")));
            }
            ::builtin::assert_(s.ext_equal(Set::empty()));
        }
        #[verifier(verus_macro)]
        #[proof]
        pub fn lemma_len_union<A>(s1: Set<A>, s2: Set<A>) {
            ::builtin::requires([s1.finite(), s2.finite()]);
            ::builtin::ensures([(s1.union(s2).len()).spec_le((s1.len()).spec_add(s2.len()))]);
            ::builtin::decreases((s1.len(),));
            if s1.is_empty() {
                ::builtin::assert_(s1.union(s2).ext_equal(s2));
            } else {
                let a = s1.choose();
                if s2.contains(a) {
                    ::builtin::assert_(s1.union(s2).ext_equal(s1.remove(a).union(s2)));
                } else {
                    ::builtin::assert_(s1.union(s2).remove(a).ext_equal(s1.remove(a).union(s2)));
                }
                lemma_len_union::<A>(s1.remove(a), s2);
            }
        }
        #[verifier(verus_macro)]
        #[proof]
        pub fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>) {
            ::builtin::requires([s1.finite()]);
            ::builtin::ensures([(s1.intersect(s2).len()).spec_le(s1.len())]);
            ::builtin::decreases((s1.len(),));
            if s1.is_empty() {
                ::builtin::assert_(s1.intersect(s2).ext_equal(s1));
            } else {
                let a = s1.choose();
                ::builtin::assert_(s1.intersect(s2).remove(a).ext_equal(s1.remove(a).intersect(s2)));
                lemma_len_intersect::<A>(s1.remove(a), s2);
            }
        }
        #[verifier(verus_macro)]
        #[proof]
        pub fn lemma_len_subset<A>(s1: Set<A>, s2: Set<A>) {
            ::builtin::requires([s2.finite(), s1.subset_of(s2)]);
            ::builtin::ensures([(s1.len()).spec_le(s2.len()), s1.finite()]);
            lemma_len_intersect::<A>(s2, s1);
            ::builtin::assert_(s2.intersect(s1).ext_equal(s1));
        }
        #[verifier(verus_macro)]
        #[proof]
        pub fn lemma_len_difference<A>(s1: Set<A>, s2: Set<A>) {
            ::builtin::requires([s1.finite()]);
            ::builtin::ensures([(s1.difference(s2).len()).spec_le(s1.len())]);
            ::builtin::decreases((s1.len(),));
            if s1.is_empty() {
                ::builtin::assert_(s1.difference(s2).ext_equal(s1));
            } else {
                let a = s1.choose();
                ::builtin::assert_(s1.difference(s2).remove(a).ext_equal(s1.remove(a).difference(s2)));
                lemma_len_difference::<A>(s1.remove(a), s2);
            }
        }
        #[verifier(verus_macro)]
        #[proof]
        pub fn lemma_len_filter<A>(s: Set<A>,
                                   f: ::builtin::FnSpec<(A,), bool>) {
            ::builtin::requires([s.finite()]);
            ::builtin::ensures([s.filter(f).finite(),
                                (s.filter(f).len()).spec_le(s.len())]);
            ::builtin::decreases((s.len(),));
            lemma_len_intersect::<A>(s, Set::new(f));
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn set_int_range(lo: int, hi: int) -> Set<int> {
            Set::new(::builtin::closure_to_fn_spec(|i: int|
                                                       (lo).spec_le(i) &&
                                                           (i).spec_lt(hi)))
        }
        #[verifier(verus_macro)]
        #[proof]
        pub fn lemma_int_range(lo: int, hi: int) {
            ::builtin::requires([(lo).spec_le(hi)]);
            ::builtin::ensures([set_int_range(lo, hi).finite(),
                                ::builtin::spec_eq(set_int_range(lo,
                                                                 hi).len(),
                                                   (hi).spec_sub(lo))]);
            ::builtin::decreases(((hi).spec_sub(lo),));
            if ::builtin::spec_eq(lo, hi) {
                ::builtin::assert_(set_int_range(lo,
                                                 hi).ext_equal(Set::empty()));
            } else {
                lemma_int_range(lo,
                                (hi).spec_sub(::builtin::spec_literal_nat("1")));
                ::builtin::assert_(set_int_range(lo,
                                                 (hi).spec_sub(::builtin::spec_literal_nat("1"))).insert((hi).spec_sub(::builtin::spec_literal_nat("1"))).ext_equal(set_int_range(lo,
                                                                                                                                                                                  hi)));
            }
        }
        #[doc(hidden)]
        #[verifier(inline)]
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn check_argument_is_set<A>(s: Set<A>) -> Set<A> { s }
        #[doc = " Prove two sets equal by extensionality. Usage is:"]
        #[doc = ""]
        #[doc = " ```rust"]
        #[doc = " assert_sets_equal!(set1, set2);"]
        #[doc = " ```"]
        #[doc = " "]
        #[doc = " or,"]
        #[doc = " "]
        #[doc = " ```rust"]
        #[doc = " assert_sets_equal!(set1, set2, elem => {"]
        #[doc =
          "     // prove that set1.contains(elem) iff set2.contains(elem)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[macro_export]
        macro_rules! assert_sets_equal {
            [$($tail : tt) *] =>
            {
                :: builtin_macros :: verus_proof_macro_exprs!
                ($crate :: pervasive :: set_lib :: assert_sets_equal_internal!
                 ($($tail) *))
            } ;
        }
        #[macro_export]
        #[doc(hidden)]
        macro_rules! assert_sets_equal_internal {
            ($s1 : expr, $s2 : expr $(,) ?) =>
            { assert_sets_equal_internal! ($s1, $s2, elem => { }) } ;
            ($s1 : expr, $s2 : expr, $elem : ident $(: $t : ty) ? => $bblock :
             block) =>
            {
                let s1 = $crate :: pervasive :: set_lib ::
                check_argument_is_set($s1) ; let s2 = $crate :: pervasive ::
                set_lib :: check_argument_is_set($s2) ; :: builtin ::
                assert_by(:: builtin :: equal(s1, s2),
                          {
                              :: builtin ::
                              assert_forall_by(| $elem $(: $t) ? |
                                               {
                                                   :: builtin ::
                                                   ensures(:: builtin ::
                                                           imply(s1.contains($elem),
                                                                 s2.contains($elem))
                                                           && :: builtin ::
                                                           imply(s2.contains($elem),
                                                                 s1.contains($elem)))
                                                   ; { $bblock }
                                               }) ; $crate :: pervasive ::
                              assert(s1.ext_equal(s2)) ;
                          }) ;
            }
        }
        pub use assert_sets_equal_internal;
        pub use assert_sets_equal;
    }
    pub mod slice {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use crate::pervasive::seq::*;
        use crate::pervasive::vec::*;
        pub trait SliceAdditionalSpecFns<T> {
            #[verifier(verus_macro)]
            #[spec]
            fn view(&self) -> Seq<T> { ::builtin::no_method_body() }
            #[verifier(verus_macro)]
            #[spec]
            fn spec_index(&self, i: int) -> T { ::builtin::no_method_body() }
        }
        impl <T> SliceAdditionalSpecFns<T> for [T] {
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            fn view(&self) -> Seq<T> {
                ::core::panicking::panic("not implemented")
            }
            #[verifier(inline)]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            fn spec_index(&self, i: int) -> T { self.view().index(i) }
        }
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        #[exec]
        pub fn slice_index_get<T>(slice: &[T], i: usize) -> &T {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                   i),
                                                                                        slice.view().len()))]);
            ::builtin::ensures(|out: &T|
                                   [::builtin::equal(*out,
                                                     (slice.view()).index(::builtin::spec_cast_integer::<_,
                                                                                                         int>(i)))]);
            &slice[i]
        }
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        #[exec]
        pub fn slice_to_vec<T: Copy>(slice: &[T]) -> Vec<T> {
            ::builtin::ensures(|out: Vec<T>|
                                   [::builtin::equal((out.view()),
                                                     (slice.view()))]);
            Vec{vec: slice.to_vec(),}
        }
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        #[exec]
        pub fn slice_subrange<'a, T>(slice: &'a [T], i: usize, j: usize)
         -> &'a [T] {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                                              i),
                                                                                                                   j),
                                                                                        (slice.view()).len()))]);
            ::builtin::ensures(|out: &'a [T]|
                                   [::builtin::equal((out.view()),
                                                     (slice.view()).subrange(::builtin::spec_cast_integer::<_,
                                                                                                            int>(i),
                                                                             ::builtin::spec_cast_integer::<_,
                                                                                                            int>(j)))]);
            &slice[i..j]
        }
    }
    pub mod cell {
        use core::cell::UnsafeCell;
        use core::{mem, mem::MaybeUninit};
        use core::marker;
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[allow(unused_imports)]
        use crate::pervasive::modes::*;
        #[allow(unused_imports)]
        use crate::pervasive::invariant::*;
        #[allow(unused_imports)]
        use crate::pervasive::set::*;
        #[doc =
          " `PCell<V>` (which stands for \"permissioned call\") is the primitive Verus `Cell` type."]
        #[doc = ""]
        #[doc = " Technically, it is a wrapper around"]
        #[doc =
          " `core::cell::UnsafeCell<core::mem::MaybeUninit<V>>`, and thus has the same runtime"]
        #[doc =
          " properties: there are no runtime checks (as there would be for Rust\'s traditional"]
        #[doc =
          " [`core::cell::RefCell`](https://doc.rust-lang.org/core/cell/struct.RefCell.html))."]
        #[doc = " Its data may be uninitialized."]
        #[doc = ""]
        #[doc = " Furthermore (and unlike both"]
        #[doc =
          " [`core::cell::Cell`](https://doc.rust-lang.org/core/cell/struct.Cell.html) and"]
        #[doc =
          " [`core::cell::RefCell`](https://doc.rust-lang.org/core/cell/struct.RefCell.html)),"]
        #[doc = " a `PCell<V>` may be `Sync` (depending on `V`)."]
        #[doc =
          " Thanks to verification, Verus ensures that access to the cell is data-race-free."]
        #[doc = ""]
        #[doc =
          " `PCell` uses a _ghost permission token_ similar to [`ptr::PPtr`] -- see the [`ptr::PPtr`]"]
        #[doc = " documentation for the basics."]
        #[doc =
          " For `PCell`, the associated type of the permission token is [`cell::PermissionOpt`]."]
        #[doc = ""]
        #[doc = " ### Differences from `PPtr`."]
        #[doc = ""]
        #[doc =
          " The key difference is that, whereas [`ptr::PPtr`] represents a fixed address in memory,"]
        #[doc =
          " a `PCell` has _no_ fixed address because a `PCell` might be moved."]
        #[doc =
          " As such, the [`pcell.id()`](PCell::id) does not correspond to a memory address; rather,"]
        #[doc =
          " it is a unique identifier that is fixed for a given cell, even when it is moved."]
        #[doc = ""]
        #[doc =
          " The arbitrary ID given by [`pcell.id()`](PCell::id) is of type [`CellId`]."]
        #[doc =
          " Despite the fact that it is, in some ways, \"like a pointer\", note that"]
        #[doc = " `CellId` does not support any meangingful arithmetic,"]
        #[doc = " has no concept of a \"null ID\","]
        #[doc = " and has no runtime representation."]
        #[doc = ""]
        #[doc =
          " Also note that the `PCell` might be dropped before the `PermissionOpt` token is dropped,"]
        #[doc =
          " although in that case it will no longer be possible to use the `PermissionOpt` in `exec` code"]
        #[doc = " to extract data from the cell."]
        #[doc = ""]
        #[doc = " ### Example (TODO)"]
        #[verifier(external_body)]
        pub struct PCell<#[verifier(strictly_positive)] V> {
            ucell: UnsafeCell<MaybeUninit<V>>,
        }
        #[verifier(external)]
        unsafe impl <T> Sync for PCell<T> { }
        #[verifier(external)]
        unsafe impl <T> Send for PCell<T> { }
        #[verifier(external_body)]
        #[proof]
        pub struct PermissionOpt<#[verifier(strictly_positive)] V> {
            phantom: marker::PhantomData<V>,
            no_copy: NoCopy,
        }
        #[spec]
        pub struct PermissionOptData<V> {
            pub pcell: CellId,
            pub value: option::Option<V>,
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! pcell_opt_internal {
            [$pcell : expr => $val : expr] =>
            {
                $crate :: pervasive :: cell :: PermissionOptData
                { pcell : $pcell, value : $val, }
            } ;
        }
        #[macro_export]
        macro_rules! pcell_opt {
            [$($tail : tt) *] =>
            {
                :: builtin_macros :: verus_proof_macro_exprs!
                ($crate :: pervasive :: cell :: pcell_opt_internal!
                 ($($tail) *))
            }
        }
        pub use pcell_opt_internal;
        pub use pcell_opt;
        #[verifier(external_body)]
        pub struct CellId {
            id: int,
        }
        impl <V> PermissionOpt<V> {
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermissionOptData<V> {
                ::core::panicking::panic("not implemented")
            }
        }
        impl <V> PCell<V> {
            #[doc = " A unique ID for the cell."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> CellId {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Return an empty (\"uninitialized\") cell."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn empty() -> (PCell<V>, Tracked<PermissionOpt<V>>) {
                ::builtin::ensures(|pt: (PCell<V>, Tracked<PermissionOpt<V>>)|
                                       [::builtin::equal(((pt.1.view()).view()),
                                                         crate::pervasive::cell::PermissionOptData{pcell:
                                                                                                       pt.0.id(),
                                                                                                   value:
                                                                                                       option::Option::None,})]);
                let p = PCell{ucell: UnsafeCell::new(MaybeUninit::uninit()),};
                (p, Tracked::assume_new())
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn put(&self, perm: &mut Tracked<PermissionOpt<V>>, v: V) {
                ::builtin::requires([::builtin::equal(((old(perm).view()).view()),
                                                      crate::pervasive::cell::PermissionOptData{pcell:
                                                                                                    self.id(),
                                                                                                value:
                                                                                                    option::Option::None,})]);
                ::builtin::ensures([::builtin::equal(((perm.view()).view()),
                                                     crate::pervasive::cell::PermissionOptData{pcell:
                                                                                                   self.id(),
                                                                                               value:
                                                                                                   option::Option::Some(v),})]);
                opens_invariants_none();
                unsafe { *(self.ucell.get()) = MaybeUninit::new(v); }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn take(&self, perm: &mut Tracked<PermissionOpt<V>>) -> V {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      ((old(perm).view()).view()).pcell),
                                     ((old(perm).view()).view()).value.is_Some()]);
                ::builtin::ensures(|v: V|
                                       [::builtin::equal(((perm.view()).view()).pcell,
                                                         ((old(perm).view()).view()).pcell),
                                        ::builtin::equal(((perm.view()).view()).value,
                                                         option::Option::None),
                                        ::builtin::equal(v,
                                                         ((old(perm).view()).view()).value.get_Some_0())]);
                opens_invariants_none();
                unsafe {
                    let mut m = MaybeUninit::uninit();
                    mem::swap(&mut m, &mut *self.ucell.get());
                    m.assume_init()
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn replace(&self, perm: &mut Tracked<PermissionOpt<V>>,
                           in_v: V) -> V {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      ((old(perm).view()).view()).pcell),
                                     ((old(perm).view()).view()).value.is_Some()]);
                ::builtin::ensures(|out_v: V|
                                       [::builtin::equal(((perm.view()).view()).pcell,
                                                         ((old(perm).view()).view()).pcell),
                                        ::builtin::equal(((perm.view()).view()).value,
                                                         option::Option::Some(in_v)),
                                        ::builtin::equal(out_v,
                                                         ((old(perm).view()).view()).value.get_Some_0())]);
                opens_invariants_none();
                unsafe {
                    let mut m = MaybeUninit::new(in_v);
                    mem::swap(&mut m, &mut *self.ucell.get());
                    m.assume_init()
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn borrow<'a>(&'a self, perm: &'a Tracked<PermissionOpt<V>>)
             -> &'a V {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      ((perm.view()).view()).pcell),
                                     ((perm.view()).view()).value.is_Some()]);
                ::builtin::ensures(|v: &'a V|
                                       [::builtin::equal(*v,
                                                         ((perm.view()).view()).value.get_Some_0())]);
                opens_invariants_none();
                unsafe { (*self.ucell.get()).assume_init_ref() }
            }
            #[inline(always)]
            #[verifier(verus_macro)]
            pub fn into_inner(self, perm: Tracked<PermissionOpt<V>>) -> V {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      ((perm.view()).view()).pcell),
                                     ((perm.view()).view()).value.is_Some()]);
                ::builtin::ensures(|v: V|
                                       [::builtin::equal(v,
                                                         ((perm.view()).view()).value.get_Some_0())]);
                opens_invariants_none();
                let mut perm = perm;
                self.take(&mut perm)
            }
            #[inline(always)]
            #[verifier(verus_macro)]
            pub fn new(v: V) -> (PCell<V>, Tracked<PermissionOpt<V>>) {
                ::builtin::ensures(|pt: (PCell<V>, Tracked<PermissionOpt<V>>)|
                                       [(::builtin::equal(((pt.1.view()).view()),
                                                          PermissionOptData{pcell:
                                                                                pt.0.id(),
                                                                            value:
                                                                                option::Option::Some(v),}))]);
                let (p, mut t) = Self::empty();
                p.put(&mut t, v);
                (p, t)
            }
        }
        struct InvCellPred {
        }
        impl <T> InvariantPredicate<(Set<T>, PCell<T>), PermissionOpt<T>> for
         InvCellPred {
            #[verifier(verus_macro)]
            #[spec]
            fn inv(k: (Set<T>, PCell<T>), perm: PermissionOpt<T>) -> bool {
                let (possible_values, pcell) = k;
                {
                    (((perm.view()).value.is_Some()) &&
                         (possible_values.contains((perm.view()).value.get_Some_0())))
                        && (::builtin::equal(pcell.id(), (perm.view()).pcell))
                }
            }
        }
        pub struct InvCell<#[verifier(maybe_negative)] T> {
            possible_values: Ghost<Set<T>>,
            pcell: PCell<T>,
            perm_inv: Tracked<LocalInvariant<(Set<T>, PCell<T>),
                                             PermissionOpt<T>, InvCellPred>>,
        }
        impl <T> InvCell<T> {
            #[verifier(verus_macro)]
            #[spec]
            pub fn wf(&self) -> bool {
                ::builtin::equal((self.perm_inv.view()).constant(),
                                 ((self.possible_values.view()), self.pcell))
            }
            #[verifier(verus_macro)]
            #[spec]
            pub fn inv(&self, val: T) -> bool {
                (self.possible_values.view()).contains(val)
            }
            #[verifier(verus_macro)]
            pub fn new(val: T,
                       #[spec] f: Ghost<::builtin::FnSpec<(T,), bool>>)
             -> Self {
                ::builtin::requires([(f.view())(val)]);
                ::builtin::ensures(|cell: Self|
                                       [cell.wf() &&
                                            ::builtin::forall(|v|
                                                                  ::builtin::spec_eq(((f.view())(v)),
                                                                                     (cell.inv(v))))]);
                let (pcell, perm) = PCell::new(val);
                let possible_values =
                    #[verifier(ghost_wrapper)] crate::pervasive::modes::ghost_exec(#[verifier(ghost_block_wrapped)] (Set::new((f.view()))));
                let perm_inv =
                    #[verifier(ghost_wrapper)] crate::pervasive::modes::tracked_exec(#[verifier(tracked_block_wrapped)] (LocalInvariant::new(((possible_values.view()),
                                                                                                                                              pcell),
                                                                                                                                             perm.get(),
                                                                                                                                             ::builtin::spec_literal_integer("0"))));
                InvCell{possible_values, pcell, perm_inv,}
            }
            pub fn replace(&self, val: T) -> T {
                requires(self.wf() && self.inv(val));
                ensures(|old_val| self.inv(old_val));
                let r;

                #[verifier(invariant_block)]
                {
                    #[allow(unused_mut)]
                    let (guard, mut perm) =
                        crate::pervasive::invariant::open_local_invariant_begin(self.perm_inv.borrow());
                    {
                        let mut t = tracked_exec(perm);
                        r = self.pcell.replace(&mut t, val);
                        perm = t.get();
                    }
                    crate::pervasive::invariant::open_invariant_end(guard,
                                                                    perm);
                };
                r
            }
        }
        impl <T: Copy> InvCell<T> {
            pub fn get(&self) -> T {
                requires(self.wf());
                ensures(|val| self.inv(val));
                let r;

                #[verifier(invariant_block)]
                {
                    #[allow(unused_mut)]
                    let (guard, mut perm) =
                        crate::pervasive::invariant::open_local_invariant_begin(self.perm_inv.borrow());
                    { r = *self.pcell.borrow(tracked_exec_borrow(&perm)); }
                    crate::pervasive::invariant::open_invariant_end(guard,
                                                                    perm);
                };
                r
            }
        }
    }
    pub mod cell_old_style {
        use core::cell::UnsafeCell;
        use core::{mem, mem::MaybeUninit};
        use core::marker;
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[allow(unused_imports)]
        use crate::pervasive::modes::*;
        #[allow(unused_imports)]
        use crate::pervasive::invariant::*;
        #[allow(unused_imports)]
        use crate::pervasive::set::*;
        #[doc =
          " `PCell<V>` (which stands for \"permissioned call\") is the primitive Verus `Cell` type."]
        #[doc = ""]
        #[doc = " Technically, it is a wrapper around"]
        #[doc =
          " `core::cell::UnsafeCell<core::mem::MaybeUninit<V>>`, and thus has the same runtime"]
        #[doc =
          " properties: there are no runtime checks (as there would be for Rust\'s traditional"]
        #[doc =
          " [`core::cell::RefCell`](https://doc.rust-lang.org/core/cell/struct.RefCell.html))."]
        #[doc = " Its data may be uninitialized."]
        #[doc = ""]
        #[doc = " Furthermore (and unlike both"]
        #[doc =
          " [`core::cell::Cell`](https://doc.rust-lang.org/core/cell/struct.Cell.html) and"]
        #[doc =
          " [`core::cell::RefCell`](https://doc.rust-lang.org/core/cell/struct.RefCell.html)),"]
        #[doc = " a `PCell<V>` may be `Sync` (depending on `V`)."]
        #[doc =
          " Thanks to verification, Verus ensures that access to the cell is data-race-free."]
        #[doc = ""]
        #[doc =
          " `PCell` uses a _ghost permission token_ similar to [`ptr::PPtr`] -- see the [`ptr::PPtr`]"]
        #[doc = " documentation for the basics."]
        #[doc =
          " For `PCell`, the associated type of the permission token is [`cell::PermData`]."]
        #[doc = ""]
        #[doc = " ### Differences from `PPtr`."]
        #[doc = ""]
        #[doc =
          " The key difference is that, whereas [`ptr::PPtr`] represents a fixed address in memory,"]
        #[doc =
          " a `PCell` has _no_ fixed address because a `PCell` might be moved."]
        #[doc =
          " As such, the [`pcell.id()`](PCell::id) does not correspond to a memory address; rather,"]
        #[doc =
          " it is a unique identifier that is fixed for a given cell, even when it is moved."]
        #[doc = ""]
        #[doc =
          " The arbitrary ID given by [`pcell.id()`](PCell::id) is of type [`CellId`]."]
        #[doc =
          " Despite the fact that it is, in some ways, \"like a pointer\", note that"]
        #[doc = " `CellId` does not support any meangingful arithmetic,"]
        #[doc = " has no concept of a \"null ID\","]
        #[doc = " and has no runtime representation."]
        #[doc = ""]
        #[doc =
          " Also note that the `PCell` might be dropped before the `PermData` token is dropped,"]
        #[doc =
          " although in that case it will no longer be possible to use the `PermData` in `exec` code"]
        #[doc = " to extract data from the cell."]
        #[doc = ""]
        #[doc = " ### Example (TODO)"]
        #[verifier(external_body)]
        pub struct PCell<#[verifier(strictly_positive)] V> {
            ucell: UnsafeCell<MaybeUninit<V>>,
        }
        #[verifier(external)]
        unsafe impl <T> Sync for PCell<T> { }
        #[verifier(external)]
        unsafe impl <T> Send for PCell<T> { }
        #[verifier(external_body)]
        #[proof]
        pub struct PermData<#[verifier(strictly_positive)] V> {
            phantom: marker::PhantomData<V>,
            no_copy: NoCopy,
        }
        #[spec]
        pub struct PermDataData<V> {
            pub pcell: CellId,
            pub value: option::Option<V>,
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! old_style_pcell_opt_internal {
            [$pcell : expr => $val : expr] =>
            {
                $crate :: pervasive :: cell_old_style :: PermDataData
                { pcell : $pcell, value : $val, }
            } ;
        }
        #[macro_export]
        macro_rules! old_style_pcell_opt {
            [$($tail : tt) *] =>
            {
                :: builtin_macros :: verus_proof_macro_exprs!
                ($crate :: pervasive :: cell_old_style :: pcell_opt_internal!
                 ($($tail) *))
            }
        }
        pub use old_style_pcell_opt_internal as pcell_opt_internal;
        pub use old_style_pcell_opt as pcell_opt;
        #[verifier(external_body)]
        pub struct CellId {
            id: int,
        }
        impl <V> PermData<V> {
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermDataData<V> {
                ::core::panicking::panic("not implemented")
            }
        }
        impl <V> PCell<V> {
            #[doc = " A unique ID for the cell."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> CellId {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Return an empty (\"uninitialized\") cell."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn empty() -> (PCell<V>, Trk<PermData<V>>) {
                ::builtin::ensures(|pt: (PCell<V>, Trk<PermData<V>>)|
                                       [::builtin::equal((pt.1.0.view()),
                                                         crate::pervasive::cell_old_style::PermDataData{pcell:
                                                                                                            pt.0.id(),
                                                                                                        value:
                                                                                                            option::Option::None,})]);
                let p = PCell{ucell: UnsafeCell::new(MaybeUninit::uninit()),};
                (p, Trk(proof_from_false()))
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn put(&self, #[proof] perm: &mut PermData<V>, v: V) {
                ::builtin::requires([::builtin::equal((old(perm).view()),
                                                      crate::pervasive::cell_old_style::PermDataData{pcell:
                                                                                                         self.id(),
                                                                                                     value:
                                                                                                         option::Option::None,})]);
                ::builtin::ensures([::builtin::equal((perm.view()),
                                                     crate::pervasive::cell_old_style::PermDataData{pcell:
                                                                                                        self.id(),
                                                                                                    value:
                                                                                                        option::Option::Some(v),})]);
                opens_invariants_none();
                unsafe { *(self.ucell.get()) = MaybeUninit::new(v); }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn take(&self, #[proof] perm: &mut PermData<V>) -> V {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      (old(perm).view()).pcell),
                                     (old(perm).view()).value.is_Some()]);
                ::builtin::ensures(|v: V|
                                       [::builtin::equal((perm.view()).pcell,
                                                         (old(perm).view()).pcell),
                                        ::builtin::equal((perm.view()).value,
                                                         option::Option::None),
                                        ::builtin::equal(v,
                                                         (old(perm).view()).value.get_Some_0())]);
                opens_invariants_none();
                unsafe {
                    let mut m = MaybeUninit::uninit();
                    mem::swap(&mut m, &mut *self.ucell.get());
                    m.assume_init()
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn replace(&self, #[proof] perm: &mut PermData<V>, in_v: V)
             -> V {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      (old(perm).view()).pcell),
                                     (old(perm).view()).value.is_Some()]);
                ::builtin::ensures(|out_v: V|
                                       [::builtin::equal((perm.view()).pcell,
                                                         (old(perm).view()).pcell),
                                        ::builtin::equal((perm.view()).value,
                                                         option::Option::Some(in_v)),
                                        ::builtin::equal(out_v,
                                                         (old(perm).view()).value.get_Some_0())]);
                opens_invariants_none();
                unsafe {
                    let mut m = MaybeUninit::new(in_v);
                    mem::swap(&mut m, &mut *self.ucell.get());
                    m.assume_init()
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn borrow<'a>(&'a self, #[proof] perm: &'a PermData<V>)
             -> &'a V {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      (perm.view()).pcell),
                                     (perm.view()).value.is_Some()]);
                ::builtin::ensures(|v: &'a V|
                                       [::builtin::equal(*v,
                                                         (perm.view()).value.get_Some_0())]);
                opens_invariants_none();
                unsafe { (*self.ucell.get()).assume_init_ref() }
            }
            #[inline(always)]
            pub fn into_inner(self, #[proof] perm: PermData<V>) -> V {
                requires([equal(self.id(), perm.view().pcell),
                          perm.view().value.is_Some()]);
                ensures(|v: V| [equal(v, perm.view().value.get_Some_0())]);
                opens_invariants_none();
                #[proof]
                let mut perm = perm;
                self.take(&mut perm)
            }
            #[inline(always)]
            #[verifier(verus_macro)]
            pub fn new(v: V) -> (PCell<V>, Trk<PermData<V>>) {
                ::builtin::ensures(|pt: (PCell<V>, Trk<PermData<V>>)|
                                       [(::builtin::equal((pt.1.0.view()),
                                                          PermDataData{pcell:
                                                                           pt.0.id(),
                                                                       value:
                                                                           option::Option::Some(v),}))]);
                let (p, Trk(mut t)) = Self::empty();
                p.put(&mut t, v);
                (p, Trk(t))
            }
        }
        pub struct InvCell<#[verifier(maybe_negative)] T> {
            #[spec]
            possible_values: Set<T>,
            pcell: PCell<T>,
            #[proof]
            perm_inv: LocalInvariant<(FieldType_InvCell_possible_values<T>,
                                      FieldType_InvCell_pcell<T>),
                                     PermData<T>,
                                     InvariantPredicate_auto_InvCell_perm_inv>,
        }
        pub type FieldType_InvCell_possible_values<T> = Set<T>;
        pub type FieldType_InvCell_pcell<T> = PCell<T>;
        pub type FieldType_InvCell_perm_inv<T> =
         LocalInvariant<(FieldType_InvCell_possible_values<T>,
                         FieldType_InvCell_pcell<T>), PermData<T>,
                        InvariantPredicate_auto_InvCell_perm_inv>;
        pub struct InvariantPredicate_auto_InvCell_perm_inv {
        }
        impl <#[verifier(maybe_negative)] T>
         crate::pervasive::invariant::InvariantPredicate<(FieldType_InvCell_possible_values<T>,
                                                          FieldType_InvCell_pcell<T>),
                                                         PermData<T>> for
         InvariantPredicate_auto_InvCell_perm_inv {
            #[verifier(verus_macro)]
            #[spec]
            fn inv(declare_struct_with_invariants_tmp_k:
                       (FieldType_InvCell_possible_values<T>,
                        FieldType_InvCell_pcell<T>),
                   declare_struct_with_invariants_tmp_v: PermData<T>)
             -> bool {
                let (possible_values, pcell) =
                    declare_struct_with_invariants_tmp_k;
                let perm = declare_struct_with_invariants_tmp_v;
                {
                    perm.view().value.is_Some() &&
                        possible_values.contains(perm.view().value.get_Some_0())
                        && equal(pcell.id(), perm.view().pcell)
                }
            }
        }
        impl <#[verifier(maybe_negative)] T> InvCell<T> {
            #[verifier(verus_macro)]
            #[spec]
            pub fn wf(&self) -> bool {
                true &&
                    ::builtin::equal(self.perm_inv.constant().0,
                                     self.possible_values) &&
                    ::builtin::equal(self.perm_inv.constant().1, self.pcell)
            }
        }
        impl <T> InvCell<T> {
            #[spec]
            pub fn inv(&self, val: T) -> bool {
                self.possible_values.contains(val)
            }
            pub fn new(val: T, #[spec] f: FnSpec<(T,), bool>) -> Self {
                requires(f(val));
                ensures(|cell: Self|
                            cell.wf() && forall(|v| f(v) == cell.inv(v)));
                let (pcell, Trk(perm)) = PCell::new(val);
                #[spec]
                let possible_values = Set::new(f);
                #[proof]
                let perm_inv =
                    LocalInvariant::new((possible_values, pcell), perm,
                                        ::builtin::spec_literal_integer("0"));
                InvCell{possible_values, pcell, perm_inv,}
            }
            pub fn replace(&self, val: T) -> T {
                requires(self.wf() && self.inv(val));
                ensures(|old_val| self.inv(old_val));
                let r;

                #[verifier(invariant_block)]
                {
                    #[allow(unused_mut)]
                    let (guard, mut perm) =
                        crate::pervasive::invariant::open_local_invariant_begin(&self.perm_inv);
                    { r = self.pcell.replace(&mut perm, val); }
                    crate::pervasive::invariant::open_invariant_end(guard,
                                                                    perm);
                };
                r
            }
        }
        impl <T: Copy> InvCell<T> {
            pub fn get(&self) -> T {
                requires(self.wf());
                ensures(|val| self.inv(val));
                let r;

                #[verifier(invariant_block)]
                {
                    #[allow(unused_mut)]
                    let (guard, mut perm) =
                        crate::pervasive::invariant::open_local_invariant_begin(&self.perm_inv);
                    { r = *self.pcell.borrow(&perm); }
                    crate::pervasive::invariant::open_invariant_end(guard,
                                                                    perm);
                };
                r
            }
        }
    }
    pub mod invariant {
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[doc = " Trait used to specify an _invariant predicate_ for"]
        #[doc = " [`LocalInvariant`] and [`AtomicInvariant`]."]
        pub trait InvariantPredicate<K, V> {
            #[verifier(verus_macro)]
            #[spec]
            fn inv(k: K, v: V) -> bool { ::builtin::no_method_body() }
        }
        /// An `AtomicInvariant` is a ghost object that provides "interior mutability"
        /// for ghost objects, specifically, for `tracked` ghost objects.
        /// A reference `&AtomicInvariant` may be shared between clients.
        /// A client holding such a reference may _open_ the invariant
        /// to obtain ghost ownership of `v1: V`, and then _close_ the invariant by returning
        /// ghost ownership of a (potentially) different object `v2: V`.
        ///
        /// An `AtomicInvariant` implements [`Sync`](https://doc.rust-lang.org/std/sync/)
        /// and may be shared between threads.
        /// However, this means that an `AtomicInvariant` can be only opened for
        /// the duration of a single _sequentially consistent atomic_ operation.
        /// Such operations are provided by our [`PAtomic`](crate::pervasive::atomic) library.
        /// For an invariant object without this atomicity restriction,
        /// see [`LocalInvariant`], which gives up thread safety in exchange.
        ///
        /// An `AtomicInvariant` consists of:
        ///
        ///  * A _predicate_ specified via the `InvariantPredicate` type bound, that determines
        ///    what values `V` may be saved inside the invariant.
        ///  * A _constant_ `K`, specified at construction type. The predicate function takes
        ///    this constant as a parameter, so the constant allows users to dynamically configure
        ///    the predicate function in a way that can't be done at the type level.
        ///  * A _namespace_. This is a bit of a technicality, and you can often just declare
        ///    it as an arbitrary integer with no issues. See the [`open_local_invariant!`]
        ///    documentation for more details.
        ///
        /// The constant and namespace are specified at construction time ([`AtomicInvariant::new`]).
        /// These values are fixed for the lifetime of the `AtomicInvariant` object.
        /// To open the invariant and access the stored object `V`,
        /// use the macro [`open_atomic_invariant!`].
        ///
        /// The `AtomicInvariant` API is an instance of the ["invariant" method in Verus's general philosophy on interior mutability](https://verus-lang.github.io/verus/guide/interior_mutability.html).
        ///
        /// **Note:** Rather than using `AtomicInvariant` directly, we generally recommend
        /// using the [`atomic_ghost` APIs](atomic_ghost).
        #[proof]
        #[verifier(external_body)]
        pub struct AtomicInvariant<#[verifier(strictly_positive)] K,
                                   #[verifier(strictly_positive)] V,
                                   #[verifier(strictly_positive)] Pred> {
            dummy: builtin::SyncSendIfSend<V>,
            dummy1: core::marker::PhantomData<(K, Pred)>,
        }
        /// A `LocalInvariant` is a ghost object that provides "interior mutability"
        /// for ghost objects, specifically, for `tracked` ghost objects.
        /// A reference `&LocalInvariant` may be shared between clients.
        /// A client holding such a reference may _open_ the invariant
        /// to obtain ghost ownership of `v1: V`, and then _close_ the invariant by returning
        /// ghost ownership of a (potentially) different object `v2: V`.
        ///
        /// A `LocalInvariant` cannot be shared between threads
        /// (that is, it does not implement [`Sync`](https://doc.rust-lang.org/std/sync/)).
        /// However, this means that a `LocalInvariant` can be opened for an indefinite length
        /// of time, since there is no risk of a race with another thread.
        /// For an invariant object with the opposite properties, see [`AtomicInvariant`].
        ///
        /// A `LocalInvariant` consists of:
        ///
        ///  * A _predicate_ specified via the `InvariantPredicate` type bound, that determines
        ///    what values `V` may be saved inside the invariant.
        ///  * A _constant_ `K`, specified at construction type. The predicate function takes
        ///    this constant as a parameter, so the constant allows users to dynamically configure
        ///    the predicate function in a way that can't be done at the type level.
        ///  * A _namespace_. This is a bit of a technicality, and you can often just declare
        ///    it as an arbitrary integer with no issues. See the [`open_local_invariant!`]
        ///    documentation for more details.
        ///
        /// The constant and namespace are specified at construction time ([`LocalInvariant::new`]).
        /// These values are fixed for the lifetime of the `LocalInvariant` object.
        /// To open the invariant and access the stored object `V`,
        /// use the macro [`open_local_invariant!`].
        ///
        /// The `LocalInvariant` API is an instance of the ["invariant" method in Verus's general philosophy on interior mutability](https://verus-lang.github.io/verus/guide/interior_mutability.html).
        #[proof]
        #[verifier(external_body)]
        pub struct LocalInvariant<#[verifier(strictly_positive)] K,
                                  #[verifier(strictly_positive)] V,
                                  #[verifier(strictly_positive)] Pred> {
            dummy: builtin::SendIfSend<V>,
            dummy1: core::marker::PhantomData<(K, Pred)>,
        }
        macro_rules! declare_invariant_impl {
            ($invariant : ident) =>
            {
                verus!
                {
                    impl < K, V, Pred : InvariantPredicate < K, V >>
                    $invariant < K, V, Pred >
                    {
                        /// The constant specified upon the initialization of this `
                        #[doc = stringify! ($invariant)] ///`.
                        pub spec fn constant(& self) -> K ;
                        /// Namespace the invariant was declared in.
                        pub spec fn namespace(& self) -> int ;
                        /// Returns `true` if it is possible to store the value `v` into the `
                        #[doc = stringify! ($invariant)] ///`.
                        ///
                        /// This is equivalent to `Pred::inv(self.constant(), v)`.
                        pub open spec fn inv(& self, v : V) -> bool
                        { Pred :: inv(self.constant(), v) }
                        /// Initialize a new `
                        #[doc = stringify! ($invariant)]
                        ///` with constant `k`. initial stored (tracked) value `v`,
                        /// and in the namespace `ns`.
                        #[verifier(external_body)] pub proof fn
                        new(k : K, tracked v : V, ns : int) ->
                        (tracked i : $invariant < K, V, Pred >) requires Pred
                        :: inv(k, v), ensures i.constant() == = k,
                        i.namespace() == = ns, { unimplemented! () ; }
                        /// Destroys the `
                        #[doc = stringify! ($invariant)]
                        ///`, returning the tracked value contained within.
                        #[verifier(external_body)] pub proof fn
                        into_inner(#[proof] self) -> (tracked v : V) ensures
                        self.inv(v), { unimplemented! () ; }
                    }
                }
            }
        }
        impl <K, V, Pred: InvariantPredicate<K, V>>
         AtomicInvariant<K, V, Pred> {
            #[doc =
              " The constant specified upon the initialization of this `"]
            #[doc = "AtomicInvariant"]
            #[doc = "`."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn constant(&self) -> K {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Namespace the invariant was declared in."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn namespace(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Returns `true` if it is possible to store the value `v` into the `"]
            #[doc = "AtomicInvariant"]
            #[doc = "`."]
            #[doc = ""]
            #[doc = " This is equivalent to `Pred::inv(self.constant(), v)`."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn inv(&self, v: V) -> bool { Pred::inv(self.constant(), v) }
            #[doc = " Initialize a new `"]
            #[doc = "AtomicInvariant"]
            #[doc =
              "` with constant `k`. initial stored (tracked) value `v`,"]
            #[doc = " and in the namespace `ns`."]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            #[verifier(returns(proof))]
            #[proof]
            pub fn new(k: K, #[proof] v: V, ns: int)
             -> AtomicInvariant<K, V, Pred> {
                ::builtin::requires([Pred::inv(k, v)]);
                ::builtin::ensures(|i: AtomicInvariant<K, V, Pred>|
                                       [::builtin::equal(i.constant(), k),
                                        ::builtin::equal(i.namespace(), ns)]);
                ::core::panicking::panic("not implemented");
            }
            #[doc = " Destroys the `"]
            #[doc = "AtomicInvariant"]
            #[doc = "`, returning the tracked value contained within."]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            #[verifier(returns(proof))]
            #[proof]
            pub fn into_inner(#[proof] self) -> V {
                ::builtin::ensures(|v: V| [self.inv(v)]);
                ::core::panicking::panic("not implemented");
            }
        }
        impl <K, V, Pred: InvariantPredicate<K, V>> LocalInvariant<K, V, Pred>
         {
            #[doc =
              " The constant specified upon the initialization of this `"]
            #[doc = "LocalInvariant"]
            #[doc = "`."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn constant(&self) -> K {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Namespace the invariant was declared in."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn namespace(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Returns `true` if it is possible to store the value `v` into the `"]
            #[doc = "LocalInvariant"]
            #[doc = "`."]
            #[doc = ""]
            #[doc = " This is equivalent to `Pred::inv(self.constant(), v)`."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn inv(&self, v: V) -> bool { Pred::inv(self.constant(), v) }
            #[doc = " Initialize a new `"]
            #[doc = "LocalInvariant"]
            #[doc =
              "` with constant `k`. initial stored (tracked) value `v`,"]
            #[doc = " and in the namespace `ns`."]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            #[verifier(returns(proof))]
            #[proof]
            pub fn new(k: K, #[proof] v: V, ns: int)
             -> LocalInvariant<K, V, Pred> {
                ::builtin::requires([Pred::inv(k, v)]);
                ::builtin::ensures(|i: LocalInvariant<K, V, Pred>|
                                       [::builtin::equal(i.constant(), k),
                                        ::builtin::equal(i.namespace(), ns)]);
                ::core::panicking::panic("not implemented");
            }
            #[doc = " Destroys the `"]
            #[doc = "LocalInvariant"]
            #[doc = "`, returning the tracked value contained within."]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            #[verifier(returns(proof))]
            #[proof]
            pub fn into_inner(#[proof] self) -> V {
                ::builtin::ensures(|v: V| [self.inv(v)]);
                ::core::panicking::panic("not implemented");
            }
        }
        #[doc(hidden)]
        #[proof]
        pub struct InvariantBlockGuard;
        #[doc(hidden)]
        #[verifier(external)]
        pub fn open_atomic_invariant_begin<'a, K, V,
                                           Pred: InvariantPredicate<K,
                                                                    V>>(_inv:
                                                                            &'a AtomicInvariant<K,
                                                                                                V,
                                                                                                Pred>)
         -> (&'a InvariantBlockGuard, V) {
            ::core::panicking::panic("not implemented");
        }
        #[doc(hidden)]
        #[verifier(external)]
        pub fn open_local_invariant_begin<'a, K, V,
                                          Pred: InvariantPredicate<K,
                                                                   V>>(_inv:
                                                                           &'a LocalInvariant<K,
                                                                                              V,
                                                                                              Pred>)
         -> (&'a InvariantBlockGuard, V) {
            ::core::panicking::panic("not implemented");
        }
        #[doc(hidden)]
        #[verifier(external)]
        pub fn open_invariant_end<V>(_guard: &InvariantBlockGuard, _v: V) {
            ::core::panicking::panic("not implemented");
        }
        /// Macro used to temporarily "open" an [`AtomicInvariant`] object, obtaining the stored
        /// value within.
        ///
        /// ### Usage
        ///
        /// The form of the macro looks like,
        ///
        /// ```rust
        /// open_atomic_invariant($inv => $id => {
        ///     // Inner scope
        /// });
        /// ```
        ///
        /// This operation is very similar to [`open_local_invariant!`], so we refer to its
        /// documentation for the basics. There is only one difference, besides
        /// the fact that `$inv` should be an [`&AtomicInvariant`](AtomicInvariant)
        /// rather than a [`&LocalInvariant`](LocalInvariant).
        /// The difference is that `open_atomic_invariant!` has an additional _atomicity constraint_:
        ///
        ///  * **Atomicity constraint**: The code body of an `open_atomic_invariant!` block
        ///    cannot contain any `exec`-mode code with the exception of a _single_ atomic operation.
        ///
        /// (Of course, the code block can still contain an arbitrary amount of ghost code.)
        /// 
        /// The atomicity constraint is needed because an `AtomicInvariant` must be thread-safe;
        /// that is, it can be shared across threads. In order for the ghost state to be shared
        /// safely, it must be restored after each atomic operation.
        ///
        /// The atomic operations may be found in the [`PAtomic`](crate::pervasive::atomic) library.
        /// The user can also mark their own functions as "atomic operations" using
        /// `#[verifier(atomic)]`; however, this is not useful for very much other than defining
        /// wrappers around the existing atomic operations from [`PAtomic`](crate::pervasive::atomic).
        /// Note that reading and writing through a [`PCell`](crate::pervasive::cell::PCell)
        /// or a [`PPtr`](crate::pervasive::ptr::PPtr) are _not_ atomic operations.
        ///
        /// **Note:** Rather than using `open_atomic_invariant!` directly, we generally recommend
        /// using the [`atomic_ghost` APIs](atomic_ghost).
        ///
        /// ### Example
        ///
        /// TODO fill this in
        #[macro_export]
        macro_rules! open_atomic_invariant {
            ($eexpr : expr => $iident : ident => $bblock : block) =>
            {
                #[verifier(invariant_block)]
                {
                    #[allow(unused_mut)] let(guard, mut $iident) = $crate ::
                    pervasive :: invariant ::
                    open_atomic_invariant_begin($eexpr) ; $bblock $crate ::
                    pervasive :: invariant ::
                    open_invariant_end(guard, $iident) ;
                }
            }
        }
        /// Macro used to temporarily "open" a [`LocalInvariant`] object, obtaining the stored
        /// value within.
        ///
        /// ### Usage
        ///
        /// The form of the macro looks like,
        ///
        /// ```rust
        /// open_local_invariant($inv => $id => {
        ///     // Inner scope
        /// });
        /// ```
        /// 
        /// The operation of opening an invariant is a ghost one; however, the inner code block
        /// may contain arbitrary `exec`-mode code. The invariant remains "open" for the duration
        /// of the inner code block, and it is closed again of the end of the block.
        ///
        /// The `$inv` parameter should be an expression of type `&LocalInvariant<K, V, Pred>`,
        /// the invariant object to be opened. The `$id` is an identifier which is bound within
        /// the code block as a `mut` variable of type `V`. This gives the user ownership over
        /// the `V` value, which they may manipulate freely within the code block. At the end
        /// of the code block, the variable `$id` is consumed.
        ///
        /// The obtained object `v: V`, will satisfy the `LocalInvariant`'s invariant predicate
        /// [`$inv.inv(v)`](LocalInvariant::inv). Furthermore, the user must prove that this
        /// invariant still holds at the end. In other words, the macro usage is
        /// roughly equivalent to the following:
        ///
        /// ```rust
        /// {
        ///     let $id: V = /* an arbitrary value */;
        ///     assume($inv.inv($id));
        ///     /* user code block here */
        ///     assert($inv.inv($id));
        ///     consume($id);
        /// }
        /// ```
        ///
        /// ### Avoiding Reentrancy
        ///
        /// Verus adds additional checks to ensure that an invariant is never opened
        /// more than once at the same time. For example, suppose that you attempt to nest
        /// the use of `open_invariant`, supplying the same argument `inv` to each:
        ///
        /// ```rust
        /// open_local_invariant(inv => id1 => {
        ///     open_local_invariant(inv => id2 => {
        ///     });
        /// });
        /// ```
        ///
        /// In this situation, Verus would produce an error:
        ///
        /// ```
        /// error: possible invariant collision
        ///   |
        ///   |   open_atomic_invariant!(&inv => id1 => {
        ///   |                           ^ this invariant
        ///   |     open_atomic_invariant!(&inv => id2 => {
        ///   |                             ^ might be the same as this invariant
        /// ```
        ///
        /// When generating these conditions, Verus compares invariants via their
        /// [`namespace()`](LocalInvariant::namespace) values.
        /// An invariant's namespace (represented simply as an integer)
        /// is specified upon the call to [`LocalInvariant::new`].
        /// If you have the need to open multiple invariants at once, make sure to given
        /// them different namespaces.
        ///
        /// So that Verus can ensure that there are no nested invariant accesses across function
        /// boundaries, every `proof` and `exec` function has, as part of its specification,
        /// the set of invariant namespaces that it might open.
        ///
        /// UNDER CONSTRUCTION: right now the forms of these specifications are somewhat limited
        /// and we expect to expand them.
        ///
        /// The invariant set of a function can be specified by putting either
        /// `opens_invariants_none();` or `opens_invariants_any();` as the first line of the body.
        /// The default for an `exec`-mode function is to open any, while the default
        /// for a `proof`-mode function is to open none.
        ///
        /// ### Example
        ///
        /// TODO fill this in
        ///
        /// ### More Examples
        ///
        /// TODO fill this in 
        #[macro_export]
        macro_rules! open_local_invariant {
            ($eexpr : expr => $iident : ident => $bblock : block) =>
            {
                #[verifier(invariant_block)]
                {
                    #[allow(unused_mut)] let(guard, mut $iident) = $crate ::
                    pervasive :: invariant ::
                    open_local_invariant_begin($eexpr) ; $bblock $crate ::
                    pervasive :: invariant ::
                    open_invariant_end(guard, $iident) ;
                }
            }
        }
    }
    pub mod atomic {
        use core::sync::atomic::{AtomicBool, AtomicU8, AtomicU16, AtomicU32,
                                 AtomicU64, AtomicI8, AtomicI16, AtomicI32,
                                 AtomicI64, Ordering};
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[allow(unused_imports)]
        use crate::pervasive::modes::*;
        #[allow(unused_imports)]
        use crate::pervasive::result::*;
        macro_rules! make_unsigned_integer_atomic {
            ($at_ident : ident, $p_ident : ident, $p_data_ident : ident,
             $rust_ty : ty, $value_ty : ty, $wrap_add : ident, $wrap_sub :
             ident, $int_min : expr, $int_max : expr) =>
            {
                verus!
                {
                    pub open spec fn $wrap_add(a : int, b : int) -> int
                    {
                        if a + b > $int_max
                        { a + b - ($int_max - $int_min + 1) } else { a + b }
                    } pub open spec fn $wrap_sub(a : int, b : int) -> int
                    {
                        if a - b < $int_min
                        { a - b + ($int_max - $int_min + 1) } else { a - b }
                    }
                } atomic_types!
                ($at_ident, $p_ident, $p_data_ident, $rust_ty, $value_ty) ;
                impl $at_ident
                {
                    atomic_common_methods!
                    ($at_ident, $p_ident, $p_data_ident, $rust_ty, $value_ty)
                    ; atomic_integer_methods!
                    ($at_ident, $p_ident, $rust_ty, $value_ty, $wrap_add,
                     $wrap_sub, $int_min, $int_max) ;
                }
            }
        }
        macro_rules! make_signed_integer_atomic {
            ($at_ident : ident, $p_ident : ident, $p_data_ident : ident,
             $rust_ty : ty, $value_ty : ty, $wrap_add : ident, $wrap_sub :
             ident, $int_min : expr, $int_max : expr) =>
            {
                verus!
                {
                    pub open spec fn $wrap_add(a : int, b : int) -> int
                    {
                        if a + b > $int_max
                        { a + b - ($int_max - $int_min + 1) } else if a + b <
                        $int_min { a + b + ($int_max - $int_min + 1) } else
                        { a + b }
                    } pub open spec fn $wrap_sub(a : int, b : int) -> int
                    {
                        if a - b > $int_max
                        { a - b - ($int_max - $int_min + 1) } else if a - b <
                        $int_min { a - b + ($int_max - $int_min + 1) } else
                        { a - b }
                    }
                } atomic_types!
                ($at_ident, $p_ident, $p_data_ident, $rust_ty, $value_ty) ;
                impl $at_ident
                {
                    atomic_common_methods!
                    ($at_ident, $p_ident, $p_data_ident, $rust_ty, $value_ty)
                    ; atomic_integer_methods!
                    ($at_ident, $p_ident, $rust_ty, $value_ty, $wrap_add,
                     $wrap_sub, $int_min, $int_max) ;
                }
            }
        }
        macro_rules! make_bool_atomic {
            ($at_ident : ident, $p_ident : ident, $p_data_ident : ident,
             $rust_ty : ty, $value_ty : ty) =>
            {
                atomic_types!
                ($at_ident, $p_ident, $p_data_ident, $rust_ty, $value_ty) ;
                impl $at_ident
                {
                    atomic_common_methods!
                    ($at_ident, $p_ident, $p_data_ident, $rust_ty, $value_ty)
                    ; atomic_bool_methods!
                    ($at_ident, $p_ident, $rust_ty, $value_ty) ;
                }
            }
        }
        macro_rules! atomic_types {
            ($at_ident : ident, $p_ident : ident, $p_data_ident : ident,
             $rust_ty : ty, $value_ty : ty) =>
            {
                #[verifier(external_body)] pub struct $at_ident
                { ato : $rust_ty, } #[proof] #[verifier(external_body)] pub
                struct $p_ident { no_copy : NoCopy, } #[spec] pub struct
                $p_data_ident
                { #[spec] pub patomic : int, #[spec] pub value : $value_ty, }
                impl $p_ident
                {
                    #[spec] #[verifier(external_body)] pub fn view(self) ->
                    $p_data_ident { unimplemented! () ; } #[spec]
                    #[verifier(publish)] pub fn
                    is_for(& self, patomic : $at_ident) -> bool
                    { self.view().patomic == patomic.id() } #[spec]
                    #[verifier(publish)] pub fn
                    points_to(& self, v : $value_ty) -> bool
                    { self.view().value == v }
                }
            }
        }
        macro_rules! atomic_common_methods {
            ($at_ident : ident, $p_ident : ident, $p_data_ident : ident,
             $rust_ty : ty, $value_ty : ty) =>
            {
                fndecl! (pub fn id(& self) -> int) ; #[inline(always)]
                #[verifier(external_body)] pub fn new(i : $value_ty) ->
                ($at_ident, Proof < $p_ident >)
                {
                    ensures(| res : ($at_ident, Proof < $p_ident >) |
                            equal(res.1.0.view(), $p_data_ident
                                  { patomic : res.0.id(), value : i })) ; let
                    p = $at_ident { ato : < $rust_ty > :: new(i) } ; let
                    Proof(t) = exec_proof_from_false() ; (p, Proof(t))
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                load(& self, #[proof] perm : & $p_ident) -> $value_ty
                {
                    requires([equal(self.id(), perm.view().patomic),]) ;
                    ensures(| ret : $value_ty | equal(perm.view().value, ret))
                    ; opens_invariants_none() ; return
                    self.ato.load(Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                store(& self, #[proof] perm : & mut $p_ident, v : $value_ty)
                {
                    requires([equal(self.id(), old(perm).view().patomic),]) ;
                    ensures(equal(perm.view().value, v) &&
                            equal(self.id(), perm.view().patomic)) ;
                    opens_invariants_none() ;
                    self.ato.store(v, Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                compare_exchange(& self, #[proof] perm : & mut $p_ident,
                                 current : $value_ty, new : $value_ty) ->
                Result < $value_ty, $value_ty >
                {
                    requires([equal(self.id(), old(perm).view().patomic),]) ;
                    ensures(| ret : Result < $value_ty, $value_ty > |
                            equal(self.id(), perm.view().patomic) && match ret
                            {
                                Result :: Ok(r) => current ==
                                old(perm).view().value &&
                                equal(perm.view().value, new) &&
                                equal(r, old(perm).view().value), Result ::
                                Err(r) => current != old(perm).view().value &&
                                equal(perm.view().value,
                                      old(perm).view().value) &&
                                equal(r, old(perm).view().value),
                            }) ; opens_invariants_none() ; match
                    self.ato.compare_exchange(current, new, Ordering ::
                                              SeqCst, Ordering :: SeqCst)
                    { Ok(x) => Result :: Ok(x), Err(x) => Result :: Err(x), }
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                compare_exchange_weak(& self, #[proof] perm : & mut $p_ident,
                                      current : $value_ty, new : $value_ty) ->
                Result < $value_ty, $value_ty >
                {
                    requires([equal(self.id(), old(perm).view().patomic),]) ;
                    ensures(| ret : Result < $value_ty, $value_ty > |
                            equal(self.id(), perm.view().patomic) && match ret
                            {
                                Result :: Ok(r) => current ==
                                old(perm).view().value &&
                                equal(perm.view().value, new) &&
                                equal(r, old(perm).view().value), Result ::
                                Err(r) =>
                                equal(perm.view().value,
                                      old(perm).view().value) &&
                                equal(r, old(perm).view().value),
                            }) ; opens_invariants_none() ; match
                    self.ato.compare_exchange_weak(current, new, Ordering ::
                                                   SeqCst, Ordering :: SeqCst)
                    { Ok(x) => Result :: Ok(x), Err(x) => Result :: Err(x), }
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                swap(& self, #[proof] perm : & mut $p_ident, v : $value_ty) ->
                $value_ty
                {
                    requires([equal(self.id(), old(perm).view().patomic),]) ;
                    ensures(| ret : $value_ty | equal(perm.view().value, v) &&
                            equal(old(perm).view().value, ret) &&
                            equal(self.id(), perm.view().patomic)) ;
                    opens_invariants_none() ; return
                    self.ato.swap(v, Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(external_body)] pub fn
                into_inner(self, #[proof] perm : $p_ident) -> $value_ty
                {
                    requires([equal(self.id(), perm.view().patomic),]) ;
                    ensures(| ret : $value_ty | equal(perm.view().value, ret))
                    ; opens_invariants_none() ; return self.ato.into_inner() ;
                }
            }
        }
        macro_rules! atomic_integer_methods {
            ($at_ident : ident, $p_ident : ident, $rust_ty : ty, $value_ty :
             ty, $wrap_add : ident, $wrap_sub : ident, $int_min : expr,
             $int_max : expr) =>
            {
                #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                fetch_add_wrapping(& self, #[proof] perm : & mut $p_ident, n :
                                   $value_ty) -> $value_ty
                {
                    requires(equal(self.id(), old(perm).view().patomic)) ;
                    ensures(| ret : $value_ty |
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer :: < $value_ty, int >
                             (perm.view().value) ==
                             $wrap_add(spec_cast_integer(old(perm).view().value),
                                       spec_cast_integer(n)),]) ;
                    opens_invariants_none() ; return
                    self.ato.fetch_add(n, Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                fetch_sub_wrapping(& self, #[proof] perm : & mut $p_ident, n :
                                   $value_ty) -> $value_ty
                {
                    requires(equal(self.id(), old(perm).view().patomic)) ;
                    ensures(| ret : $value_ty |
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer :: < $value_ty, int >
                             (perm.view().value) ==
                             $wrap_sub(spec_cast_integer :: < $value_ty, int >
                                       (old(perm).view().value),
                                       spec_cast_integer(n)),]) ;
                    opens_invariants_none() ; return
                    self.ato.fetch_sub(n, Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(atomic)] pub fn
                fetch_add(& self, #[proof] perm : & mut $p_ident, n :
                          $value_ty) -> $value_ty
                {
                    requires([equal(self.id(), old(perm).view().patomic),
                              $int_min <= old(perm).view().value.spec_add(n),
                              old(perm).view().value.spec_add(n) <= $int_max])
                    ;
                    ensures(| ret : $value_ty |
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value == old(perm).view().value +
                             n,]) ; opens_invariants_none() ;
                    self.fetch_add_wrapping(& mut * perm, n)
                } #[inline(always)] #[verifier(atomic)] pub fn
                fetch_sub(& self, #[proof] perm : & mut $p_ident, n :
                          $value_ty) -> $value_ty
                {
                    requires([equal(self.id(), old(perm).view().patomic),
                              $int_min <= old(perm).view().value.spec_sub(n),
                              old(perm).view().value.spec_sub(n) <=
                              $int_max,]) ;
                    ensures(| ret : $value_ty |
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value == old(perm).view().value -
                             n,]) ; opens_invariants_none() ;
                    self.fetch_sub_wrapping(& mut * perm, n)
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                fetch_and(& self, #[proof] perm : & mut $p_ident, n :
                          $value_ty) -> $value_ty
                {
                    requires(equal(self.id(), old(perm).view().patomic)) ;
                    ensures(| ret : $value_ty |
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                             (old(perm).view().value & n),]) ;
                    opens_invariants_none() ; return
                    self.ato.fetch_and(n, Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                fetch_or(& self, #[proof] perm : & mut $p_ident, n :
                         $value_ty) -> $value_ty
                {
                    requires(equal(self.id(), old(perm).view().patomic)) ;
                    ensures(| ret : $value_ty |
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                             (old(perm).view().value | n),]) ;
                    opens_invariants_none() ; return
                    self.ato.fetch_or(n, Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                fetch_xor(& self, #[proof] perm : & mut $p_ident, n :
                          $value_ty) -> $value_ty
                {
                    requires(equal(self.id(), old(perm).view().patomic)) ;
                    ensures(| ret : $value_ty |
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                             (old(perm).view().value ^ n),]) ;
                    opens_invariants_none() ; return
                    self.ato.fetch_or(n, Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                fetch_nand(& self, #[proof] perm : & mut $p_ident, n :
                           $value_ty) -> $value_ty
                {
                    requires(equal(self.id(), old(perm).view().patomic)) ;
                    ensures(| ret : $value_ty |
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==!
                             (old(perm).view().value & n),]) ;
                    opens_invariants_none() ; return
                    self.ato.fetch_nand(n, Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                fetch_max(& self, #[proof] perm : & mut $p_ident, n :
                          $value_ty) -> $value_ty
                {
                    requires(equal(self.id(), old(perm).view().patomic)) ;
                    ensures(| ret : $value_ty |
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                             (if old(perm).view().value > n
                              { old(perm).view().value } else { n }),]) ;
                    opens_invariants_none() ; return
                    self.ato.fetch_max(n, Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                fetch_min(& self, #[proof] perm : & mut $p_ident, n :
                          $value_ty) -> $value_ty
                {
                    requires(equal(self.id(), old(perm).view().patomic)) ;
                    ensures(| ret : $value_ty |
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                             (if old(perm).view().value < n
                              { old(perm).view().value } else { n }),]) ;
                    opens_invariants_none() ; return
                    self.ato.fetch_min(n, Ordering :: SeqCst) ;
                }
            }
        }
        macro_rules! atomic_bool_methods {
            ($at_ident : ident, $p_ident : ident, $rust_ty : ty, $value_ty :
             ty) =>
            {
                #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                fetch_and(& self, #[proof] perm : & mut $p_ident, n :
                          $value_ty) -> $value_ty
                {
                    requires([equal(self.id(), old(perm).view().patomic),]) ;
                    ensures(| ret : $value_ty |
                            equal(old(perm).view().value, ret) &&
                            perm.view().patomic == old(perm).view().patomic &&
                            perm.view().value ==
                            (old(perm).view().value && n)) ;
                    opens_invariants_none() ; return
                    self.ato.fetch_and(n, Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                fetch_or(& self, #[proof] perm : & mut $p_ident, n :
                         $value_ty) -> $value_ty
                {
                    requires([equal(self.id(), old(perm).view().patomic),]) ;
                    ensures(| ret : $value_ty |
                            equal(old(perm).view().value, ret) &&
                            perm.view().patomic == old(perm).view().patomic &&
                            perm.view().value ==
                            (old(perm).view().value || n)) ;
                    opens_invariants_none() ; return
                    self.ato.fetch_or(n, Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                fetch_xor(& self, #[proof] perm : & mut $p_ident, n :
                          $value_ty) -> $value_ty
                {
                    requires([equal(self.id(), old(perm).view().patomic),]) ;
                    ensures(| ret : $value_ty |
                            equal(old(perm).view().value, ret) &&
                            perm.view().patomic == old(perm).view().patomic &&
                            perm.view().value ==
                            ((old(perm).view().value &&! n) ||
                             (! old(perm).view().value && n))) ;
                    opens_invariants_none() ; return
                    self.ato.fetch_or(n, Ordering :: SeqCst) ;
                } #[inline(always)] #[verifier(external_body)]
                #[verifier(atomic)] pub fn
                fetch_nand(& self, #[proof] perm : & mut $p_ident, n :
                           $value_ty) -> $value_ty
                {
                    requires([equal(self.id(), old(perm).view().patomic),]) ;
                    ensures(| ret : $value_ty |
                            equal(old(perm).view().value, ret) &&
                            perm.view().patomic == old(perm).view().patomic &&
                            perm.view().value ==!
                            (old(perm).view().value && n)) ;
                    opens_invariants_none() ; return
                    self.ato.fetch_nand(n, Ordering :: SeqCst) ;
                }
            }
        }
        #[verifier(external_body)]
        pub struct PAtomicBool {
            ato: AtomicBool,
        }
        #[proof]
        #[verifier(external_body)]
        pub struct PermissionBool {
            no_copy: NoCopy,
        }
        #[spec]
        pub struct PermissionDataBool {
            #[spec]
            pub patomic: int,
            #[spec]
            pub value: bool,
        }
        impl PermissionBool {
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermissionDataBool {
                ::core::panicking::panic("not implemented");
            }
            #[spec]
            #[verifier(publish)]
            pub fn is_for(&self, patomic: PAtomicBool) -> bool {
                self.view().patomic == patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn points_to(&self, v: bool) -> bool {
                self.view().value == v
            }
        }
        impl PAtomicBool {
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn new(i: bool) -> (PAtomicBool, Proof<PermissionBool>) {
                ensures(|res: (PAtomicBool, Proof<PermissionBool>)|
                            equal(res.1.0.view(),
                                  PermissionDataBool{patomic: res.0.id(),
                                                     value: i,}));
                let p = PAtomicBool{ato: <AtomicBool>::new(i),};
                let Proof(t) = exec_proof_from_false();
                (p, Proof(t))
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn load(&self, #[proof] perm: &PermissionBool) -> bool {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: bool| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.load(Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn store(&self, #[proof] perm: &mut PermissionBool, v: bool) {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(equal(perm.view().value, v) &&
                            equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                self.ato.store(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange(&self, #[proof] perm: &mut PermissionBool,
                                    current: bool, new: bool)
             -> Result<bool, bool> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<bool, bool>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    current != old(perm).view().value &&
                                        equal(perm.view().value,
                                              old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange(current, new,
                                                Ordering::SeqCst,
                                                Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange_weak(&self,
                                         #[proof] perm: &mut PermissionBool,
                                         current: bool, new: bool)
             -> Result<bool, bool> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<bool, bool>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    equal(perm.view().value,
                                          old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange_weak(current, new,
                                                     Ordering::SeqCst,
                                                     Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn swap(&self, #[proof] perm: &mut PermissionBool, v: bool)
             -> bool {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: bool|
                            equal(perm.view().value, v) &&
                                equal(old(perm).view().value, ret) &&
                                equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                return self.ato.swap(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn into_inner(self, #[proof] perm: PermissionBool) -> bool {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: bool| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.into_inner();
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_and(&self, #[proof] perm: &mut PermissionBool,
                             n: bool) -> bool {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: bool|
                            equal(old(perm).view().value, ret) &&
                                perm.view().patomic ==
                                    old(perm).view().patomic &&
                                perm.view().value ==
                                    (old(perm).view().value && n));
                opens_invariants_none();
                return self.ato.fetch_and(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_or(&self, #[proof] perm: &mut PermissionBool,
                            n: bool) -> bool {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: bool|
                            equal(old(perm).view().value, ret) &&
                                perm.view().patomic ==
                                    old(perm).view().patomic &&
                                perm.view().value ==
                                    (old(perm).view().value || n));
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_xor(&self, #[proof] perm: &mut PermissionBool,
                             n: bool) -> bool {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: bool|
                            equal(old(perm).view().value, ret) &&
                                perm.view().patomic ==
                                    old(perm).view().patomic &&
                                perm.view().value ==
                                    ((old(perm).view().value && !n) ||
                                         (!old(perm).view().value && n)));
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_nand(&self, #[proof] perm: &mut PermissionBool,
                              n: bool) -> bool {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: bool|
                            equal(old(perm).view().value, ret) &&
                                perm.view().patomic ==
                                    old(perm).view().patomic &&
                                perm.view().value ==
                                    !(old(perm).view().value && n));
                opens_invariants_none();
                return self.ato.fetch_nand(n, Ordering::SeqCst);
            }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_add_u8(a: int, b: int) -> int {
            if ((a).spec_add(b)).spec_gt(spec_literal_int("255")) {
                ((a).spec_add(b)).spec_sub((((spec_literal_int("255")).spec_sub(spec_literal_int("0"))).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_add(b) }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_sub_u8(a: int, b: int) -> int {
            if ((a).spec_sub(b)).spec_lt(spec_literal_int("0")) {
                ((a).spec_sub(b)).spec_add((((spec_literal_int("255")).spec_sub(spec_literal_int("0"))).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_sub(b) }
        }
        #[verifier(external_body)]
        pub struct PAtomicU8 {
            ato: AtomicU8,
        }
        #[proof]
        #[verifier(external_body)]
        pub struct PermissionU8 {
            no_copy: NoCopy,
        }
        #[spec]
        pub struct PermissionDataU8 {
            #[spec]
            pub patomic: int,
            #[spec]
            pub value: u8,
        }
        impl PermissionU8 {
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermissionDataU8 {
                ::core::panicking::panic("not implemented");
            }
            #[spec]
            #[verifier(publish)]
            pub fn is_for(&self, patomic: PAtomicU8) -> bool {
                self.view().patomic == patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn points_to(&self, v: u8) -> bool { self.view().value == v }
        }
        impl PAtomicU8 {
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn new(i: u8) -> (PAtomicU8, Proof<PermissionU8>) {
                ensures(|res: (PAtomicU8, Proof<PermissionU8>)|
                            equal(res.1.0.view(),
                                  PermissionDataU8{patomic: res.0.id(),
                                                   value: i,}));
                let p = PAtomicU8{ato: <AtomicU8>::new(i),};
                let Proof(t) = exec_proof_from_false();
                (p, Proof(t))
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn load(&self, #[proof] perm: &PermissionU8) -> u8 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: u8| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.load(Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn store(&self, #[proof] perm: &mut PermissionU8, v: u8) {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(equal(perm.view().value, v) &&
                            equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                self.ato.store(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange(&self, #[proof] perm: &mut PermissionU8,
                                    current: u8, new: u8) -> Result<u8, u8> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<u8, u8>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    current != old(perm).view().value &&
                                        equal(perm.view().value,
                                              old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange(current, new,
                                                Ordering::SeqCst,
                                                Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange_weak(&self,
                                         #[proof] perm: &mut PermissionU8,
                                         current: u8, new: u8)
             -> Result<u8, u8> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<u8, u8>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    equal(perm.view().value,
                                          old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange_weak(current, new,
                                                     Ordering::SeqCst,
                                                     Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn swap(&self, #[proof] perm: &mut PermissionU8, v: u8)
             -> u8 {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: u8|
                            equal(perm.view().value, v) &&
                                equal(old(perm).view().value, ret) &&
                                equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                return self.ato.swap(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn into_inner(self, #[proof] perm: PermissionU8) -> u8 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: u8| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.into_inner();
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_add_wrapping(&self, #[proof] perm: &mut PermissionU8,
                                      n: u8) -> u8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<u8, int>(perm.view().value)
                                 ==
                                 wrapping_add_u8(spec_cast_integer(old(perm).view().value),
                                                 spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_add(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_sub_wrapping(&self, #[proof] perm: &mut PermissionU8,
                                      n: u8) -> u8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<u8, int>(perm.view().value)
                                 ==
                                 wrapping_sub_u8(spec_cast_integer::<u8,
                                                                     int>(old(perm).view().value),
                                                 spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_sub(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_add(&self, #[proof] perm: &mut PermissionU8, n: u8)
             -> u8 {
                requires([equal(self.id(), old(perm).view().patomic),
                          spec_literal_int("0") <=
                              old(perm).view().value.spec_add(n),
                          old(perm).view().value.spec_add(n) <=
                              spec_literal_int("255")]);
                ensures(|ret: u8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value + n]);
                opens_invariants_none();
                self.fetch_add_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_sub(&self, #[proof] perm: &mut PermissionU8, n: u8)
             -> u8 {
                requires([equal(self.id(), old(perm).view().patomic),
                          spec_literal_int("0") <=
                              old(perm).view().value.spec_sub(n),
                          old(perm).view().value.spec_sub(n) <=
                              spec_literal_int("255")]);
                ensures(|ret: u8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value - n]);
                opens_invariants_none();
                self.fetch_sub_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_and(&self, #[proof] perm: &mut PermissionU8, n: u8)
             -> u8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_and(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_or(&self, #[proof] perm: &mut PermissionU8, n: u8)
             -> u8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value | n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_xor(&self, #[proof] perm: &mut PermissionU8, n: u8)
             -> u8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value ^ n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_nand(&self, #[proof] perm: &mut PermissionU8, n: u8)
             -> u8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 !(old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_nand(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_max(&self, #[proof] perm: &mut PermissionU8, n: u8)
             -> u8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value > n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_max(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_min(&self, #[proof] perm: &mut PermissionU8, n: u8)
             -> u8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value < n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_min(n, Ordering::SeqCst);
            }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_add_u16(a: int, b: int) -> int {
            if ((a).spec_add(b)).spec_gt(spec_literal_int("65535")) {
                ((a).spec_add(b)).spec_sub((((spec_literal_int("65535")).spec_sub(spec_literal_int("0"))).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_add(b) }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_sub_u16(a: int, b: int) -> int {
            if ((a).spec_sub(b)).spec_lt(spec_literal_int("0")) {
                ((a).spec_sub(b)).spec_add((((spec_literal_int("65535")).spec_sub(spec_literal_int("0"))).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_sub(b) }
        }
        #[verifier(external_body)]
        pub struct PAtomicU16 {
            ato: AtomicU16,
        }
        #[proof]
        #[verifier(external_body)]
        pub struct PermissionU16 {
            no_copy: NoCopy,
        }
        #[spec]
        pub struct PermissionDataU16 {
            #[spec]
            pub patomic: int,
            #[spec]
            pub value: u16,
        }
        impl PermissionU16 {
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermissionDataU16 {
                ::core::panicking::panic("not implemented");
            }
            #[spec]
            #[verifier(publish)]
            pub fn is_for(&self, patomic: PAtomicU16) -> bool {
                self.view().patomic == patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn points_to(&self, v: u16) -> bool { self.view().value == v }
        }
        impl PAtomicU16 {
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn new(i: u16) -> (PAtomicU16, Proof<PermissionU16>) {
                ensures(|res: (PAtomicU16, Proof<PermissionU16>)|
                            equal(res.1.0.view(),
                                  PermissionDataU16{patomic: res.0.id(),
                                                    value: i,}));
                let p = PAtomicU16{ato: <AtomicU16>::new(i),};
                let Proof(t) = exec_proof_from_false();
                (p, Proof(t))
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn load(&self, #[proof] perm: &PermissionU16) -> u16 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: u16| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.load(Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn store(&self, #[proof] perm: &mut PermissionU16, v: u16) {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(equal(perm.view().value, v) &&
                            equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                self.ato.store(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange(&self, #[proof] perm: &mut PermissionU16,
                                    current: u16, new: u16)
             -> Result<u16, u16> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<u16, u16>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    current != old(perm).view().value &&
                                        equal(perm.view().value,
                                              old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange(current, new,
                                                Ordering::SeqCst,
                                                Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange_weak(&self,
                                         #[proof] perm: &mut PermissionU16,
                                         current: u16, new: u16)
             -> Result<u16, u16> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<u16, u16>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    equal(perm.view().value,
                                          old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange_weak(current, new,
                                                     Ordering::SeqCst,
                                                     Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn swap(&self, #[proof] perm: &mut PermissionU16, v: u16)
             -> u16 {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: u16|
                            equal(perm.view().value, v) &&
                                equal(old(perm).view().value, ret) &&
                                equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                return self.ato.swap(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn into_inner(self, #[proof] perm: PermissionU16) -> u16 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: u16| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.into_inner();
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_add_wrapping(&self,
                                      #[proof] perm: &mut PermissionU16,
                                      n: u16) -> u16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<u16, int>(perm.view().value)
                                 ==
                                 wrapping_add_u16(spec_cast_integer(old(perm).view().value),
                                                  spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_add(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_sub_wrapping(&self,
                                      #[proof] perm: &mut PermissionU16,
                                      n: u16) -> u16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<u16, int>(perm.view().value)
                                 ==
                                 wrapping_sub_u16(spec_cast_integer::<u16,
                                                                      int>(old(perm).view().value),
                                                  spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_sub(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_add(&self, #[proof] perm: &mut PermissionU16, n: u16)
             -> u16 {
                requires([equal(self.id(), old(perm).view().patomic),
                          spec_literal_int("0") <=
                              old(perm).view().value.spec_add(n),
                          old(perm).view().value.spec_add(n) <=
                              spec_literal_int("65535")]);
                ensures(|ret: u16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value + n]);
                opens_invariants_none();
                self.fetch_add_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_sub(&self, #[proof] perm: &mut PermissionU16, n: u16)
             -> u16 {
                requires([equal(self.id(), old(perm).view().patomic),
                          spec_literal_int("0") <=
                              old(perm).view().value.spec_sub(n),
                          old(perm).view().value.spec_sub(n) <=
                              spec_literal_int("65535")]);
                ensures(|ret: u16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value - n]);
                opens_invariants_none();
                self.fetch_sub_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_and(&self, #[proof] perm: &mut PermissionU16, n: u16)
             -> u16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_and(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_or(&self, #[proof] perm: &mut PermissionU16, n: u16)
             -> u16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value | n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_xor(&self, #[proof] perm: &mut PermissionU16, n: u16)
             -> u16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value ^ n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_nand(&self, #[proof] perm: &mut PermissionU16,
                              n: u16) -> u16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 !(old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_nand(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_max(&self, #[proof] perm: &mut PermissionU16, n: u16)
             -> u16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value > n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_max(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_min(&self, #[proof] perm: &mut PermissionU16, n: u16)
             -> u16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value < n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_min(n, Ordering::SeqCst);
            }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_add_u32(a: int, b: int) -> int {
            if ((a).spec_add(b)).spec_gt(spec_literal_int("4294967295")) {
                ((a).spec_add(b)).spec_sub((((spec_literal_int("4294967295")).spec_sub(spec_literal_int("0"))).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_add(b) }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_sub_u32(a: int, b: int) -> int {
            if ((a).spec_sub(b)).spec_lt(spec_literal_int("0")) {
                ((a).spec_sub(b)).spec_add((((spec_literal_int("4294967295")).spec_sub(spec_literal_int("0"))).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_sub(b) }
        }
        #[verifier(external_body)]
        pub struct PAtomicU32 {
            ato: AtomicU32,
        }
        #[proof]
        #[verifier(external_body)]
        pub struct PermissionU32 {
            no_copy: NoCopy,
        }
        #[spec]
        pub struct PermissionDataU32 {
            #[spec]
            pub patomic: int,
            #[spec]
            pub value: u32,
        }
        impl PermissionU32 {
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermissionDataU32 {
                ::core::panicking::panic("not implemented");
            }
            #[spec]
            #[verifier(publish)]
            pub fn is_for(&self, patomic: PAtomicU32) -> bool {
                self.view().patomic == patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn points_to(&self, v: u32) -> bool { self.view().value == v }
        }
        impl PAtomicU32 {
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn new(i: u32) -> (PAtomicU32, Proof<PermissionU32>) {
                ensures(|res: (PAtomicU32, Proof<PermissionU32>)|
                            equal(res.1.0.view(),
                                  PermissionDataU32{patomic: res.0.id(),
                                                    value: i,}));
                let p = PAtomicU32{ato: <AtomicU32>::new(i),};
                let Proof(t) = exec_proof_from_false();
                (p, Proof(t))
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn load(&self, #[proof] perm: &PermissionU32) -> u32 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: u32| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.load(Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn store(&self, #[proof] perm: &mut PermissionU32, v: u32) {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(equal(perm.view().value, v) &&
                            equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                self.ato.store(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange(&self, #[proof] perm: &mut PermissionU32,
                                    current: u32, new: u32)
             -> Result<u32, u32> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<u32, u32>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    current != old(perm).view().value &&
                                        equal(perm.view().value,
                                              old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange(current, new,
                                                Ordering::SeqCst,
                                                Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange_weak(&self,
                                         #[proof] perm: &mut PermissionU32,
                                         current: u32, new: u32)
             -> Result<u32, u32> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<u32, u32>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    equal(perm.view().value,
                                          old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange_weak(current, new,
                                                     Ordering::SeqCst,
                                                     Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn swap(&self, #[proof] perm: &mut PermissionU32, v: u32)
             -> u32 {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: u32|
                            equal(perm.view().value, v) &&
                                equal(old(perm).view().value, ret) &&
                                equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                return self.ato.swap(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn into_inner(self, #[proof] perm: PermissionU32) -> u32 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: u32| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.into_inner();
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_add_wrapping(&self,
                                      #[proof] perm: &mut PermissionU32,
                                      n: u32) -> u32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<u32, int>(perm.view().value)
                                 ==
                                 wrapping_add_u32(spec_cast_integer(old(perm).view().value),
                                                  spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_add(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_sub_wrapping(&self,
                                      #[proof] perm: &mut PermissionU32,
                                      n: u32) -> u32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<u32, int>(perm.view().value)
                                 ==
                                 wrapping_sub_u32(spec_cast_integer::<u32,
                                                                      int>(old(perm).view().value),
                                                  spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_sub(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_add(&self, #[proof] perm: &mut PermissionU32, n: u32)
             -> u32 {
                requires([equal(self.id(), old(perm).view().patomic),
                          spec_literal_int("0") <=
                              old(perm).view().value.spec_add(n),
                          old(perm).view().value.spec_add(n) <=
                              spec_literal_int("4294967295")]);
                ensures(|ret: u32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value + n]);
                opens_invariants_none();
                self.fetch_add_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_sub(&self, #[proof] perm: &mut PermissionU32, n: u32)
             -> u32 {
                requires([equal(self.id(), old(perm).view().patomic),
                          spec_literal_int("0") <=
                              old(perm).view().value.spec_sub(n),
                          old(perm).view().value.spec_sub(n) <=
                              spec_literal_int("4294967295")]);
                ensures(|ret: u32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value - n]);
                opens_invariants_none();
                self.fetch_sub_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_and(&self, #[proof] perm: &mut PermissionU32, n: u32)
             -> u32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_and(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_or(&self, #[proof] perm: &mut PermissionU32, n: u32)
             -> u32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value | n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_xor(&self, #[proof] perm: &mut PermissionU32, n: u32)
             -> u32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value ^ n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_nand(&self, #[proof] perm: &mut PermissionU32,
                              n: u32) -> u32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 !(old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_nand(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_max(&self, #[proof] perm: &mut PermissionU32, n: u32)
             -> u32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value > n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_max(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_min(&self, #[proof] perm: &mut PermissionU32, n: u32)
             -> u32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value < n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_min(n, Ordering::SeqCst);
            }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_add_u64(a: int, b: int) -> int {
            if ((a).spec_add(b)).spec_gt(spec_literal_int("18446744073709551615"))
               {
                ((a).spec_add(b)).spec_sub((((spec_literal_int("18446744073709551615")).spec_sub(spec_literal_int("0"))).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_add(b) }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_sub_u64(a: int, b: int) -> int {
            if ((a).spec_sub(b)).spec_lt(spec_literal_int("0")) {
                ((a).spec_sub(b)).spec_add((((spec_literal_int("18446744073709551615")).spec_sub(spec_literal_int("0"))).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_sub(b) }
        }
        #[verifier(external_body)]
        pub struct PAtomicU64 {
            ato: AtomicU64,
        }
        #[proof]
        #[verifier(external_body)]
        pub struct PermissionU64 {
            no_copy: NoCopy,
        }
        #[spec]
        pub struct PermissionDataU64 {
            #[spec]
            pub patomic: int,
            #[spec]
            pub value: u64,
        }
        impl PermissionU64 {
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermissionDataU64 {
                ::core::panicking::panic("not implemented");
            }
            #[spec]
            #[verifier(publish)]
            pub fn is_for(&self, patomic: PAtomicU64) -> bool {
                self.view().patomic == patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn points_to(&self, v: u64) -> bool { self.view().value == v }
        }
        impl PAtomicU64 {
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn new(i: u64) -> (PAtomicU64, Proof<PermissionU64>) {
                ensures(|res: (PAtomicU64, Proof<PermissionU64>)|
                            equal(res.1.0.view(),
                                  PermissionDataU64{patomic: res.0.id(),
                                                    value: i,}));
                let p = PAtomicU64{ato: <AtomicU64>::new(i),};
                let Proof(t) = exec_proof_from_false();
                (p, Proof(t))
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn load(&self, #[proof] perm: &PermissionU64) -> u64 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: u64| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.load(Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn store(&self, #[proof] perm: &mut PermissionU64, v: u64) {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(equal(perm.view().value, v) &&
                            equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                self.ato.store(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange(&self, #[proof] perm: &mut PermissionU64,
                                    current: u64, new: u64)
             -> Result<u64, u64> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<u64, u64>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    current != old(perm).view().value &&
                                        equal(perm.view().value,
                                              old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange(current, new,
                                                Ordering::SeqCst,
                                                Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange_weak(&self,
                                         #[proof] perm: &mut PermissionU64,
                                         current: u64, new: u64)
             -> Result<u64, u64> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<u64, u64>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    equal(perm.view().value,
                                          old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange_weak(current, new,
                                                     Ordering::SeqCst,
                                                     Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn swap(&self, #[proof] perm: &mut PermissionU64, v: u64)
             -> u64 {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: u64|
                            equal(perm.view().value, v) &&
                                equal(old(perm).view().value, ret) &&
                                equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                return self.ato.swap(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn into_inner(self, #[proof] perm: PermissionU64) -> u64 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: u64| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.into_inner();
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_add_wrapping(&self,
                                      #[proof] perm: &mut PermissionU64,
                                      n: u64) -> u64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<u64, int>(perm.view().value)
                                 ==
                                 wrapping_add_u64(spec_cast_integer(old(perm).view().value),
                                                  spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_add(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_sub_wrapping(&self,
                                      #[proof] perm: &mut PermissionU64,
                                      n: u64) -> u64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<u64, int>(perm.view().value)
                                 ==
                                 wrapping_sub_u64(spec_cast_integer::<u64,
                                                                      int>(old(perm).view().value),
                                                  spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_sub(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_add(&self, #[proof] perm: &mut PermissionU64, n: u64)
             -> u64 {
                requires([equal(self.id(), old(perm).view().patomic),
                          spec_literal_int("0") <=
                              old(perm).view().value.spec_add(n),
                          old(perm).view().value.spec_add(n) <=
                              spec_literal_int("18446744073709551615")]);
                ensures(|ret: u64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value + n]);
                opens_invariants_none();
                self.fetch_add_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_sub(&self, #[proof] perm: &mut PermissionU64, n: u64)
             -> u64 {
                requires([equal(self.id(), old(perm).view().patomic),
                          spec_literal_int("0") <=
                              old(perm).view().value.spec_sub(n),
                          old(perm).view().value.spec_sub(n) <=
                              spec_literal_int("18446744073709551615")]);
                ensures(|ret: u64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value - n]);
                opens_invariants_none();
                self.fetch_sub_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_and(&self, #[proof] perm: &mut PermissionU64, n: u64)
             -> u64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_and(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_or(&self, #[proof] perm: &mut PermissionU64, n: u64)
             -> u64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value | n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_xor(&self, #[proof] perm: &mut PermissionU64, n: u64)
             -> u64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value ^ n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_nand(&self, #[proof] perm: &mut PermissionU64,
                              n: u64) -> u64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 !(old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_nand(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_max(&self, #[proof] perm: &mut PermissionU64, n: u64)
             -> u64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value > n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_max(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_min(&self, #[proof] perm: &mut PermissionU64, n: u64)
             -> u64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: u64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value < n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_min(n, Ordering::SeqCst);
            }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_add_i8(a: int, b: int) -> int {
            if ((a).spec_add(b)).spec_gt(spec_literal_int("127")) {
                ((a).spec_add(b)).spec_sub((((spec_literal_int("127")).spec_sub((spec_literal_int("128")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else if ((a).spec_add(b)).spec_lt((spec_literal_int("128")).spec_neg())
             {
                ((a).spec_add(b)).spec_add((((spec_literal_int("127")).spec_sub((spec_literal_int("128")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_add(b) }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_sub_i8(a: int, b: int) -> int {
            if ((a).spec_sub(b)).spec_gt(spec_literal_int("127")) {
                ((a).spec_sub(b)).spec_sub((((spec_literal_int("127")).spec_sub((spec_literal_int("128")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else if ((a).spec_sub(b)).spec_lt((spec_literal_int("128")).spec_neg())
             {
                ((a).spec_sub(b)).spec_add((((spec_literal_int("127")).spec_sub((spec_literal_int("128")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_sub(b) }
        }
        #[verifier(external_body)]
        pub struct PAtomicI8 {
            ato: AtomicI8,
        }
        #[proof]
        #[verifier(external_body)]
        pub struct PermissionI8 {
            no_copy: NoCopy,
        }
        #[spec]
        pub struct PermissionDataI8 {
            #[spec]
            pub patomic: int,
            #[spec]
            pub value: i8,
        }
        impl PermissionI8 {
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermissionDataI8 {
                ::core::panicking::panic("not implemented");
            }
            #[spec]
            #[verifier(publish)]
            pub fn is_for(&self, patomic: PAtomicI8) -> bool {
                self.view().patomic == patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn points_to(&self, v: i8) -> bool { self.view().value == v }
        }
        impl PAtomicI8 {
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn new(i: i8) -> (PAtomicI8, Proof<PermissionI8>) {
                ensures(|res: (PAtomicI8, Proof<PermissionI8>)|
                            equal(res.1.0.view(),
                                  PermissionDataI8{patomic: res.0.id(),
                                                   value: i,}));
                let p = PAtomicI8{ato: <AtomicI8>::new(i),};
                let Proof(t) = exec_proof_from_false();
                (p, Proof(t))
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn load(&self, #[proof] perm: &PermissionI8) -> i8 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: i8| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.load(Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn store(&self, #[proof] perm: &mut PermissionI8, v: i8) {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(equal(perm.view().value, v) &&
                            equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                self.ato.store(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange(&self, #[proof] perm: &mut PermissionI8,
                                    current: i8, new: i8) -> Result<i8, i8> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<i8, i8>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    current != old(perm).view().value &&
                                        equal(perm.view().value,
                                              old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange(current, new,
                                                Ordering::SeqCst,
                                                Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange_weak(&self,
                                         #[proof] perm: &mut PermissionI8,
                                         current: i8, new: i8)
             -> Result<i8, i8> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<i8, i8>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    equal(perm.view().value,
                                          old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange_weak(current, new,
                                                     Ordering::SeqCst,
                                                     Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn swap(&self, #[proof] perm: &mut PermissionI8, v: i8)
             -> i8 {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: i8|
                            equal(perm.view().value, v) &&
                                equal(old(perm).view().value, ret) &&
                                equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                return self.ato.swap(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn into_inner(self, #[proof] perm: PermissionI8) -> i8 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: i8| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.into_inner();
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_add_wrapping(&self, #[proof] perm: &mut PermissionI8,
                                      n: i8) -> i8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<i8, int>(perm.view().value)
                                 ==
                                 wrapping_add_i8(spec_cast_integer(old(perm).view().value),
                                                 spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_add(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_sub_wrapping(&self, #[proof] perm: &mut PermissionI8,
                                      n: i8) -> i8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<i8, int>(perm.view().value)
                                 ==
                                 wrapping_sub_i8(spec_cast_integer::<i8,
                                                                     int>(old(perm).view().value),
                                                 spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_sub(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_add(&self, #[proof] perm: &mut PermissionI8, n: i8)
             -> i8 {
                requires([equal(self.id(), old(perm).view().patomic),
                          -spec_literal_int("128") <=
                              old(perm).view().value.spec_add(n),
                          old(perm).view().value.spec_add(n) <=
                              spec_literal_int("127")]);
                ensures(|ret: i8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value + n]);
                opens_invariants_none();
                self.fetch_add_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_sub(&self, #[proof] perm: &mut PermissionI8, n: i8)
             -> i8 {
                requires([equal(self.id(), old(perm).view().patomic),
                          -spec_literal_int("128") <=
                              old(perm).view().value.spec_sub(n),
                          old(perm).view().value.spec_sub(n) <=
                              spec_literal_int("127")]);
                ensures(|ret: i8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value - n]);
                opens_invariants_none();
                self.fetch_sub_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_and(&self, #[proof] perm: &mut PermissionI8, n: i8)
             -> i8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_and(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_or(&self, #[proof] perm: &mut PermissionI8, n: i8)
             -> i8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value | n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_xor(&self, #[proof] perm: &mut PermissionI8, n: i8)
             -> i8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value ^ n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_nand(&self, #[proof] perm: &mut PermissionI8, n: i8)
             -> i8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 !(old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_nand(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_max(&self, #[proof] perm: &mut PermissionI8, n: i8)
             -> i8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value > n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_max(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_min(&self, #[proof] perm: &mut PermissionI8, n: i8)
             -> i8 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i8|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value < n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_min(n, Ordering::SeqCst);
            }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_add_i16(a: int, b: int) -> int {
            if ((a).spec_add(b)).spec_gt(spec_literal_int("32767")) {
                ((a).spec_add(b)).spec_sub((((spec_literal_int("32767")).spec_sub((spec_literal_int("32768")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else if ((a).spec_add(b)).spec_lt((spec_literal_int("32768")).spec_neg())
             {
                ((a).spec_add(b)).spec_add((((spec_literal_int("32767")).spec_sub((spec_literal_int("32768")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_add(b) }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_sub_i16(a: int, b: int) -> int {
            if ((a).spec_sub(b)).spec_gt(spec_literal_int("32767")) {
                ((a).spec_sub(b)).spec_sub((((spec_literal_int("32767")).spec_sub((spec_literal_int("32768")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else if ((a).spec_sub(b)).spec_lt((spec_literal_int("32768")).spec_neg())
             {
                ((a).spec_sub(b)).spec_add((((spec_literal_int("32767")).spec_sub((spec_literal_int("32768")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_sub(b) }
        }
        #[verifier(external_body)]
        pub struct PAtomicI16 {
            ato: AtomicI16,
        }
        #[proof]
        #[verifier(external_body)]
        pub struct PermissionI16 {
            no_copy: NoCopy,
        }
        #[spec]
        pub struct PermissionDataI16 {
            #[spec]
            pub patomic: int,
            #[spec]
            pub value: i16,
        }
        impl PermissionI16 {
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermissionDataI16 {
                ::core::panicking::panic("not implemented");
            }
            #[spec]
            #[verifier(publish)]
            pub fn is_for(&self, patomic: PAtomicI16) -> bool {
                self.view().patomic == patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn points_to(&self, v: i16) -> bool { self.view().value == v }
        }
        impl PAtomicI16 {
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn new(i: i16) -> (PAtomicI16, Proof<PermissionI16>) {
                ensures(|res: (PAtomicI16, Proof<PermissionI16>)|
                            equal(res.1.0.view(),
                                  PermissionDataI16{patomic: res.0.id(),
                                                    value: i,}));
                let p = PAtomicI16{ato: <AtomicI16>::new(i),};
                let Proof(t) = exec_proof_from_false();
                (p, Proof(t))
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn load(&self, #[proof] perm: &PermissionI16) -> i16 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: i16| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.load(Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn store(&self, #[proof] perm: &mut PermissionI16, v: i16) {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(equal(perm.view().value, v) &&
                            equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                self.ato.store(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange(&self, #[proof] perm: &mut PermissionI16,
                                    current: i16, new: i16)
             -> Result<i16, i16> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<i16, i16>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    current != old(perm).view().value &&
                                        equal(perm.view().value,
                                              old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange(current, new,
                                                Ordering::SeqCst,
                                                Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange_weak(&self,
                                         #[proof] perm: &mut PermissionI16,
                                         current: i16, new: i16)
             -> Result<i16, i16> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<i16, i16>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    equal(perm.view().value,
                                          old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange_weak(current, new,
                                                     Ordering::SeqCst,
                                                     Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn swap(&self, #[proof] perm: &mut PermissionI16, v: i16)
             -> i16 {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: i16|
                            equal(perm.view().value, v) &&
                                equal(old(perm).view().value, ret) &&
                                equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                return self.ato.swap(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn into_inner(self, #[proof] perm: PermissionI16) -> i16 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: i16| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.into_inner();
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_add_wrapping(&self,
                                      #[proof] perm: &mut PermissionI16,
                                      n: i16) -> i16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<i16, int>(perm.view().value)
                                 ==
                                 wrapping_add_i16(spec_cast_integer(old(perm).view().value),
                                                  spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_add(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_sub_wrapping(&self,
                                      #[proof] perm: &mut PermissionI16,
                                      n: i16) -> i16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<i16, int>(perm.view().value)
                                 ==
                                 wrapping_sub_i16(spec_cast_integer::<i16,
                                                                      int>(old(perm).view().value),
                                                  spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_sub(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_add(&self, #[proof] perm: &mut PermissionI16, n: i16)
             -> i16 {
                requires([equal(self.id(), old(perm).view().patomic),
                          -spec_literal_int("32768") <=
                              old(perm).view().value.spec_add(n),
                          old(perm).view().value.spec_add(n) <=
                              spec_literal_int("32767")]);
                ensures(|ret: i16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value + n]);
                opens_invariants_none();
                self.fetch_add_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_sub(&self, #[proof] perm: &mut PermissionI16, n: i16)
             -> i16 {
                requires([equal(self.id(), old(perm).view().patomic),
                          -spec_literal_int("32768") <=
                              old(perm).view().value.spec_sub(n),
                          old(perm).view().value.spec_sub(n) <=
                              spec_literal_int("32767")]);
                ensures(|ret: i16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value - n]);
                opens_invariants_none();
                self.fetch_sub_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_and(&self, #[proof] perm: &mut PermissionI16, n: i16)
             -> i16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_and(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_or(&self, #[proof] perm: &mut PermissionI16, n: i16)
             -> i16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value | n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_xor(&self, #[proof] perm: &mut PermissionI16, n: i16)
             -> i16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value ^ n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_nand(&self, #[proof] perm: &mut PermissionI16,
                              n: i16) -> i16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 !(old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_nand(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_max(&self, #[proof] perm: &mut PermissionI16, n: i16)
             -> i16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value > n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_max(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_min(&self, #[proof] perm: &mut PermissionI16, n: i16)
             -> i16 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i16|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value < n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_min(n, Ordering::SeqCst);
            }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_add_i32(a: int, b: int) -> int {
            if ((a).spec_add(b)).spec_gt(spec_literal_int("2147483647")) {
                ((a).spec_add(b)).spec_sub((((spec_literal_int("2147483647")).spec_sub((spec_literal_int("2147483648")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else if ((a).spec_add(b)).spec_lt((spec_literal_int("2147483648")).spec_neg())
             {
                ((a).spec_add(b)).spec_add((((spec_literal_int("2147483647")).spec_sub((spec_literal_int("2147483648")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_add(b) }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_sub_i32(a: int, b: int) -> int {
            if ((a).spec_sub(b)).spec_gt(spec_literal_int("2147483647")) {
                ((a).spec_sub(b)).spec_sub((((spec_literal_int("2147483647")).spec_sub((spec_literal_int("2147483648")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else if ((a).spec_sub(b)).spec_lt((spec_literal_int("2147483648")).spec_neg())
             {
                ((a).spec_sub(b)).spec_add((((spec_literal_int("2147483647")).spec_sub((spec_literal_int("2147483648")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_sub(b) }
        }
        #[verifier(external_body)]
        pub struct PAtomicI32 {
            ato: AtomicI32,
        }
        #[proof]
        #[verifier(external_body)]
        pub struct PermissionI32 {
            no_copy: NoCopy,
        }
        #[spec]
        pub struct PermissionDataI32 {
            #[spec]
            pub patomic: int,
            #[spec]
            pub value: i32,
        }
        impl PermissionI32 {
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermissionDataI32 {
                ::core::panicking::panic("not implemented");
            }
            #[spec]
            #[verifier(publish)]
            pub fn is_for(&self, patomic: PAtomicI32) -> bool {
                self.view().patomic == patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn points_to(&self, v: i32) -> bool { self.view().value == v }
        }
        impl PAtomicI32 {
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn new(i: i32) -> (PAtomicI32, Proof<PermissionI32>) {
                ensures(|res: (PAtomicI32, Proof<PermissionI32>)|
                            equal(res.1.0.view(),
                                  PermissionDataI32{patomic: res.0.id(),
                                                    value: i,}));
                let p = PAtomicI32{ato: <AtomicI32>::new(i),};
                let Proof(t) = exec_proof_from_false();
                (p, Proof(t))
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn load(&self, #[proof] perm: &PermissionI32) -> i32 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: i32| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.load(Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn store(&self, #[proof] perm: &mut PermissionI32, v: i32) {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(equal(perm.view().value, v) &&
                            equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                self.ato.store(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange(&self, #[proof] perm: &mut PermissionI32,
                                    current: i32, new: i32)
             -> Result<i32, i32> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<i32, i32>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    current != old(perm).view().value &&
                                        equal(perm.view().value,
                                              old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange(current, new,
                                                Ordering::SeqCst,
                                                Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange_weak(&self,
                                         #[proof] perm: &mut PermissionI32,
                                         current: i32, new: i32)
             -> Result<i32, i32> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<i32, i32>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    equal(perm.view().value,
                                          old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange_weak(current, new,
                                                     Ordering::SeqCst,
                                                     Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn swap(&self, #[proof] perm: &mut PermissionI32, v: i32)
             -> i32 {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: i32|
                            equal(perm.view().value, v) &&
                                equal(old(perm).view().value, ret) &&
                                equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                return self.ato.swap(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn into_inner(self, #[proof] perm: PermissionI32) -> i32 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: i32| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.into_inner();
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_add_wrapping(&self,
                                      #[proof] perm: &mut PermissionI32,
                                      n: i32) -> i32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<i32, int>(perm.view().value)
                                 ==
                                 wrapping_add_i32(spec_cast_integer(old(perm).view().value),
                                                  spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_add(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_sub_wrapping(&self,
                                      #[proof] perm: &mut PermissionI32,
                                      n: i32) -> i32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<i32, int>(perm.view().value)
                                 ==
                                 wrapping_sub_i32(spec_cast_integer::<i32,
                                                                      int>(old(perm).view().value),
                                                  spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_sub(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_add(&self, #[proof] perm: &mut PermissionI32, n: i32)
             -> i32 {
                requires([equal(self.id(), old(perm).view().patomic),
                          -spec_literal_int("2147483648") <=
                              old(perm).view().value.spec_add(n),
                          old(perm).view().value.spec_add(n) <=
                              spec_literal_int("2147483647")]);
                ensures(|ret: i32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value + n]);
                opens_invariants_none();
                self.fetch_add_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_sub(&self, #[proof] perm: &mut PermissionI32, n: i32)
             -> i32 {
                requires([equal(self.id(), old(perm).view().patomic),
                          -spec_literal_int("2147483648") <=
                              old(perm).view().value.spec_sub(n),
                          old(perm).view().value.spec_sub(n) <=
                              spec_literal_int("2147483647")]);
                ensures(|ret: i32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value - n]);
                opens_invariants_none();
                self.fetch_sub_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_and(&self, #[proof] perm: &mut PermissionI32, n: i32)
             -> i32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_and(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_or(&self, #[proof] perm: &mut PermissionI32, n: i32)
             -> i32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value | n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_xor(&self, #[proof] perm: &mut PermissionI32, n: i32)
             -> i32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value ^ n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_nand(&self, #[proof] perm: &mut PermissionI32,
                              n: i32) -> i32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 !(old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_nand(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_max(&self, #[proof] perm: &mut PermissionI32, n: i32)
             -> i32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value > n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_max(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_min(&self, #[proof] perm: &mut PermissionI32, n: i32)
             -> i32 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i32|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value < n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_min(n, Ordering::SeqCst);
            }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_add_i64(a: int, b: int) -> int {
            if ((a).spec_add(b)).spec_gt(spec_literal_int("9223372036854775807"))
               {
                ((a).spec_add(b)).spec_sub((((spec_literal_int("9223372036854775807")).spec_sub((spec_literal_int("9223372036854775808")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else if ((a).spec_add(b)).spec_lt((spec_literal_int("9223372036854775808")).spec_neg())
             {
                ((a).spec_add(b)).spec_add((((spec_literal_int("9223372036854775807")).spec_sub((spec_literal_int("9223372036854775808")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_add(b) }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn wrapping_sub_i64(a: int, b: int) -> int {
            if ((a).spec_sub(b)).spec_gt(spec_literal_int("9223372036854775807"))
               {
                ((a).spec_sub(b)).spec_sub((((spec_literal_int("9223372036854775807")).spec_sub((spec_literal_int("9223372036854775808")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else if ((a).spec_sub(b)).spec_lt((spec_literal_int("9223372036854775808")).spec_neg())
             {
                ((a).spec_sub(b)).spec_add((((spec_literal_int("9223372036854775807")).spec_sub((spec_literal_int("9223372036854775808")).spec_neg())).spec_add(::builtin::spec_literal_nat("1"))))
            } else { (a).spec_sub(b) }
        }
        #[verifier(external_body)]
        pub struct PAtomicI64 {
            ato: AtomicI64,
        }
        #[proof]
        #[verifier(external_body)]
        pub struct PermissionI64 {
            no_copy: NoCopy,
        }
        #[spec]
        pub struct PermissionDataI64 {
            #[spec]
            pub patomic: int,
            #[spec]
            pub value: i64,
        }
        impl PermissionI64 {
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermissionDataI64 {
                ::core::panicking::panic("not implemented");
            }
            #[spec]
            #[verifier(publish)]
            pub fn is_for(&self, patomic: PAtomicI64) -> bool {
                self.view().patomic == patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn points_to(&self, v: i64) -> bool { self.view().value == v }
        }
        impl PAtomicI64 {
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn new(i: i64) -> (PAtomicI64, Proof<PermissionI64>) {
                ensures(|res: (PAtomicI64, Proof<PermissionI64>)|
                            equal(res.1.0.view(),
                                  PermissionDataI64{patomic: res.0.id(),
                                                    value: i,}));
                let p = PAtomicI64{ato: <AtomicI64>::new(i),};
                let Proof(t) = exec_proof_from_false();
                (p, Proof(t))
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn load(&self, #[proof] perm: &PermissionI64) -> i64 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: i64| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.load(Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn store(&self, #[proof] perm: &mut PermissionI64, v: i64) {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(equal(perm.view().value, v) &&
                            equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                self.ato.store(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange(&self, #[proof] perm: &mut PermissionI64,
                                    current: i64, new: i64)
             -> Result<i64, i64> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<i64, i64>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    current != old(perm).view().value &&
                                        equal(perm.view().value,
                                              old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange(current, new,
                                                Ordering::SeqCst,
                                                Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn compare_exchange_weak(&self,
                                         #[proof] perm: &mut PermissionI64,
                                         current: i64, new: i64)
             -> Result<i64, i64> {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: Result<i64, i64>|
                            equal(self.id(), perm.view().patomic) &&
                                match ret {
                                    Result::Ok(r) =>
                                    current == old(perm).view().value &&
                                        equal(perm.view().value, new) &&
                                        equal(r, old(perm).view().value),
                                    Result::Err(r) =>
                                    equal(perm.view().value,
                                          old(perm).view().value) &&
                                        equal(r, old(perm).view().value),
                                });
                opens_invariants_none();
                match self.ato.compare_exchange_weak(current, new,
                                                     Ordering::SeqCst,
                                                     Ordering::SeqCst) {
                    Ok(x) => Result::Ok(x),
                    Err(x) => Result::Err(x),
                }
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn swap(&self, #[proof] perm: &mut PermissionI64, v: i64)
             -> i64 {
                requires([equal(self.id(), old(perm).view().patomic)]);
                ensures(|ret: i64|
                            equal(perm.view().value, v) &&
                                equal(old(perm).view().value, ret) &&
                                equal(self.id(), perm.view().patomic));
                opens_invariants_none();
                return self.ato.swap(v, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            pub fn into_inner(self, #[proof] perm: PermissionI64) -> i64 {
                requires([equal(self.id(), perm.view().patomic)]);
                ensures(|ret: i64| equal(perm.view().value, ret));
                opens_invariants_none();
                return self.ato.into_inner();
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_add_wrapping(&self,
                                      #[proof] perm: &mut PermissionI64,
                                      n: i64) -> i64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<i64, int>(perm.view().value)
                                 ==
                                 wrapping_add_i64(spec_cast_integer(old(perm).view().value),
                                                  spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_add(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_sub_wrapping(&self,
                                      #[proof] perm: &mut PermissionI64,
                                      n: i64) -> i64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             spec_cast_integer::<i64, int>(perm.view().value)
                                 ==
                                 wrapping_sub_i64(spec_cast_integer::<i64,
                                                                      int>(old(perm).view().value),
                                                  spec_cast_integer(n))]);
                opens_invariants_none();
                return self.ato.fetch_sub(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_add(&self, #[proof] perm: &mut PermissionI64, n: i64)
             -> i64 {
                requires([equal(self.id(), old(perm).view().patomic),
                          -spec_literal_int("9223372036854775808") <=
                              old(perm).view().value.spec_add(n),
                          old(perm).view().value.spec_add(n) <=
                              spec_literal_int("9223372036854775807")]);
                ensures(|ret: i64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value + n]);
                opens_invariants_none();
                self.fetch_add_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(atomic)]
            pub fn fetch_sub(&self, #[proof] perm: &mut PermissionI64, n: i64)
             -> i64 {
                requires([equal(self.id(), old(perm).view().patomic),
                          -spec_literal_int("9223372036854775808") <=
                              old(perm).view().value.spec_sub(n),
                          old(perm).view().value.spec_sub(n) <=
                              spec_literal_int("9223372036854775807")]);
                ensures(|ret: i64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 old(perm).view().value - n]);
                opens_invariants_none();
                self.fetch_sub_wrapping(&mut *perm, n)
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_and(&self, #[proof] perm: &mut PermissionI64, n: i64)
             -> i64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_and(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_or(&self, #[proof] perm: &mut PermissionI64, n: i64)
             -> i64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value | n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_xor(&self, #[proof] perm: &mut PermissionI64, n: i64)
             -> i64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (old(perm).view().value ^ n)]);
                opens_invariants_none();
                return self.ato.fetch_or(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_nand(&self, #[proof] perm: &mut PermissionI64,
                              n: i64) -> i64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 !(old(perm).view().value & n)]);
                opens_invariants_none();
                return self.ato.fetch_nand(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_max(&self, #[proof] perm: &mut PermissionI64, n: i64)
             -> i64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value > n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_max(n, Ordering::SeqCst);
            }
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(atomic)]
            pub fn fetch_min(&self, #[proof] perm: &mut PermissionI64, n: i64)
             -> i64 {
                requires(equal(self.id(), old(perm).view().patomic));
                ensures(|ret: i64|
                            [equal(old(perm).view().value, ret),
                             perm.view().patomic == old(perm).view().patomic,
                             perm.view().value ==
                                 (if old(perm).view().value < n {
                                      old(perm).view().value
                                  } else { n })]);
                opens_invariants_none();
                return self.ato.fetch_min(n, Ordering::SeqCst);
            }
        }
    }
    pub mod atomic_ghost {
        //! Provides sequentially-consistent atomic memory locations with associated ghost state.
        //! See the [`atomic_with_ghost!`] documentation for more information.
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use crate::pervasive::invariant::*;
        use crate::pervasive::atomic::*;
        use crate::pervasive::modes::*;
        pub trait AtomicInvariantPredicate<K, V, G> {
            #[verifier(verus_macro)]
            #[spec]
            fn atomic_inv(k: K, v: V, g: G) -> bool {
                ::builtin::no_method_body()
            }
        }
        macro_rules! declare_atomic_type {
            ($at_ident : ident, $patomic_ty : ident, $perm_ty : ty, $value_ty
             : ty, $atomic_pred_ty : ident) =>
            {
                pub struct $atomic_pred_ty < Pred > { p : Pred } impl < K, G,
                Pred > InvariantPredicate < (K, int), ($perm_ty, G) > for
                $atomic_pred_ty < Pred > where Pred : AtomicInvariantPredicate
                < K, $value_ty, G >
                {
                    #[verifier(publish)] #[spec] fn
                    inv(k_loc : (K, int), perm_g : ($perm_ty, G)) -> bool
                    {
                        let(k, loc) = k_loc ; let(perm, g) = perm_g ;
                        perm.view().patomic == loc && Pred ::
                        atomic_inv(k, perm.view().value, g)
                    }
                }
                #[doc = concat!
                  ("Sequentially-consistent atomic memory location storing a `",
                   stringify! ($value_ty), "` and associated ghost state.")]
                ///
                /// See the [`atomic_with_ghost!`] documentation for usage information.
                pub struct $at_ident < K, #[verifier(maybe_negative)] G, Pred
                >
                {
                    #[doc(hidden)] pub patomic : $patomic_ty, #[doc(hidden)]
                    #[proof] pub atomic_inv : AtomicInvariant < (K, int),
                    ($perm_ty, G), $atomic_pred_ty < Pred >>,
                } impl < K, G, Pred > $at_ident < K, G, Pred > where Pred :
                AtomicInvariantPredicate < K, $value_ty, G >
                {
                    #[spec] #[verifier(publish)] pub fn well_formed(& self) ->
                    bool { self.atomic_inv.constant().1 == self.patomic.id() }
                    #[spec] #[verifier(publish)] pub fn constant(& self) -> K
                    { self.atomic_inv.constant().0 } #[inline(always)] pub fn
                    new(#[spec] k : K, u : $value_ty, #[proof] g : G) -> Self
                    {
                        requires(Pred :: atomic_inv(k, u, g)) ;
                        ensures(| t : Self | t.well_formed() &&
                                equal(t.constant(), k)) ;
                        let(patomic, Proof(perm)) = $patomic_ty :: new(u) ;
                        #[proof] let pair = (perm, g) ; #[proof] let
                        atomic_inv = AtomicInvariant ::
                        new((k, patomic.id()), pair, spec_literal_int("0")) ;
                        $at_ident { patomic, atomic_inv, }
                    }
                }
            }
        }
        pub struct AtomicPredU64<Pred> {
            p: Pred,
        }
        impl <K, G, Pred> InvariantPredicate<(K, int), (PermissionU64, G)> for
         AtomicPredU64<Pred> where Pred: AtomicInvariantPredicate<K, u64, G> {
            #[verifier(publish)]
            #[spec]
            fn inv(k_loc: (K, int), perm_g: (PermissionU64, G)) -> bool {
                let (k, loc) = k_loc;
                let (perm, g) = perm_g;
                perm.view().patomic == loc &&
                    Pred::atomic_inv(k, perm.view().value, g)
            }
        }
        #[doc =
          "Sequentially-consistent atomic memory location storing a `u64` and associated ghost state."]
        ///
        /// See the [`atomic_with_ghost!`] documentation for usage information.
        pub struct AtomicU64<K, #[verifier(maybe_negative)] G, Pred> {
            #[doc(hidden)]
            pub patomic: PAtomicU64,
            #[doc(hidden)]
            #[proof]
            pub atomic_inv: AtomicInvariant<(K, int), (PermissionU64, G),
                                            AtomicPredU64<Pred>>,
        }
        impl <K, G, Pred> AtomicU64<K, G, Pred> where
         Pred: AtomicInvariantPredicate<K, u64, G> {
            #[spec]
            #[verifier(publish)]
            pub fn well_formed(&self) -> bool {
                self.atomic_inv.constant().1 == self.patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn constant(&self) -> K { self.atomic_inv.constant().0 }
            #[inline(always)]
            pub fn new(#[spec] k: K, u: u64, #[proof] g: G) -> Self {
                requires(Pred::atomic_inv(k, u, g));
                ensures(|t: Self| t.well_formed() && equal(t.constant(), k));
                let (patomic, Proof(perm)) = PAtomicU64::new(u);
                #[proof]
                let pair = (perm, g);
                #[proof]
                let atomic_inv =
                    AtomicInvariant::new((k, patomic.id()), pair,
                                         spec_literal_int("0"));
                AtomicU64{patomic, atomic_inv,}
            }
        }
        pub struct AtomicPredU32<Pred> {
            p: Pred,
        }
        impl <K, G, Pred> InvariantPredicate<(K, int), (PermissionU32, G)> for
         AtomicPredU32<Pred> where Pred: AtomicInvariantPredicate<K, u32, G> {
            #[verifier(publish)]
            #[spec]
            fn inv(k_loc: (K, int), perm_g: (PermissionU32, G)) -> bool {
                let (k, loc) = k_loc;
                let (perm, g) = perm_g;
                perm.view().patomic == loc &&
                    Pred::atomic_inv(k, perm.view().value, g)
            }
        }
        #[doc =
          "Sequentially-consistent atomic memory location storing a `u32` and associated ghost state."]
        ///
        /// See the [`atomic_with_ghost!`] documentation for usage information.
        pub struct AtomicU32<K, #[verifier(maybe_negative)] G, Pred> {
            #[doc(hidden)]
            pub patomic: PAtomicU32,
            #[doc(hidden)]
            #[proof]
            pub atomic_inv: AtomicInvariant<(K, int), (PermissionU32, G),
                                            AtomicPredU32<Pred>>,
        }
        impl <K, G, Pred> AtomicU32<K, G, Pred> where
         Pred: AtomicInvariantPredicate<K, u32, G> {
            #[spec]
            #[verifier(publish)]
            pub fn well_formed(&self) -> bool {
                self.atomic_inv.constant().1 == self.patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn constant(&self) -> K { self.atomic_inv.constant().0 }
            #[inline(always)]
            pub fn new(#[spec] k: K, u: u32, #[proof] g: G) -> Self {
                requires(Pred::atomic_inv(k, u, g));
                ensures(|t: Self| t.well_formed() && equal(t.constant(), k));
                let (patomic, Proof(perm)) = PAtomicU32::new(u);
                #[proof]
                let pair = (perm, g);
                #[proof]
                let atomic_inv =
                    AtomicInvariant::new((k, patomic.id()), pair,
                                         spec_literal_int("0"));
                AtomicU32{patomic, atomic_inv,}
            }
        }
        pub struct AtomicPredU16<Pred> {
            p: Pred,
        }
        impl <K, G, Pred> InvariantPredicate<(K, int), (PermissionU16, G)> for
         AtomicPredU16<Pred> where Pred: AtomicInvariantPredicate<K, u16, G> {
            #[verifier(publish)]
            #[spec]
            fn inv(k_loc: (K, int), perm_g: (PermissionU16, G)) -> bool {
                let (k, loc) = k_loc;
                let (perm, g) = perm_g;
                perm.view().patomic == loc &&
                    Pred::atomic_inv(k, perm.view().value, g)
            }
        }
        #[doc =
          "Sequentially-consistent atomic memory location storing a `u16` and associated ghost state."]
        ///
        /// See the [`atomic_with_ghost!`] documentation for usage information.
        pub struct AtomicU16<K, #[verifier(maybe_negative)] G, Pred> {
            #[doc(hidden)]
            pub patomic: PAtomicU16,
            #[doc(hidden)]
            #[proof]
            pub atomic_inv: AtomicInvariant<(K, int), (PermissionU16, G),
                                            AtomicPredU16<Pred>>,
        }
        impl <K, G, Pred> AtomicU16<K, G, Pred> where
         Pred: AtomicInvariantPredicate<K, u16, G> {
            #[spec]
            #[verifier(publish)]
            pub fn well_formed(&self) -> bool {
                self.atomic_inv.constant().1 == self.patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn constant(&self) -> K { self.atomic_inv.constant().0 }
            #[inline(always)]
            pub fn new(#[spec] k: K, u: u16, #[proof] g: G) -> Self {
                requires(Pred::atomic_inv(k, u, g));
                ensures(|t: Self| t.well_formed() && equal(t.constant(), k));
                let (patomic, Proof(perm)) = PAtomicU16::new(u);
                #[proof]
                let pair = (perm, g);
                #[proof]
                let atomic_inv =
                    AtomicInvariant::new((k, patomic.id()), pair,
                                         spec_literal_int("0"));
                AtomicU16{patomic, atomic_inv,}
            }
        }
        pub struct AtomicPredU8<Pred> {
            p: Pred,
        }
        impl <K, G, Pred> InvariantPredicate<(K, int), (PermissionU8, G)> for
         AtomicPredU8<Pred> where Pred: AtomicInvariantPredicate<K, u8, G> {
            #[verifier(publish)]
            #[spec]
            fn inv(k_loc: (K, int), perm_g: (PermissionU8, G)) -> bool {
                let (k, loc) = k_loc;
                let (perm, g) = perm_g;
                perm.view().patomic == loc &&
                    Pred::atomic_inv(k, perm.view().value, g)
            }
        }
        #[doc =
          "Sequentially-consistent atomic memory location storing a `u8` and associated ghost state."]
        ///
        /// See the [`atomic_with_ghost!`] documentation for usage information.
        pub struct AtomicU8<K, #[verifier(maybe_negative)] G, Pred> {
            #[doc(hidden)]
            pub patomic: PAtomicU8,
            #[doc(hidden)]
            #[proof]
            pub atomic_inv: AtomicInvariant<(K, int), (PermissionU8, G),
                                            AtomicPredU8<Pred>>,
        }
        impl <K, G, Pred> AtomicU8<K, G, Pred> where
         Pred: AtomicInvariantPredicate<K, u8, G> {
            #[spec]
            #[verifier(publish)]
            pub fn well_formed(&self) -> bool {
                self.atomic_inv.constant().1 == self.patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn constant(&self) -> K { self.atomic_inv.constant().0 }
            #[inline(always)]
            pub fn new(#[spec] k: K, u: u8, #[proof] g: G) -> Self {
                requires(Pred::atomic_inv(k, u, g));
                ensures(|t: Self| t.well_formed() && equal(t.constant(), k));
                let (patomic, Proof(perm)) = PAtomicU8::new(u);
                #[proof]
                let pair = (perm, g);
                #[proof]
                let atomic_inv =
                    AtomicInvariant::new((k, patomic.id()), pair,
                                         spec_literal_int("0"));
                AtomicU8{patomic, atomic_inv,}
            }
        }
        pub struct AtomicPredI64<Pred> {
            p: Pred,
        }
        impl <K, G, Pred> InvariantPredicate<(K, int), (PermissionI64, G)> for
         AtomicPredI64<Pred> where Pred: AtomicInvariantPredicate<K, i64, G> {
            #[verifier(publish)]
            #[spec]
            fn inv(k_loc: (K, int), perm_g: (PermissionI64, G)) -> bool {
                let (k, loc) = k_loc;
                let (perm, g) = perm_g;
                perm.view().patomic == loc &&
                    Pred::atomic_inv(k, perm.view().value, g)
            }
        }
        #[doc =
          "Sequentially-consistent atomic memory location storing a `i64` and associated ghost state."]
        ///
        /// See the [`atomic_with_ghost!`] documentation for usage information.
        pub struct AtomicI64<K, #[verifier(maybe_negative)] G, Pred> {
            #[doc(hidden)]
            pub patomic: PAtomicI64,
            #[doc(hidden)]
            #[proof]
            pub atomic_inv: AtomicInvariant<(K, int), (PermissionI64, G),
                                            AtomicPredI64<Pred>>,
        }
        impl <K, G, Pred> AtomicI64<K, G, Pred> where
         Pred: AtomicInvariantPredicate<K, i64, G> {
            #[spec]
            #[verifier(publish)]
            pub fn well_formed(&self) -> bool {
                self.atomic_inv.constant().1 == self.patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn constant(&self) -> K { self.atomic_inv.constant().0 }
            #[inline(always)]
            pub fn new(#[spec] k: K, u: i64, #[proof] g: G) -> Self {
                requires(Pred::atomic_inv(k, u, g));
                ensures(|t: Self| t.well_formed() && equal(t.constant(), k));
                let (patomic, Proof(perm)) = PAtomicI64::new(u);
                #[proof]
                let pair = (perm, g);
                #[proof]
                let atomic_inv =
                    AtomicInvariant::new((k, patomic.id()), pair,
                                         spec_literal_int("0"));
                AtomicI64{patomic, atomic_inv,}
            }
        }
        pub struct AtomicPredI32<Pred> {
            p: Pred,
        }
        impl <K, G, Pred> InvariantPredicate<(K, int), (PermissionI32, G)> for
         AtomicPredI32<Pred> where Pred: AtomicInvariantPredicate<K, i32, G> {
            #[verifier(publish)]
            #[spec]
            fn inv(k_loc: (K, int), perm_g: (PermissionI32, G)) -> bool {
                let (k, loc) = k_loc;
                let (perm, g) = perm_g;
                perm.view().patomic == loc &&
                    Pred::atomic_inv(k, perm.view().value, g)
            }
        }
        #[doc =
          "Sequentially-consistent atomic memory location storing a `i32` and associated ghost state."]
        ///
        /// See the [`atomic_with_ghost!`] documentation for usage information.
        pub struct AtomicI32<K, #[verifier(maybe_negative)] G, Pred> {
            #[doc(hidden)]
            pub patomic: PAtomicI32,
            #[doc(hidden)]
            #[proof]
            pub atomic_inv: AtomicInvariant<(K, int), (PermissionI32, G),
                                            AtomicPredI32<Pred>>,
        }
        impl <K, G, Pred> AtomicI32<K, G, Pred> where
         Pred: AtomicInvariantPredicate<K, i32, G> {
            #[spec]
            #[verifier(publish)]
            pub fn well_formed(&self) -> bool {
                self.atomic_inv.constant().1 == self.patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn constant(&self) -> K { self.atomic_inv.constant().0 }
            #[inline(always)]
            pub fn new(#[spec] k: K, u: i32, #[proof] g: G) -> Self {
                requires(Pred::atomic_inv(k, u, g));
                ensures(|t: Self| t.well_formed() && equal(t.constant(), k));
                let (patomic, Proof(perm)) = PAtomicI32::new(u);
                #[proof]
                let pair = (perm, g);
                #[proof]
                let atomic_inv =
                    AtomicInvariant::new((k, patomic.id()), pair,
                                         spec_literal_int("0"));
                AtomicI32{patomic, atomic_inv,}
            }
        }
        pub struct AtomicPredI16<Pred> {
            p: Pred,
        }
        impl <K, G, Pred> InvariantPredicate<(K, int), (PermissionI16, G)> for
         AtomicPredI16<Pred> where Pred: AtomicInvariantPredicate<K, i16, G> {
            #[verifier(publish)]
            #[spec]
            fn inv(k_loc: (K, int), perm_g: (PermissionI16, G)) -> bool {
                let (k, loc) = k_loc;
                let (perm, g) = perm_g;
                perm.view().patomic == loc &&
                    Pred::atomic_inv(k, perm.view().value, g)
            }
        }
        #[doc =
          "Sequentially-consistent atomic memory location storing a `i16` and associated ghost state."]
        ///
        /// See the [`atomic_with_ghost!`] documentation for usage information.
        pub struct AtomicI16<K, #[verifier(maybe_negative)] G, Pred> {
            #[doc(hidden)]
            pub patomic: PAtomicI16,
            #[doc(hidden)]
            #[proof]
            pub atomic_inv: AtomicInvariant<(K, int), (PermissionI16, G),
                                            AtomicPredI16<Pred>>,
        }
        impl <K, G, Pred> AtomicI16<K, G, Pred> where
         Pred: AtomicInvariantPredicate<K, i16, G> {
            #[spec]
            #[verifier(publish)]
            pub fn well_formed(&self) -> bool {
                self.atomic_inv.constant().1 == self.patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn constant(&self) -> K { self.atomic_inv.constant().0 }
            #[inline(always)]
            pub fn new(#[spec] k: K, u: i16, #[proof] g: G) -> Self {
                requires(Pred::atomic_inv(k, u, g));
                ensures(|t: Self| t.well_formed() && equal(t.constant(), k));
                let (patomic, Proof(perm)) = PAtomicI16::new(u);
                #[proof]
                let pair = (perm, g);
                #[proof]
                let atomic_inv =
                    AtomicInvariant::new((k, patomic.id()), pair,
                                         spec_literal_int("0"));
                AtomicI16{patomic, atomic_inv,}
            }
        }
        pub struct AtomicPredI8<Pred> {
            p: Pred,
        }
        impl <K, G, Pred> InvariantPredicate<(K, int), (PermissionI8, G)> for
         AtomicPredI8<Pred> where Pred: AtomicInvariantPredicate<K, i8, G> {
            #[verifier(publish)]
            #[spec]
            fn inv(k_loc: (K, int), perm_g: (PermissionI8, G)) -> bool {
                let (k, loc) = k_loc;
                let (perm, g) = perm_g;
                perm.view().patomic == loc &&
                    Pred::atomic_inv(k, perm.view().value, g)
            }
        }
        #[doc =
          "Sequentially-consistent atomic memory location storing a `i8` and associated ghost state."]
        ///
        /// See the [`atomic_with_ghost!`] documentation for usage information.
        pub struct AtomicI8<K, #[verifier(maybe_negative)] G, Pred> {
            #[doc(hidden)]
            pub patomic: PAtomicI8,
            #[doc(hidden)]
            #[proof]
            pub atomic_inv: AtomicInvariant<(K, int), (PermissionI8, G),
                                            AtomicPredI8<Pred>>,
        }
        impl <K, G, Pred> AtomicI8<K, G, Pred> where
         Pred: AtomicInvariantPredicate<K, i8, G> {
            #[spec]
            #[verifier(publish)]
            pub fn well_formed(&self) -> bool {
                self.atomic_inv.constant().1 == self.patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn constant(&self) -> K { self.atomic_inv.constant().0 }
            #[inline(always)]
            pub fn new(#[spec] k: K, u: i8, #[proof] g: G) -> Self {
                requires(Pred::atomic_inv(k, u, g));
                ensures(|t: Self| t.well_formed() && equal(t.constant(), k));
                let (patomic, Proof(perm)) = PAtomicI8::new(u);
                #[proof]
                let pair = (perm, g);
                #[proof]
                let atomic_inv =
                    AtomicInvariant::new((k, patomic.id()), pair,
                                         spec_literal_int("0"));
                AtomicI8{patomic, atomic_inv,}
            }
        }
        pub struct AtomicPredBool<Pred> {
            p: Pred,
        }
        impl <K, G, Pred> InvariantPredicate<(K, int), (PermissionBool, G)>
         for AtomicPredBool<Pred> where
         Pred: AtomicInvariantPredicate<K, bool, G> {
            #[verifier(publish)]
            #[spec]
            fn inv(k_loc: (K, int), perm_g: (PermissionBool, G)) -> bool {
                let (k, loc) = k_loc;
                let (perm, g) = perm_g;
                perm.view().patomic == loc &&
                    Pred::atomic_inv(k, perm.view().value, g)
            }
        }
        #[doc =
          "Sequentially-consistent atomic memory location storing a `bool` and associated ghost state."]
        ///
        /// See the [`atomic_with_ghost!`] documentation for usage information.
        pub struct AtomicBool<K, #[verifier(maybe_negative)] G, Pred> {
            #[doc(hidden)]
            pub patomic: PAtomicBool,
            #[doc(hidden)]
            #[proof]
            pub atomic_inv: AtomicInvariant<(K, int), (PermissionBool, G),
                                            AtomicPredBool<Pred>>,
        }
        impl <K, G, Pred> AtomicBool<K, G, Pred> where
         Pred: AtomicInvariantPredicate<K, bool, G> {
            #[spec]
            #[verifier(publish)]
            pub fn well_formed(&self) -> bool {
                self.atomic_inv.constant().1 == self.patomic.id()
            }
            #[spec]
            #[verifier(publish)]
            pub fn constant(&self) -> K { self.atomic_inv.constant().0 }
            #[inline(always)]
            pub fn new(#[spec] k: K, u: bool, #[proof] g: G) -> Self {
                requires(Pred::atomic_inv(k, u, g));
                ensures(|t: Self| t.well_formed() && equal(t.constant(), k));
                let (patomic, Proof(perm)) = PAtomicBool::new(u);
                #[proof]
                let pair = (perm, g);
                #[proof]
                let atomic_inv =
                    AtomicInvariant::new((k, patomic.id()), pair,
                                         spec_literal_int("0"));
                AtomicBool{patomic, atomic_inv,}
            }
        }
        /// Performs a given atomic operation on a given atomic
        /// while providing access to its ghost state.
        ///
        /// `atomic_with_ghost!` supports the types
        /// [`AtomicU64`] [`AtomicU32`], [`AtomicU16`], [`AtomicU8`],
        /// [`AtomicI64`], [`AtomicI32`], [`AtomicI16`], [`AtomicI8`], and [`AtomicBool`].
        ///
        /// For each type, it supports all applicable atomic operations among
        /// `load`, `store`, `swap`, `compare_exchange`, `compare_exchange_weak`,
        /// `fetch_add`, `fetch_add_wrapping`, `fetch_sub`, `fetch_sub_wrapping`,
        /// `fetch_or`, `fetch_and`, `fetch_xor`, `fetch_nand`, `fetch_max`, and `fetch_min`.
        ///
        /// Naturally, `AtomicBool` does not support the arithmetic-specific operations.
        ///
        /// In general, the syntax is:
        ///
        ///     let result = atomic_with_ghost!(
        ///         $atomic => $operation_name($operands...);
        ///         update $prev -> $next;         // `update` line is optional
        ///         returning $ret;                // `returning` line is optional
        ///         ghost $g => {
        ///             /* Proof code with access to `tracked` variable `g: G` */
        ///         }
        ///     );
        ///
        /// Here, the `$operation_name` is one of `load`, `store`, etc. Meanwhile,
        /// `$prev`, `$next`, and `$ret` are all identifiers which 
        /// will be available as spec variable inside the block to describe the
        /// atomic action which is performed.
        ///
        /// For example, suppose the user performs `fetch_add(1)`. The atomic
        /// operation might load the value 5, add 1, store the value 6,
        /// and return the original value, 5. In that case, we would have
        /// `prev == 5`, `next == 6`, and `ret == 5`.
        ///
        /// The specification for a given operation is given as a relation between
        /// `prev`, `next`, and `ret`; that is, at the beginning of the proof block,
        /// the user may assume the given specification holds:
        ///
        /// | operation                     | specification                                                                                                              |
        /// |-------------------------------|----------------------------------------------------------------------------------------------------------------------------|
        /// | `load()`                      | `next == prev && rev == prev`                                                                                              |
        /// | `store(x)`                    | `next == x && ret == ()`                                                                                                   |
        /// | `swap(x)`                     | `next == x && ret == prev`                                                                                                 |
        /// | `compare_exchange(x, y)`      | `prev == x && next == y && ret == Ok(prev)` ("success") OR<br> `prev != x && next == prev && ret == Err(prev)` ("failure") |
        /// | `compare_exchange_weak(x, y)` | `prev == x && next == y && ret == Ok(prev)` ("success") OR<br> `next == prev && ret == Err(prev)` ("failure")              |
        /// | `fetch_add(x)` (*)            | `next == prev + x && ret == prev`                                                                                          |
        /// | `fetch_add_wrapping(x)`       | `next == wrapping_add(prev, x) && ret == prev`                                                                             |
        /// | `fetch_sub(x)` (*)            | `next == prev - x && ret == prev`                                                                                          |
        /// | `fetch_sub_wrapping(x)`       | `next == wrapping_sub(prev, x) && ret == prev`                                                                             |
        /// | `fetch_or(x)`                 | <code>next == prev \| x && ret == prev</code>                                                                              |
        /// | `fetch_and(x)`                | `next == prev & x && ret == prev`                                                                                          |
        /// | `fetch_xor(x)`                | `next == prev ^ x && ret == prev`                                                                                          |
        /// | `fetch_nand(x)`               | `next == !(prev & x) && ret == prev`                                                                                       |
        /// | `fetch_max(x)`                | `next == max(prev, x) && ret == prev`                                                                                      |
        /// | `fetch_min(x)`                | `next == max(prev, x) && ret == prev`                                                                                      |
        /// | `no_op()` (**)                | `next == prev && ret == ()`                                                                                                |
        ///
        /// (*) Note that `fetch_add` and `fetch_sub` do not specify
        /// wrapping-on-overflow; instead, they require the user to
        /// prove that overflow _does not occur_, i.e., the user must show
        /// that `next` is in bounds for the integer type in question.
        /// Furthermore, for `fetch_add` and `fetch_sub`, the spec values of
        /// `prev`, `next`, and `ret` are all given with type `int`, so the
        /// user may reason about boundedness within the proof block.
        ///
        /// (As executable code, `fetch_add` is equivalent to `fetch_add_wrapping`,
        /// and likewise for `fetch_sub` and `fetch_sub_wrapping`.
        /// We have both because it's frequently the case that the user needs to verify
        /// lack-of-overflow _anyway_, and having it as an explicit precondition by default
        /// then makes verification errors easier to diagnose. Furthermore, when overflow is
        /// intended, the wrapping operations document that intent.)
        ///
        /// (**) `no_op` is entirely a ghost operation and doesn't emit any actual instruction.
        /// This allows the user to access the ghost state and the stored value (as `spec` data)
        /// without actually performing a load.
        ///
        /// ---
        ///
        /// At the beginning of the proof block, the user may assume, in addition
        /// to the specified relation between `prev`, `next`, and `ret`, that
        /// `atomic.inv(prev, g)` holds. The user is required to update `g` such that
        /// `atomic.inv(next, g)` holds at the end of the block.
        /// In other words, the ghost block has the implicit pre- and post-conditions:
        ///
        ///     let result = atomic_with_ghost!(
        ///         $atomic => $operation_name($operands...);
        ///         update $prev -> $next;
        ///         returning $ret;
        ///         ghost $g => {
        ///             assume(specified relation on (prev, next, ret));
        ///             assume(atomic.inv(prev, g));
        ///
        ///             // User code here; may update variable `g` with full
        ///             // access to variables in the outer context.
        ///
        ///             assert(atomic.inv(next, g));
        ///         }
        ///     );
        ///
        /// Note that the necessary action on ghost state might depend
        /// on the result of the operation; for example, if the user performs a
        /// compare-and-swap, then the ghost action that they then need to do
        /// will probably depend on whether the operation succeeded or not.
        ///
        /// The value returned by the `atomic_with_ghost!(...)` expression will be equal
        /// to `ret`, although the return value is an `exec` value (the actual result of
        /// the operation) while `ret` is a `spec` value.
        ///
        /// ### Example (TODO)
        #[macro_export]
        macro_rules! atomic_with_ghost {
            ($atomic : expr => $operation_name : ident($($operands : tt) *) ;
             update $prev : ident -> $next : ident ; returning $ret : ident ;
             ghost $g : ident => $b : block) =>
            {
                atomic_with_ghost_inner!
                ($operation_name, $atomic, ($($operands) *), $prev, $next,
                 $ret, $g, $b)
            } ;
            ($atomic : expr => $operation_name : ident($($operands : tt) *) ;
             update $prev : ident -> $next : ident ; ghost $g : ident => $b :
             block) =>
            {
                atomic_with_ghost_inner!
                ($operation_name, $atomic, ($($operands) *), $prev, $next, _,
                 $g, $b)
            } ;
            ($atomic : expr => $operation_name : ident($($operands : tt) *) ;
             returning $ret : ident ; ghost $g : ident => $b : block) =>
            {
                atomic_with_ghost_inner!
                ($operation_name, $atomic, ($($operands) *), _, _, $ret, $g,
                 $b)
            } ;
            ($atomic : expr => $operation_name : ident($($operands : tt) *) ;
             ghost $g : ident => $b : block) =>
            {
                atomic_with_ghost_inner!
                ($operation_name, $atomic, ($($operands) *), _, _, _, $g, $b)
            } ;
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! atomic_with_ghost_inner {
            (load, $e : expr, (), $prev : pat, $next : pat, $ret : pat, $g :
             ident, $b : block) =>
            { atomic_with_ghost_load! ($e, $prev, $next, $ret, $g, $b) } ;
            (store, $e : expr, ($operand : expr), $prev : pat, $next : pat,
             $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_store!
                ($e, $operand, $prev, $next, $ret, $g, $b)
            } ;
            (swap, $e : expr, ($operand : expr), $prev : pat, $next : pat,
             $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_with_1_operand!
                (swap, $e, $operand, $prev, $next, $ret, $g, $b)
            } ;
            (fetch_or, $e : expr, ($operand : expr), $prev : pat, $next : pat,
             $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_with_1_operand!
                (fetch_or, $e, $operand, $prev, $next, $ret, $g, $b)
            } ;
            (fetch_and, $e : expr, ($operand : expr), $prev : pat, $next :
             pat, $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_with_1_operand!
                (fetch_and, $e, $operand, $prev, $next, $ret, $g, $b)
            } ;
            (fetch_xor, $e : expr, ($operand : expr), $prev : pat, $next :
             pat, $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_with_1_operand!
                (fetch_xor, $e, $operand, $prev, $next, $ret, $g, $b)
            } ;
            (fetch_nand, $e : expr, ($operand : expr), $prev : pat, $next :
             pat, $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_with_1_operand!
                (fetch_nand, $e, $operand, $prev, $next, $ret, $g, $b)
            } ;
            (fetch_max, $e : expr, ($operand : expr), $prev : pat, $next :
             pat, $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_with_1_operand!
                (fetch_max, $e, $operand, $prev, $next, $ret, $g, $b)
            } ;
            (fetch_min, $e : expr, ($operand : expr), $prev : pat, $next :
             pat, $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_with_1_operand!
                (fetch_min, $e, $operand, $prev, $next, $ret, $g, $b)
            } ;
            (fetch_add_wrapping, $e : expr, ($operand : expr), $prev : pat,
             $next : pat, $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_with_1_operand!
                (fetch_add_wrapping, $e, $operand, $prev, $next, $ret, $g, $b)
            } ;
            (fetch_sub_wrapping, $e : expr, ($operand : expr), $prev : pat,
             $next : pat, $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_with_1_operand!
                (fetch_sub_wrapping, $e, $operand, $prev, $next, $ret, $g, $b)
            } ;
            (fetch_add, $e : expr, ($operand : expr), $prev : pat, $next :
             pat, $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_fetch_add!
                ($e, $operand, $prev, $next, $ret, $g, $b)
            } ;
            (fetch_sub, $e : expr, ($operand : expr), $prev : pat, $next :
             pat, $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_fetch_sub!
                ($e, $operand, $prev, $next, $ret, $g, $b)
            } ;
            (compare_exchange, $e : expr,
             ($operand1 : expr, $operand2 : expr), $prev : pat, $next : pat,
             $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_with_2_operand!
                (compare_exchange, $e, $operand1, $operand2, $prev, $next,
                 $ret, $g, $b)
            } ;
            (compare_exchange_weak, $e : expr,
             ($operand1 : expr, $operand2 : expr), $prev : pat, $next : pat,
             $ret : pat, $g : ident, $b : block) =>
            {
                atomic_with_ghost_update_with_2_operand!
                (compare_exchange_weak, $e, $operand1, $operand2, $prev,
                 $next, $ret, $g, $b)
            } ;
            (no_op, $e : expr, (), $prev : pat, $next : pat, $ret : pat, $g :
             ident, $b : block) =>
            { atomic_with_ghost_no_op! ($e, $prev, $next, $ret, $g, $b) } ;
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! atomic_with_ghost_store {
            ($e : expr, $operand : expr, $prev : pat, $next : pat, $res : pat,
             $g : ident, $b : block) =>
            {
                {
                    let atomic = & $e ; crate :: open_atomic_invariant!
                    (& atomic.atomic_inv => pair =>
                     {
                         #[allow(unused_mut)] #[proof] let(mut perm, mut $g) =
                         pair ; #[spec] let $prev = perm.view().value ;
                         atomic.patomic.store(& mut perm, $operand) ; #[spec]
                         let $next = perm.view().value ; #[spec] let $res = ()
                         ; { $b } pair = (perm, $g) ;
                     }) ;
                }
            }
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! atomic_with_ghost_load {
            ($e : expr, $prev : pat, $next : pat, $res : pat, $g : ident, $b :
             block) =>
            {
                {
                    let result ; let atomic = & $e ; crate ::
                    open_atomic_invariant!
                    (& atomic.atomic_inv => pair =>
                     {
                         #[allow(unused_mut)] #[proof] let(perm, mut $g) =
                         pair ; result = atomic.patomic.load(& perm) ; #[spec]
                         let $res = result ; #[spec] let $prev = result ;
                         #[spec] let $next = result ; { $b } pair = (perm, $g)
                         ;
                     }) ; result
                }
            }
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! atomic_with_ghost_no_op {
            ($e : expr, $prev : pat, $next : pat, $res : pat, $g : ident, $b :
             block) =>
            {
                {
                    let atomic = & $e ; crate :: open_atomic_invariant!
                    (& atomic.atomic_inv => pair =>
                     {
                         #[allow(unused_mut)] #[proof] let(perm, mut $g) =
                         pair ; #[spec] let $res = result ; #[spec] let $prev
                         = result ; #[spec] let $next = result ; { $b } pair =
                         (perm, $g) ;
                     }) ;
                }
            }
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! atomic_with_ghost_update_with_1_operand {
            ($name : ident, $e : expr, $operand : expr, $prev : pat, $next :
             pat, $res : pat, $g : ident, $b : block) =>
            {
                {
                    let result ; let atomic = & $e ; crate ::
                    open_atomic_invariant!
                    (& atomic.atomic_inv => pair =>
                     {
                         #[allow(unused_mut)] #[proof] let(mut perm, mut $g) =
                         pair ; #[spec] let $prev = perm.view().value ; result
                         = atomic.patomic.$name(& mut perm, $operand) ;
                         #[spec] let $res = result ; #[spec] let $next =
                         perm.view().value ; { $b } pair = (perm, $g) ;
                     }) ; result
                }
            }
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! atomic_with_ghost_update_with_2_operand {
            ($name : ident, $e : expr, $operand1 : expr, $operand2 : expr,
             $prev : pat, $next : pat, $res : pat, $g : ident, $b : block) =>
            {
                {
                    let result ; let atomic = & $e ; crate ::
                    open_atomic_invariant!
                    (& atomic.atomic_inv => pair =>
                     {
                         #[allow(unused_mut)] #[proof] let(mut perm, mut $g) =
                         pair ; #[spec] let $prev = perm.view().value ; result
                         =
                         atomic.patomic.$name(& mut perm, $operand1,
                                              $operand2) ; #[spec] let $res =
                         result ; #[spec] let $next = perm.view().value ;
                         { $b } pair = (perm, $g) ;
                     }) ; result
                }
            }
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! atomic_with_ghost_update_fetch_add {
            ($e : expr, $operand : expr, $prev : pat, $next : pat, $res : pat,
             $g : ident, $b : block) =>
            {
                {
                    let result ; let atomic = & $e ; crate ::
                    open_atomic_invariant!
                    (& atomic.atomic_inv => pair =>
                     {
                         #[allow(unused_mut)] #[proof] let(mut perm, mut $g) =
                         pair ; #[spec] let $prev = :: builtin ::
                         spec_cast_integer :: < _, int > (perm.view().value) ;
                         let op = $operand ; #[spec] let computed = :: builtin
                         :: spec_cast_integer :: < _, int >
                         (perm.view().value) + :: builtin :: spec_cast_integer
                         :: < _, int > (op) ; #[spec] let $res = computed ;
                         #[spec] let $next = computed ; { $b } result =
                         atomic.patomic.fetch_add(& mut perm, op) ; pair =
                         (perm, $g) ;
                     }) ; result
                }
            }
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! atomic_with_ghost_update_fetch_sub {
            ($e : expr, $operand : expr, $prev : pat, $next : pat, $res : pat,
             $g : ident, $b : block) =>
            {
                {
                    let result ; let atomic = & $e ; crate ::
                    open_atomic_invariant!
                    (& atomic.atomic_inv => pair =>
                     {
                         #[allow(unused_mut)] #[proof] let(mut perm, mut $g) =
                         pair ; #[spec] let $prev = :: builtin ::
                         spec_cast_integer :: < _, int > (perm.view().value) ;
                         let op = $operand ; #[spec] let computed = :: builtin
                         :: spec_cast_integer :: < _, int >
                         (perm.view().value) - :: builtin :: spec_cast_integer
                         :: < _, int > (op) ; #[spec] let $res = computed ;
                         #[spec] let $next = computed ; { $b } result =
                         atomic.patomic.fetch_sub(& mut perm, op) ; pair =
                         (perm, $g) ;
                     }) ; result
                }
            }
        }
    }
    pub mod modes {
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        pub fn ghost_exec<A>(#[spec] a: A) -> Ghost<A> {
            ::builtin::ensures(|s: Ghost<A>|
                                   [::builtin::equal(a, (s.view()))]);
            Ghost::assume_new()
        }
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        pub fn tracked_exec<A>(#[proof] a: A) -> Tracked<A> {
            ::builtin::ensures(|s: Tracked<A>|
                                   [::builtin::equal(a, (s.view()))]);
            opens_invariants_none();
            Tracked::assume_new()
        }
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        pub fn tracked_exec_borrow<'a, A>(#[proof] a: &'a A)
         -> &'a Tracked<A> {
            ::builtin::ensures(|s: &'a Tracked<A>|
                                   [::builtin::equal(*a, (s.view()))]);
            opens_invariants_none();
            ::core::panicking::panic("not implemented");
        }
        pub struct Gho<A>(
                          #[spec]
                          pub A);
        pub struct Trk<A>(
                          #[proof]
                          pub A);
        #[inline(always)]
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        pub fn ghost_unwrap_gho<A>(a: Ghost<Gho<A>>) -> Ghost<A> {
            ::builtin::ensures(|ret: Ghost<A>|
                                   [::builtin::equal((a.view()).0,
                                                     (ret.view()))]);
            Ghost::assume_new()
        }
        #[inline(always)]
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        pub fn tracked_unwrap_gho<A>(a: Tracked<Gho<A>>) -> Tracked<A> {
            ::builtin::ensures(|ret: Tracked<A>|
                                   [::builtin::equal((a.view()).0,
                                                     (ret.view()))]);
            Tracked::assume_new()
        }
        #[inline(always)]
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        pub fn tracked_unwrap_trk<A>(a: Tracked<Trk<A>>) -> Tracked<A> {
            ::builtin::ensures(|ret: Tracked<A>|
                                   [::builtin::equal((a.view()).0,
                                                     (ret.view()))]);
            Tracked::assume_new()
        }
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn tracked_swap<V>(#[proof] a: &mut V, #[proof] b: &mut V) {
            ::builtin::ensures([::builtin::equal(a, old(b)),
                                ::builtin::equal(b, old(a))]);
            ::core::panicking::panic("not implemented");
        }
        pub struct Proof<A>(
                            #[proof]
                            pub A);
        impl <A> PartialEq for Proof<A> {
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            fn eq(&self, _rhs: &Proof<A>) -> bool { true }
        }
        impl <A> Eq for Proof<A> { }
        #[allow(dead_code)]
        #[inline(always)]
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        pub fn exec_proof_from_false<A>() -> Proof<A> {
            ::builtin::requires([false]);
            Proof(proof_from_false())
        }
    }
    pub mod multiset {
        use core::{marker};
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[allow(unused_imports)]
        use crate::pervasive::set::*;
        #[doc =
          " `Multiset<V>` is an abstract multiset type for specifications."]
        #[doc = ""]
        #[doc =
          " `Multiset<V>` can be encoded as a (total) map from elements to natural numbers,"]
        #[doc = " where the number of nonzero entries is finite."]
        #[doc = ""]
        #[doc = " Multisets can be constructed in a few different ways:"]
        #[doc = "  * [`Multiset::empty()`] constructs an empty multiset."]
        #[doc =
          "  * By manipulating existings multisets with [`Multiset::add`], [`Multiset::insert`],"]
        #[doc =
          "    [`Multiset::sub`], [`Multiset::remove`], or [`Multiset::filter`]."]
        #[doc =
          "  * TODO: `multiset!` constructor macro, multiset from set, from map, etc."]
        #[doc = ""]
        #[doc =
          " To prove that two multisets are equal, it is usually easiest to use the "]
        #[doc = " [`assert_multisets_equal!`] macro."]
        #[verifier(external_body)]
        pub struct Multiset<#[verifier(strictly_positive)] V> {
            dummy: marker::PhantomData<V>,
        }
        impl <V> Multiset<V> {
            #[doc =
              " Returns the _count_, or _multiplicity_ of a single value within the multiset."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn count(self, value: V) -> nat {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " The total size of the multiset, i.e., the sum of all multiplicities over all values."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn len(self) -> nat {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " An empty multiset."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn empty() -> Self {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " A singleton multiset, i.e., a multiset with a single element of multiplicity 1."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn singleton(v: V) -> Self {
                ::core::panicking::panic("not implemented")
            }
            #[doc =
              " Takes the union of two multisets. For a given element, its multiplicity in"]
            #[doc =
              " the resulting multiset is the sum of its multiplicities in the operands."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn add(self, m2: Self) -> Self {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Takes the difference of two multisets."]
            #[doc =
              " The multiplicities of `m2` are subtracted from those of `self`; if any element"]
            #[doc =
              " occurs more in `m2` then the resulting multiplicity bottoms out at 0."]
            #[doc =
              " (See [`axiom_multiset_sub`] for the precise definition.)"]
            #[doc = ""]
            #[doc =
              " Note in particular that `self === self.sub(m).add(m)` only holds if"]
            #[doc = " `m` is included in `self`."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn sub(self, m2: Self) -> Self {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Inserts one instance the value `v` into the multiset."]
            #[doc = ""]
            #[doc =
              " This always increases the total size of the multiset by 1."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn insert(self, v: V) -> Self { self.add(Self::singleton(v)) }
            #[doc =
              " Removes one instance of the value `v` from the multiset."]
            #[doc = ""]
            #[doc =
              " If `v` was absent from the multiset, then the multiset is unchanged."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn remove(self, v: V) -> Self { self.sub(Self::singleton(v)) }
            #[doc =
              " Returns `true` is the left argument is contained in the right argument,"]
            #[doc =
              " that is, if for each value `v`, the number of occurences in the left"]
            #[doc = " is at most the number of occurences in the right."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn le(self, m2: Self) -> bool {
                ::builtin::forall(|v: V| (self.count(v)).spec_le(m2.count(v)))
            }
            #[doc =
              " Returns true if the two multisets are pointwise equal, i.e.,"]
            #[doc =
              " for every value `v: V`, the counts are the same in each multiset."]
            #[doc =
              " This is equivalent to the multisets actually being equal"]
            #[doc = " by [`axiom_multiset_ext_equal`]."]
            #[doc = ""]
            #[doc =
              " To prove that two maps are equal via extensionality, it is generally easier"]
            #[doc =
              " to use the [`assert_multisets_equal!`] macro, rather than using `ext_equal` directly."]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn ext_equal(self, m2: Self) -> bool {
                ::builtin::forall(|v: V|
                                      ::builtin::spec_eq(self.count(v),
                                                         m2.count(v)))
            }
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn filter(self, f: impl Fn(V) -> bool) -> Self {
                ::core::panicking::panic("not implemented")
            }
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_multiset_empty<V>(v: V) {
            ::builtin::ensures([::builtin::spec_eq(Multiset::empty().count(v),
                                                   ::builtin::spec_literal_nat("0"))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_multiset_singleton<V>(v: V) {
            ::builtin::ensures([::builtin::spec_eq((#[trigger] Multiset::singleton(v)).count(v),
                                                   ::builtin::spec_literal_nat("1"))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_multiset_singleton_different<V>(v: V, w: V) {
            ::builtin::ensures([::builtin::imply(!::builtin::equal(v, w),
                                                 ::builtin::spec_eq(Multiset::singleton(v).count(w),
                                                                    ::builtin::spec_literal_nat("0")))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_multiset_add<V>(m1: Multiset<V>, m2: Multiset<V>, v: V) {
            ::builtin::ensures([::builtin::spec_eq(m1.add(m2).count(v),
                                                   (m1.count(v)).spec_add(m2.count(v)))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_multiset_sub<V>(m1: Multiset<V>, m2: Multiset<V>, v: V) {
            ::builtin::ensures([::builtin::spec_eq(m1.sub(m2).count(v),
                                                   if (m1.count(v)).spec_ge(m2.count(v))
                                                      {
                                                       (m1.count(v)).spec_sub(m2.count(v))
                                                   } else {
                                                       ::builtin::spec_literal_integer("0")
                                                   })]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_multiset_ext_equal<V>(m1: Multiset<V>, m2: Multiset<V>) {
            ::builtin::ensures([::builtin::spec_eq(m1.ext_equal(m2),
                                                   equal(m1, m2))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_len_empty<V>() {
            ::builtin::ensures([::builtin::spec_eq((#[trigger] Multiset::<V>::empty().len()),
                                                   ::builtin::spec_literal_nat("0"))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_len_singleton<V>(v: V) {
            ::builtin::ensures([::builtin::spec_eq((#[trigger] Multiset::<V>::singleton(v).len()),
                                                   ::builtin::spec_literal_nat("1"))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_len_add<V>(m1: Multiset<V>, m2: Multiset<V>) {
            ::builtin::ensures([::builtin::spec_eq((#[trigger] m1.add(m2).len()),
                                                   (m1.len()).spec_add(m2.len()))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_len_sub<V>(m1: Multiset<V>, m2: Multiset<V>) {
            ::builtin::requires([m2.le(m1)]);
            ::builtin::ensures([::builtin::spec_eq((#[trigger] m1.sub(m2).len()),
                                                   (m1.len()).spec_sub(m2.len()))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_count_le_len<V>(m: Multiset<V>, v: V) {
            ::builtin::ensures([(#[trigger] m.count(v)).spec_le(#[trigger] m.len())]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_filter_count<V>(m: Multiset<V>,
                                     f: ::builtin::FnSpec<(V,), bool>, v: V) {
            ::builtin::ensures([::builtin::spec_eq((#[trigger] m.filter(f).count(v)),
                                                   if f(v) {
                                                       m.count(v)
                                                   } else {
                                                       ::builtin::spec_literal_integer("0")
                                                   })]);
        }
        #[macro_export]
        macro_rules! assert_multisets_equal {
            ($m1 : expr, $m2 : expr $(,) ?) =>
            { assert_multisets_equal! ($m1, $m2, key => { }) } ;
            ($m1 : expr, $m2 : expr, $k : ident $(: $t : ty) ? => $bblock :
             block) =>
            {
                #[spec] let m1 = $m1 ; #[spec] let m2 = $m2 ; :: builtin ::
                assert_by(:: builtin :: equal(m1, m2),
                          {
                              :: builtin ::
                              assert_forall_by(| $k $(: $t) ? |
                                               {
                                                   :: builtin ::
                                                   ensures([:: builtin ::
                                                            equal(m1.count($k),
                                                                  m2.count($k))])
                                                   ; { $bblock }
                                               }) ; $crate :: pervasive ::
                              assert(m1.ext_equal(m2)) ;
                          }) ;
            }
        }
    }
    pub mod function {
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[doc = " General properties of spec functions."]
        #[doc = ""]
        #[doc =
          " For now, this just contains an axiom of function extensionality for"]
        #[doc = " FnSpec."]
        #[doc =
          " A dummy expression used only to give `fun_ext` a trigger. See the comment"]
        #[doc = " below."]
        #[verifier(verus_macro)]
        #[spec]
        #[verifier(external_body)]
        pub fn dummy_trigger<A>(x: A) {
            ::core::panicking::panic("not implemented")
        }
        #[doc =
          " Axiom of function extensionality: two functions are equal if they are"]
        #[doc = " equal on all inputs."]
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn fun_ext<A,
                       B>(f1: ::builtin::FnSpec<(A,), B>,
                          f2: ::builtin::FnSpec<(A,), B>) {
            ::builtin::requires([::builtin::forall(|x: A|
                                                       ::builtin::with_triggers(((dummy_trigger(x),),),
                                                                                ::builtin::equal(f1(x),
                                                                                                 f2(x))))]);
            ::builtin::ensures([::builtin::equal(f1, f2)]);
        }
    }
    pub mod state_machine_internal {
        //! Helper utilities used by the `state_machine_macros` codegen.
        #![allow(unused_imports)]
        #![doc(hidden)]
        use builtin::*;
        use builtin_macros::*;
        use crate::pervasive::*;
        use crate::pervasive::seq::*;
        use crate::pervasive::map::*;
        use crate::pervasive::option::*;
        #[verifier(external_body)]
        pub struct SyncSendIfSyncSend<#[verifier(strictly_positive)] T> {
            _sync_send: builtin::SyncSendIfSyncSend<T>,
        }
        #[verifier(external_body)]
        pub struct NoCopy {
            _no_copy: builtin::NoCopy,
        }
        #[proof]
        #[verifier(custom_req_err("unable to prove assertion safety condition"))]
        pub fn assert_safety(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove safety condition that the pattern matches"))]
        pub fn assert_let_pattern(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: to add a value Some(_), field must be None before the update"))]
        pub fn assert_add_option(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: to add a singleton set, the value must not be in the set before the update"))]
        pub fn assert_add_set(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: to add a value `true`, field must be `false` before the update"))]
        pub fn assert_add_bool(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the given key must be absent from the map before the update"))]
        pub fn assert_add_map(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: if the key is already in the map, its existing value must agree with the provided value"))]
        pub fn assert_add_persistent_map(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: if the previous value is Some(_), then this existing value must agree with the newly provided value"))]
        pub fn assert_add_persistent_option(b: bool) {
            requires(b);
            ensures(b);
        }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the given value to be withdrawn must be stored before the withdraw"))]
        pub fn assert_withdraw_option(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: to deposit a value into Some(_), the field must be None before the deposit"))]
        pub fn assert_deposit_option(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the value being guarded must be stored"))]
        pub fn assert_guard_option(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the value to be withdrawn must be stored at the given key before the withdraw"))]
        pub fn assert_withdraw_map(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the given key must be absent from the map before the deposit"))]
        pub fn assert_deposit_map(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the value being guarded must be stored at the given key"))]
        pub fn assert_guard_map(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the optional values being composed cannot both be Some(_)"))]
        pub fn assert_general_add_option(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the sets being composed must be disjoint"))]
        pub fn assert_general_add_set(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the boolean values being composed cannot both be `true`"))]
        pub fn assert_general_add_bool(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the key domains of the maps being composed must be disjoint"))]
        pub fn assert_general_add_map(b: bool) { requires(b); ensures(b); }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the maps being composed must agree on their values for any key in both domains"))]
        pub fn assert_general_add_persistent_map(b: bool) {
            requires(b);
            ensures(b);
        }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: if the previous value and the newly added values are both Some(_), then their values must agree"))]
        pub fn assert_general_add_persistent_option(b: bool) {
            requires(b);
            ensures(b);
        }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the optional value to be withdrawn must be stored before the withdraw"))]
        pub fn assert_general_withdraw_option(b: bool) {
            requires(b);
            ensures(b);
        }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the optional values being composed cannot both be Some(_)"))]
        pub fn assert_general_deposit_option(b: bool) {
            requires(b);
            ensures(b);
        }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the value being guarded must be stored"))]
        pub fn assert_general_guard_option(b: bool) {
            requires(b);
            ensures(b);
        }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the map being withdrawn must be a submap of the stored map"))]
        pub fn assert_general_withdraw_map(b: bool) {
            requires(b);
            ensures(b);
        }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the key domains of the maps being composed must be disjoint"))]
        pub fn assert_general_deposit_map(b: bool) {
            requires(b);
            ensures(b);
        }
        #[proof]
        #[verifier(custom_req_err("unable to prove inherent safety condition: the map being guarded must be a submap of the stored map"))]
        pub fn assert_general_guard_map(b: bool) { requires(b); ensures(b); }
        #[doc(hidden)]
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn nat_max(a: nat, b: nat) -> nat {
            if (a).spec_gt(b) { a } else { b }
        }
        #[doc(hidden)]
        impl <A> Seq<A> {
            #[verifier(inline)]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn update_at_index(self, i: int, a: A) -> Self {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                         i),
                                                                                              self.len()))]);
                self.update(i, a)
            }
        }
        #[doc(hidden)]
        impl <K, V> Map<K, V> {
            #[verifier(inline)]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn update_at_index(self, k: K, v: V) -> Self {
                self.insert(k, v)
            }
        }
        #[doc(hidden)]
        #[verifier(inline)]
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn opt_is_none<V>(a: Option<V>) -> bool { a.is_None() }
        #[doc(hidden)]
        #[verifier(inline)]
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn opt_ge<V>(a: Option<V>, b: Option<V>) -> bool {
            ::builtin::imply(b.is_Some(), ::builtin::equal(a, b))
        }
        #[doc(hidden)]
        #[verifier(inline)]
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn opt_add<V>(a: Option<V>, b: Option<V>) -> Option<V> {
            if b.is_Some() { b } else { a }
        }
        #[doc(hidden)]
        #[verifier(inline)]
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn opt_agree<V>(a: Option<V>, b: Option<V>) -> bool {
            ::builtin::imply(a.is_Some() && b.is_Some(),
                             ::builtin::equal(a.get_Some_0(), b.get_Some_0()))
        }
        #[doc(hidden)]
        #[verifier(inline)]
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn opt_sub<V>(a: Option<V>, b: Option<V>) -> Option<V> {
            if b.is_Some() { Option::None } else { a }
        }
    }
    #[cfg(not(feature = "non_std"))]
    pub mod thread {
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[allow(unused_imports)]
        use crate::pervasive::result::*;
        #[doc =
          " Object returned by [`spawn()`](spawn) to allow thread joining."]
        #[doc =
          " (Wrapper around [`std::thread::JoinHandle`](https://doc.rust-lang.org/std/thread/struct.JoinHandle.html).)"]
        #[doc = ""]
        #[doc =
          " See the documentation of [`spawn()`](spawn) for more details."]
        #[verifier(external_body)]
        pub struct JoinHandle<#[verifier(maybe_negative)] Ret> {
            handle: std::thread::JoinHandle<Ret>,
        }
        impl <Ret> JoinHandle<Ret> {
            #[doc =
              " Predicate restricting the possible return values. This is determined by the"]
            #[doc =
              " postcondition of the closure provided when calling `spawn()`."]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn predicate(&self, ret: Ret) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Wait for a thread to complete."]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn join(self) -> Result<Ret, ()> {
                ::builtin::ensures(|r_result: Result<Ret, ()>|
                                       [match r_result {
                                            Result::Ok(r) =>
                                            self.predicate(r),
                                            Result::Err(_) => true,
                                        }]);
                let res =
                    std::panic::catch_unwind(std::panic::AssertUnwindSafe(||
                                                                              {
                                                                                  match self.handle.join()
                                                                                      {
                                                                                      Ok(r)
                                                                                      =>
                                                                                      Result::Ok(r),
                                                                                      Err(_)
                                                                                      =>
                                                                                      Result::Err(()),
                                                                                  }
                                                                              }));
                match res {
                    Ok(res) => res,
                    Err(_) => {
                        {
                            ::std::io::_print(::core::fmt::Arguments::new_v1(&["panic on join\n"],
                                                                             &match ()
                                                                                  {
                                                                                  _args
                                                                                  =>
                                                                                  [],
                                                                              }));
                        };
                        std::process::abort();
                    }
                }
            }
        }
        #[doc =
          " Spawns a thread. (Wrapper around [`std::thread::spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html).)"]
        #[doc = ""]
        #[doc = " This takes as input a `FnOnce` closure with no arguments."]
        #[doc =
          " The `spawn` returns a [`JoinHandle`], on which the client can call"]
        #[doc = " [`join()`](JoinHandle::join) to wait"]
        #[doc =
          " for the thread to complete. The return value of the closure is returned via `join()`."]
        #[doc = ""]
        #[doc =
          " The closure must be callable (i.e., its precondition must be satisfied)"]
        #[doc =
          " but it may have an arbitrary postcondition. The postcondition is passed through"]
        #[doc =
          " the `JoinHandle` via [`JoinHandle::predicate()`](JoinHandle::predicate)."]
        #[doc = ""]
        #[doc = " ### Example"]
        #[doc = ""]
        #[doc = " ```rust,ignore"]
        #[doc = " struct MyInteger {"]
        #[doc = "     u: u64,"]
        #[doc = " }"]
        #[doc = " "]
        #[doc = " fn main() {"]
        #[doc = "     // Construct an object to pass into the thread."]
        #[doc = "     let my_int = MyInteger { u: 5 };"]
        #[doc = " "]
        #[doc = "     // Spawn a new thread."]
        #[doc = "     let join_handle = spawn(move || {"]
        #[doc = "         ensures(|return_value: MyInteger|"]
        #[doc = "             return_value.u == 20);"]
        #[doc = " "]
        #[doc = "         // Move the `my_int` object into the closure."]
        #[doc = "         let mut my_int_on_another_thread = my_int;"]
        #[doc = " "]
        #[doc = "         // Update its value."]
        #[doc = "         my_int_on_another_thread.u = 20;"]
        #[doc = " "]
        #[doc = "         // Return it."]
        #[doc = "         my_int_on_another_thread"]
        #[doc = "     });"]
        #[doc = " "]
        #[doc = "     // Wait for the thread to finish its work."]
        #[doc = "     let result_my_int = join_handle.join();"]
        #[doc = " "]
        #[doc = "     match result_my_int {"]
        #[doc = "         Result::Ok(my_int) => {"]
        #[doc =
          "             // Obtain the `MyInteger` object that was passed"]
        #[doc = "             // back from the spawned thread."]
        #[doc = "             // Assert that it has the right value."]
        #[doc = "             assert(my_int.u == 20);"]
        #[doc = "         }"]
        #[doc = "         Result::Err(_) => { }"]
        #[doc = "     }"]
        #[doc = " }"]
        #[doc = " ```"]
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        pub fn spawn<F, Ret>(f: F) -> JoinHandle<Ret> where F: FnOnce()
         -> Ret, F: Send + 'static, Ret: Send + 'static {
            ::builtin::requires([f.requires(())]);
            ::builtin::ensures(|handle: JoinHandle<Ret>|
                                   [::builtin::forall(|ret: Ret|
                                                          ::builtin::imply(#[trigger] handle.predicate(ret),
                                                                           f.ensures((),
                                                                                     ret)))]);
            let res =
                std::panic::catch_unwind(std::panic::AssertUnwindSafe(||
                                                                          {
                                                                              let handle =
                                                                                  std::thread::spawn(move
                                                                                                         ||
                                                                                                         f());
                                                                              JoinHandle{handle,}
                                                                          }));
            match res {
                Ok(res) => res,
                Err(_) => {
                    {
                        ::std::io::_print(::core::fmt::Arguments::new_v1(&["panic on spawn\n"],
                                                                         &match ()
                                                                              {
                                                                              _args
                                                                              =>
                                                                              [],
                                                                          }));
                    };
                    std::process::abort();
                }
            }
        }
    }
    #[cfg(not(feature = "no_global_allocator"))]
    pub mod ptr {
        use core::{marker, mem, mem::MaybeUninit};
        extern crate alloc;
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[allow(unused_imports)]
        use crate::pervasive::modes::*;
        #[doc = " `PPtr<V>` (which stands for \"permissioned pointer\")"]
        #[doc = " is a wrapper around a raw pointer to `V` on the heap."]
        #[doc = ""]
        #[doc =
          " Technically, it is a wrapper around `*mut mem::MaybeUninit<V>`, that is, the object"]
        #[doc = " it points to may be uninitialized."]
        #[doc = ""]
        #[doc =
          " In order to access (read or write) the value behind the pointer, the user needs"]
        #[doc =
          " a special _ghost permission token_, [`PermissionOpt<V>`](PermissionOpt). This object is `tracked`,"]
        #[doc =
          " which means that it is \"only a proof construct\" that does not appear in code,"]
        #[doc =
          " but its uses _are_ checked by the borrow-checker. This ensures memory safety,"]
        #[doc = " data-race-freedom, prohibits use-after-free, etc."]
        #[doc = ""]
        #[doc = " ### PermissionOpt objects."]
        #[doc = ""]
        #[doc =
          " The [`PermissionOpt`] object represents both the ability to access the data behind the"]
        #[doc =
          " pointer _and_ the ability to free it (return it to the memory allocator)."]
        #[doc = ""]
        #[doc = " In particular:"]
        #[doc =
          "  * When the user owns a `PermissionOpt<V>` object associated to a given pointer,"]
        #[doc =
          "    they can either read or write its contents, or deallocate (\"free\") it."]
        #[doc =
          "  * When the user has a shared borrow, `&PermissionOpt<V>`, they can read"]
        #[doc = "    the contents (i.e., obtained a shared borrow `&V`)."]
        #[doc = ""]
        #[doc =
          " The `perm: PermissionOpt<V>` object tracks two pieces of data:"]
        #[doc =
          "  * `perm.pptr` is the pointer that the permission is associated to,"]
        #[doc = "     given by [`ptr.id()`](PPtr::id)."]
        #[doc =
          "  * `perm.value` tracks the data that is behind the pointer. Thereby:"]
        #[doc =
          "      * When the user uses the permission to _read_ a value, they always"]
        #[doc = "        read the value as given by the `perm.value`."]
        #[doc =
          "      * When the user uses the permission to _write_ a value, the `perm.value`"]
        #[doc = "        data is updated."]
        #[doc = ""]
        #[doc =
          " For those familiar with separation logic, the `PermissionOpt` object plays a role"]
        #[doc =
          " similar to that of the \"points-to\" operator, _ptr_ ↦ _value_."]
        #[doc = ""]
        #[doc = " ### Differences from `PCell`."]
        #[doc = ""]
        #[doc =
          " `PPtr` is similar to [`cell::PCell`], but has a few key differences:"]
        #[doc =
          "  * In `PCell<T>`, the type `T` is placed internally to the `PCell`, whereas with `PPtr`,"]
        #[doc = "    the type `T` is placed at some location on the heap."]
        #[doc =
          "  * Since `PPtr` is just a pointer (represented by an integer), it can be `Copy`."]
        #[doc =
          "  * The `ptr::PermissionOpt` token represents not just the permission to read/write"]
        #[doc = "    the contents, but also to deallocate."]
        #[doc = ""]
        #[doc = " ### Example (TODO)"]
        #[verifier(external_body)]
        pub struct PPtr<#[verifier(strictly_positive)] V> {
            uptr: *mut MaybeUninit<V>,
        }
        #[verifier(external)]
        unsafe impl <T> Sync for PPtr<T> { }
        #[verifier(external)]
        unsafe impl <T> Send for PPtr<T> { }
        #[doc =
          " A `tracked` ghost object that gives the user permission to dereference a pointer"]
        #[doc =
          " for reading or writing, or to free the memory at that pointer."]
        #[doc = ""]
        #[doc =
          " The meaning of a `PermissionOpt` object is given by the data in its"]
        #[doc = " `View` object, [`PermissionOptData`]."]
        #[doc = ""]
        #[doc = " See the [`PPtr`] documentation for more details."]
        #[verifier(external_body)]
        #[proof]
        pub struct PermissionOpt<#[verifier(strictly_positive)] V> {
            phantom: marker::PhantomData<V>,
            no_copy: NoCopy,
        }
        #[doc = " Represents the meaning of a [`PermissionOpt`] object."]
        #[spec]
        pub struct PermissionOptData<V> {
            #[doc =
              " Indicates that this token is for a pointer `ptr: PPtr<V>`"]
            #[doc = " such that [`ptr.id()`](PPtr::id) equal to this value."]
            pub pptr: int,
            #[doc =
              " Indicates that this token gives the ability to read a value `V` from memory."]
            #[doc =
              " When `None`, it indicates that the memory is uninitialized."]
            pub value: option::Option<V>,
        }
        impl <V> PermissionOpt<V> {
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermissionOptData<V> {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Any dereferenceable pointer must be non-null."]
            #[doc =
              " (Note that null pointers _do_ exist and are representable by `PPtr`;"]
            #[doc =
              " however, it is not possible to obtain a `PermissionOpt` token for"]
            #[doc = " any such a pointer.)"]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            #[proof]
            pub fn is_nonnull(#[proof] &self) {
                ::builtin::ensures([!::builtin::spec_eq((self.view()).pptr,
                                                        ::builtin::spec_literal_nat("0"))]);
                ::core::panicking::panic("not implemented");
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            #[proof]
            pub fn leak_contents(#[proof] &mut self) {
                ::builtin::ensures([::builtin::spec_eq((self.view()).pptr,
                                                       (old(self).view()).pptr)
                                        && (self.view()).value.is_None()]);
                ::core::panicking::panic("not implemented");
            }
        }
        impl <V> PPtr<V> {
            #[doc = " Cast a pointer to an integer."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn to_usize(&self) -> usize {
                ::builtin::ensures(|u: usize|
                                       [::builtin::spec_eq(::builtin::spec_cast_integer::<_,
                                                                                          int>(u),
                                                           self.id())]);
                self.uptr as usize
            }
            #[doc = " integer address of the pointer"]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Cast an integer to a pointer."]
            #[doc = " "]
            #[doc =
              " Note that this does _not_ require or ensure that the pointer is valid."]
            #[doc =
              " Of course, if the user creates an invalid pointer, they would still not be able to"]
            #[doc =
              " create a valid [`PermissionOpt`] token for it, and thus they would never"]
            #[doc = " be able to access the data behind the pointer."]
            #[doc = ""]
            #[doc =
              " This is analogous to normal Rust, where casting to a pointer is always possible,"]
            #[doc = " but dereferencing a pointer is an `unsafe` operation."]
            #[doc =
              " In Verus, casting to a pointer is likewise always possible,"]
            #[doc =
              " while dereferencing it is only allowed when the right preconditions are met."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn from_usize(u: usize) -> Self {
                ::builtin::ensures(|p: Self|
                                       [::builtin::spec_eq(p.id(),
                                                           ::builtin::spec_cast_integer::<_,
                                                                                          int>(u))]);
                let uptr = u as *mut MaybeUninit<V>;
                PPtr{uptr,}
            }
            #[doc =
              " Allocates heap memory for type `V`, leaving it uninitialized."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn empty() -> (PPtr<V>, Tracked<PermissionOpt<V>>) {
                ::builtin::ensures(|pt: (PPtr<V>, Tracked<PermissionOpt<V>>)|
                                       [::builtin::equal(((pt.1.view()).view()),
                                                         (PermissionOptData{pptr:
                                                                                pt.0.id(),
                                                                            value:
                                                                                option::Option::None,}))]);
                opens_invariants_none();
                let p =
                    PPtr{uptr:
                             alloc::boxed::Box::leak(alloc::boxed::Box::new(MaybeUninit::uninit())).as_mut_ptr(),};
                let _exposed_addr = p.uptr as usize;
                (p, Tracked::assume_new())
            }
            #[doc = " Clones the pointer."]
            #[doc = " TODO implement the `Clone` and `Copy` traits"]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn clone(&self) -> PPtr<V> {
                ::builtin::ensures(|pt: PPtr<V>|
                                       [::builtin::equal(pt.id(),
                                                         self.id())]);
                opens_invariants_none();
                PPtr{uptr: self.uptr,}
            }
            #[doc =
              " Moves `v` into the location pointed to by the pointer `self`."]
            #[doc =
              " Requires the memory to be uninitialized, and leaves it initialized."]
            #[doc = ""]
            #[doc = " In the ghost perspective, this updates `perm.value`"]
            #[doc = " from `None` to `Some(v)`."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn put(&self, perm: &mut Tracked<PermissionOpt<V>>, v: V) {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      ((old(perm).view()).view()).pptr),
                                     ::builtin::equal(((old(perm).view()).view()).value,
                                                      option::Option::None)]);
                ::builtin::ensures([::builtin::equal(((perm.view()).view()).pptr,
                                                     ((old(perm).view()).view()).pptr),
                                    ::builtin::equal(((perm.view()).view()).value,
                                                     option::Option::Some(v))]);
                opens_invariants_none();
                unsafe { *(self.uptr) = MaybeUninit::new(v); }
            }
            #[doc =
              " Moves `v` out of the location pointed to by the pointer `self`"]
            #[doc = " and returns it."]
            #[doc =
              " Requires the memory to be initialized, and leaves it uninitialized."]
            #[doc = ""]
            #[doc = " In the ghost perspective, this updates `perm@.value`"]
            #[doc = " from `Some(v)` to `None`,"]
            #[doc = " while returning the `v` as an `exec` value."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn take(&self, perm: &mut Tracked<PermissionOpt<V>>) -> V {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      ((old(perm).view()).view()).pptr),
                                     ((old(perm).view()).view()).value.is_Some()]);
                ::builtin::ensures(|v: V|
                                       [::builtin::equal(((perm.view()).view()).pptr,
                                                         ((old(perm).view()).view()).pptr),
                                        ::builtin::equal(((perm.view()).view()).value,
                                                         option::Option::None),
                                        ::builtin::equal(v,
                                                         ((old(perm).view()).view()).value.get_Some_0())]);
                opens_invariants_none();
                unsafe {
                    let mut m = MaybeUninit::uninit();
                    mem::swap(&mut m, &mut *self.uptr);
                    m.assume_init()
                }
            }
            #[doc =
              " Swaps the `in_v: V` passed in as an argument with the value in memory."]
            #[doc =
              " Requires the memory to be initialized, and leaves it initialized with the new value."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn replace(&self, perm: &mut Tracked<PermissionOpt<V>>,
                           in_v: V) -> V {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      ((old(perm).view()).view()).pptr),
                                     ((old(perm).view()).view()).value.is_Some()]);
                ::builtin::ensures(|out_v: V|
                                       [::builtin::equal(((perm.view()).view()).pptr,
                                                         ((old(perm).view()).view()).pptr),
                                        ::builtin::equal(((perm.view()).view()).value,
                                                         option::Option::Some(in_v)),
                                        ::builtin::equal(out_v,
                                                         ((old(perm).view()).view()).value.get_Some_0())]);
                opens_invariants_none();
                unsafe {
                    let mut m = MaybeUninit::new(in_v);
                    mem::swap(&mut m, &mut *self.uptr);
                    m.assume_init()
                }
            }
            #[doc =
              " Given a shared borrow of the `PermissionOpt<V>`, obtain a shared borrow of `V`."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn borrow<'a>(&self, perm: &'a Tracked<PermissionOpt<V>>)
             -> &'a V {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      ((perm.view()).view()).pptr),
                                     ((perm.view()).view()).value.is_Some()]);
                ::builtin::ensures(|v: &'a V|
                                       [::builtin::equal(*v,
                                                         ((perm.view()).view()).value.get_Some_0())]);
                opens_invariants_none();
                unsafe { (*self.uptr).assume_init_ref() }
            }
            #[doc = " Free the memory pointed to be `perm`."]
            #[doc = " Requires the memory to be uninitialized."]
            #[doc = ""]
            #[doc =
              " This consumes `perm`, since it will no longer be safe to access"]
            #[doc = " that memory location."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn dispose(&self, perm: Tracked<PermissionOpt<V>>) {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      ((perm.view()).view()).pptr),
                                     ::builtin::equal(((perm.view()).view()).value,
                                                      option::Option::None)]);
                opens_invariants_none();
                unsafe {
                    alloc::alloc::dealloc(self.uptr as *mut u8,
                                          alloc::alloc::Layout::for_value(&*self.uptr));
                }
            }
            #[doc = " Free the memory pointed to be `perm` and return the "]
            #[doc = " value that was previously there."]
            #[doc = " Requires the memory to be initialized."]
            #[doc =
              " This consumes the [`PermissionOpt`] token, since the user is giving up"]
            #[doc = " access to the memory by freeing it."]
            #[inline(always)]
            #[verifier(verus_macro)]
            pub fn into_inner(self, perm: Tracked<PermissionOpt<V>>) -> V {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      ((perm.view()).view()).pptr),
                                     ((perm.view()).view()).value.is_Some()]);
                ::builtin::ensures(|v: V|
                                       [::builtin::equal(v,
                                                         ((perm.view()).view()).value.get_Some_0())]);
                opens_invariants_none();
                let mut perm = perm;
                let v = self.take(&mut perm);
                self.dispose(perm);
                v
            }
            #[doc =
              " Allocates heap memory for type `V`, leaving it initialized"]
            #[doc = " with the given value `v`."]
            #[inline(always)]
            #[verifier(verus_macro)]
            pub fn new(v: V) -> (PPtr<V>, Tracked<PermissionOpt<V>>) {
                ::builtin::ensures(|pt: (PPtr<V>, Tracked<PermissionOpt<V>>)|
                                       [(::builtin::equal(((pt.1.view()).view()),
                                                          PermissionOptData{pptr:
                                                                                pt.0.id(),
                                                                            value:
                                                                                option::Option::Some(v),}))]);
                let (p, mut t) = Self::empty();
                p.put(&mut t, v);
                (p, t)
            }
        }
    }
    #[cfg(not(feature = "no_global_allocator"))]
    pub mod ptr_old_style {
        use core::{marker, mem, mem::MaybeUninit};
        extern crate alloc;
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[allow(unused_imports)]
        use crate::pervasive::modes::*;
        #[doc = " `PPtr<V>` (which stands for \"permissioned pointer\")"]
        #[doc = " is a wrapper around a raw pointer to `V` on the heap."]
        #[doc = ""]
        #[doc =
          " Technically, it is a wrapper around `*mut mem::MaybeUninit<V>`, that is, the object"]
        #[doc = " it points to may be uninitialized."]
        #[doc = ""]
        #[doc =
          " In order to access (read or write) the value behind the pointer, the user needs"]
        #[doc =
          " a special _ghost permission token_, [`PermData<V>`](PermData). This object is `tracked`,"]
        #[doc =
          " which means that it is \"only a proof construct\" that does not appear in code,"]
        #[doc =
          " but its uses _are_ checked by the borrow-checker. This ensures memory safety,"]
        #[doc = " data-race-freedom, prohibits use-after-free, etc."]
        #[doc = ""]
        #[doc = " ### PermData objects."]
        #[doc = ""]
        #[doc =
          " The [`PermData`] object represents both the ability to access the data behind the"]
        #[doc =
          " pointer _and_ the ability to free it (return it to the memory allocator)."]
        #[doc = ""]
        #[doc = " In particular:"]
        #[doc =
          "  * When the user owns a `PermData<V>` object associated to a given pointer,"]
        #[doc =
          "    they can either read or write its contents, or deallocate (\"free\") it."]
        #[doc =
          "  * When the user has a shared borrow, `&PermData<V>`, they can read"]
        #[doc = "    the contents (i.e., obtained a shared borrow `&V`)."]
        #[doc = ""]
        #[doc = " The `perm: PermData<V>` object tracks two pieces of data:"]
        #[doc =
          "  * `perm.pptr` is the pointer that the permission is associated to,"]
        #[doc = "     given by [`ptr.id()`](PPtr::id)."]
        #[doc =
          "  * `perm.value` tracks the data that is behind the pointer. Thereby:"]
        #[doc =
          "      * When the user uses the permission to _read_ a value, they always"]
        #[doc = "        read the value as given by the `perm.value`."]
        #[doc =
          "      * When the user uses the permission to _write_ a value, the `perm.value`"]
        #[doc = "        data is updated."]
        #[doc = ""]
        #[doc =
          " For those familiar with separation logic, the `PermData` object plays a role"]
        #[doc =
          " similar to that of the \"points-to\" operator, _ptr_ ↦ _value_."]
        #[doc = ""]
        #[doc = " ### Differences from `PCell`."]
        #[doc = ""]
        #[doc =
          " `PPtr` is similar to [`cell::PCell`], but has a few key differences:"]
        #[doc =
          "  * In `PCell<T>`, the type `T` is placed internally to the `PCell`, whereas with `PPtr`,"]
        #[doc = "    the type `T` is placed at some location on the heap."]
        #[doc =
          "  * Since `PPtr` is just a pointer (represented by an integer), it can be `Copy`."]
        #[doc =
          "  * The `ptr::PermData` token represents not just the permission to read/write"]
        #[doc = "    the contents, but also to deallocate."]
        #[doc = ""]
        #[doc = " ### Example (TODO)"]
        #[verifier(external_body)]
        pub struct PPtr<#[verifier(strictly_positive)] V> {
            uptr: *mut MaybeUninit<V>,
        }
        #[verifier(external)]
        unsafe impl <T> Sync for PPtr<T> { }
        #[verifier(external)]
        unsafe impl <T> Send for PPtr<T> { }
        #[doc =
          " A `tracked` ghost object that gives the user permission to dereference a pointer"]
        #[doc =
          " for reading or writing, or to free the memory at that pointer."]
        #[doc = ""]
        #[doc =
          " The meaning of a `PermData` object is given by the data in its"]
        #[doc = " `View` object, [`PermDataData`]."]
        #[doc = ""]
        #[doc = " See the [`PPtr`] documentation for more details."]
        #[verifier(external_body)]
        #[proof]
        pub struct PermData<#[verifier(strictly_positive)] V> {
            phantom: marker::PhantomData<V>,
            no_copy: NoCopy,
        }
        #[doc = " Represents the meaning of a [`PermData`] object."]
        #[spec]
        pub struct PermDataData<V> {
            #[doc =
              " Indicates that this token is for a pointer `ptr: PPtr<V>`"]
            #[doc = " such that [`ptr.id()`](PPtr::id) equal to this value."]
            pub pptr: int,
            #[doc =
              " Indicates that this token gives the ability to read a value `V` from memory."]
            #[doc =
              " When `None`, it indicates that the memory is uninitialized."]
            pub value: option::Option<V>,
        }
        #[doc(hidden)]
        #[macro_export]
        macro_rules! ptr_perm_internal {
            [$pcell : expr => $val : expr] =>
            {
                $crate :: pervasive :: ptr_old_style :: PermDataData
                { pptr : $pcell, value : $val, }
            } ;
        }
        #[macro_export]
        macro_rules! ptr_perm {
            [$($tail : tt) *] =>
            {
                :: builtin_macros :: verus_proof_macro_exprs!
                ($crate :: pervasive :: ptr_old_style :: ptr_perm_internal!
                 ($($tail) *))
            }
        }
        pub use ptr_perm_internal;
        pub use ptr_perm;
        impl <V> PermData<V> {
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn view(self) -> PermDataData<V> {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Any dereferenceable pointer must be non-null."]
            #[doc =
              " (Note that null pointers _do_ exist and are representable by `PPtr`;"]
            #[doc =
              " however, it is not possible to obtain a `PermData` token for"]
            #[doc = " any such a pointer.)"]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            #[proof]
            pub fn is_nonnull(#[proof] &self) {
                ::builtin::ensures([!::builtin::spec_eq(self.view().pptr,
                                                        ::builtin::spec_literal_nat("0"))]);
                ::core::panicking::panic("not implemented");
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            #[proof]
            pub fn leak_contents(#[proof] &mut self) {
                ::builtin::ensures([::builtin::spec_eq(self.view().pptr,
                                                       old(self).view().pptr)
                                        && self.view().value.is_None()]);
                ::core::panicking::panic("not implemented");
            }
        }
        impl <V> PPtr<V> {
            #[doc = " Cast a pointer to an integer."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn to_usize(&self) -> usize {
                ::builtin::ensures(|u: usize|
                                       [::builtin::spec_eq(::builtin::spec_cast_integer::<_,
                                                                                          int>(u),
                                                           self.id())]);
                self.uptr as usize
            }
            #[doc = " integer address of the pointer"]
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn id(&self) -> int {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " Cast an integer to a pointer."]
            #[doc = " "]
            #[doc =
              " Note that this does _not_ require or ensure that the pointer is valid."]
            #[doc =
              " Of course, if the user creates an invalid pointer, they would still not be able to"]
            #[doc =
              " create a valid [`PermData`] token for it, and thus they would never"]
            #[doc = " be able to access the data behind the pointer."]
            #[doc = ""]
            #[doc =
              " This is analogous to normal Rust, where casting to a pointer is always possible,"]
            #[doc = " but dereferencing a pointer is an `unsafe` operation."]
            #[doc =
              " In Verus, casting to a pointer is likewise always possible,"]
            #[doc =
              " while dereferencing it is only allowed when the right preconditions are met."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn from_usize(u: usize) -> Self {
                ::builtin::ensures(|p: Self|
                                       [::builtin::spec_eq(p.id(),
                                                           ::builtin::spec_cast_integer::<_,
                                                                                          int>(u))]);
                let uptr = u as *mut MaybeUninit<V>;
                PPtr{uptr,}
            }
            /// Allocates heap memory for type `V`, leaving it uninitialized.
            #[inline(always)]
            #[verifier(external_body)]
            pub fn empty() -> (PPtr<V>, Trk<PermData<V>>) {
                ensures(|pt: (PPtr<V>, Trk<PermData<V>>)|
                            equal(pt.1.0.view(),
                                  PermDataData{pptr: pt.0.id(),
                                               value:
                                                   option::Option::None,}));
                opens_invariants_none();
                let p =
                    PPtr{uptr:
                             alloc::boxed::Box::leak(alloc::boxed::Box::new(MaybeUninit::uninit())).as_mut_ptr(),};
                let _exposed_addr = p.uptr as usize;
                (p, Trk(proof_from_false()))
            }
            #[doc = " Clones the pointer."]
            #[doc = " TODO implement the `Clone` and `Copy` traits"]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn clone(&self) -> PPtr<V> {
                ::builtin::ensures(|pt: PPtr<V>|
                                       [::builtin::equal(pt, *self)]);
                opens_invariants_none();
                PPtr{uptr: self.uptr,}
            }
            /// Moves `v` into the location pointed to by the pointer `self`.
            /// Requires the memory to be uninitialized, and leaves it initialized.
            ///
            /// In the ghost perspective, this updates `perm.value`
            /// from `None` to `Some(v)`.
            #[inline(always)]
            #[verifier(external_body)]
            pub fn put(&self, #[proof] perm: &mut PermData<V>, v: V) {
                requires([self.id() == old(perm).view().pptr,
                          equal(old(perm).view().value,
                                option::Option::None)]);
                ensures([equal(perm.view().pptr, old(perm).view().pptr),
                         equal(perm.view().value, option::Option::Some(v))]);
                opens_invariants_none();
                unsafe { *(self.uptr) = MaybeUninit::new(v); }
            }
            /// Moves `v` out of the location pointed to by the pointer `self`
            /// and returns it.
            /// Requires the memory to be initialized, and leaves it uninitialized.
            ///
            /// In the ghost perspective, this updates `perm.view().value`
            /// from `Some(v)` to `None`,
            /// while returning the `v` as an `exec` value.
            #[inline(always)]
            #[verifier(external_body)]
            pub fn take(&self, #[proof] perm: &mut PermData<V>) -> V {
                requires([self.id() == old(perm).view().pptr,
                          old(perm).view().value.is_Some()]);
                ensures(|v: V|
                            [perm.view().pptr == old(perm).view().pptr,
                             equal(perm.view().value, option::Option::None),
                             equal(v, old(perm).view().value.get_Some_0())]);
                opens_invariants_none();
                unsafe {
                    let mut m = MaybeUninit::uninit();
                    mem::swap(&mut m, &mut *self.uptr);
                    m.assume_init()
                }
            }
            #[doc =
              " Swaps the `in_v: V` passed in as an argument with the value in memory."]
            #[doc =
              " Requires the memory to be initialized, and leaves it initialized with the new value."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn replace(&self, #[proof] perm: &mut PermData<V>, in_v: V)
             -> V {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      old(perm).view().pptr),
                                     old(perm).view().value.is_Some()]);
                ::builtin::ensures(|out_v: V|
                                       [::builtin::equal(perm.view().pptr,
                                                         old(perm).view().pptr),
                                        ::builtin::equal(perm.view().value,
                                                         option::Option::Some(in_v)),
                                        ::builtin::equal(out_v,
                                                         old(perm).view().value.get_Some_0())]);
                opens_invariants_none();
                unsafe {
                    let mut m = MaybeUninit::new(in_v);
                    mem::swap(&mut m, &mut *self.uptr);
                    m.assume_init()
                }
            }
            /// Given a shared borrow of the `PermData<V>`, obtain a shared borrow of `V`.
            #[inline(always)]
            #[verifier(external_body)]
            pub fn borrow<'a>(&self, #[proof] perm: &'a PermData<V>)
             -> &'a V {
                requires([equal(self.id(), perm.view().pptr),
                          perm.view().value.is_Some()]);
                ensures(|v: &V| equal(*v, perm.view().value.get_Some_0()));
                opens_invariants_none();
                unsafe { (*self.uptr).assume_init_ref() }
            }
            #[doc = " Free the memory pointed to be `perm`."]
            #[doc = " Requires the memory to be uninitialized."]
            #[doc = ""]
            #[doc =
              " This consumes `perm`, since it will no longer be safe to access"]
            #[doc = " that memory location."]
            #[inline(always)]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn dispose(&self, #[proof] perm: PermData<V>) {
                ::builtin::requires([::builtin::equal(self.id(),
                                                      perm.view().pptr),
                                     ::builtin::equal(perm.view().value,
                                                      option::Option::None)]);
                opens_invariants_none();
                unsafe {
                    alloc::alloc::dealloc(self.uptr as *mut u8,
                                          alloc::alloc::Layout::for_value(&*self.uptr));
                }
            }
            /// Free the memory pointed to be `perm` and return the 
            /// value that was previously there.
            /// Requires the memory to be initialized.
            /// This consumes the [`PermData`] token, since the user is giving up
            /// access to the memory by freeing it.
            #[inline(always)]
            pub fn into_inner(self, #[proof] perm: PermData<V>) -> V {
                requires([equal(self.id(), perm.view().pptr),
                          perm.view().value.is_Some()]);
                ensures(|v: V| [equal(v, perm.view().value.get_Some_0())]);
                opens_invariants_none();
                #[proof]
                let mut perm = perm;
                let v = self.take(&mut perm);
                self.dispose(perm);
                v
            }
            #[doc =
              " Allocates heap memory for type `V`, leaving it initialized"]
            #[doc = " with the given value `v`."]
            #[inline(always)]
            #[verifier(verus_macro)]
            pub fn new(v: V) -> (PPtr<V>, Trk<PermData<V>>) {
                ::builtin::ensures(|pt: (PPtr<V>, Trk<PermData<V>>)|
                                       [(::builtin::equal(pt.1.0.view(),
                                                          PermDataData{pptr:
                                                                           pt.0.id(),
                                                                       value:
                                                                           option::Option::Some(v),}))]);
                let (p, Trk(mut t)) = Self::empty();
                p.put(&mut t, v);
                (p, Trk(t))
            }
        }
        impl <V: Copy> PPtr<V> {
            #[inline(always)]
            pub fn read(&self, #[proof] perm: &PermData<V>) -> V {
                requires([equal(self.id(), perm.view().pptr),
                          perm.view().value.is_Some()]);
                ensures(|v: V|
                            equal(option::Option::Some(v),
                                  perm.view().value));
                *self.borrow(perm)
            }
            #[inline(always)]
            #[exec]
            pub fn write(&self, #[proof] perm: &mut PermData<V>, v: V) {
                requires(equal(self.id(), old(perm).view().pptr));
                ensures([equal(perm.view().pptr, self.id()),
                         equal(perm.view().value, option::Option::Some(v))]);
                perm.leak_contents();
                self.put(perm, v);
            }
            #[inline(always)]
            pub fn free(&self, #[proof] perm: PermData<V>) {
                requires(equal(self.id(), perm.view().pptr));
                #[proof]
                let mut perm = perm;
                perm.leak_contents();
                self.dispose(perm);
            }
        }
    }
    #[cfg(not(feature = "no_global_allocator"))]
    pub mod string {
        #![feature(rustc_attrs)]
        extern crate alloc;
        use alloc::string;
        #[allow(unused_imports)]
        use super::seq::Seq;
        use super::vec::Vec;
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::verus;
        #[verifier(external_body)]
        pub struct String {
            inner: string::String,
        }
        #[rustc_diagnostic_item = "pervasive::string::StrSlice"]
        #[verifier(external_body)]
        pub struct StrSlice<'a> {
            inner: &'a str,
        }
        #[rustc_diagnostic_item = "pervasive::string::new_strlit"]
        #[verifier(external_body)]
        #[verifier(verus_macro)]
        pub const fn new_strlit<'a>(s: &'a str) -> StrSlice<'a> {
            StrSlice{inner: s,}
        }
        impl <'a> StrSlice<'a> {
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn view(&self) -> Seq<char> {
                ::core::panicking::panic("not implemented")
            }
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn is_ascii(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[doc = " The len() function in rust returns the byte length."]
            #[doc =
              " It is more useful to talk about the length of characters and therefore this function was added."]
            #[doc =
              " Please note that this function counts the unicode variation selectors as characters."]
            #[doc = " Warning: O(n)"]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn unicode_len(&self) -> usize {
                ::builtin::ensures(|l: usize|
                                       [::builtin::equal(::builtin::spec_cast_integer::<_,
                                                                                        nat>(l),
                                                         (self.view()).len())]);
                self.inner.chars().count()
            }
            #[doc = " Warning: O(n) not O(1) due to unicode decoding needed"]
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn get_char(&self, i: usize) -> char {
                ::builtin::requires([(i).spec_lt((self.view()).len())]);
                ::builtin::ensures(|c: char|
                                       [::builtin::equal((self.view()).index(::builtin::spec_cast_integer::<_,
                                                                                                            int>(i)),
                                                         c),
                                        ::builtin::imply(self.is_ascii(),
                                                         ::builtin::forall(|i:
                                                                                int|
                                                                               ::builtin::imply((i).spec_lt((self.view()).len()),
                                                                                                ((::builtin::spec_cast_integer::<_,
                                                                                                                                 nat>((self.view()).index(i)))).spec_lt(::builtin::spec_literal_nat("256")))))]);
                self.inner.chars().nth(i).unwrap()
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn substring_ascii(&self, from: usize, to: usize)
             -> StrSlice<'a> {
                ::builtin::requires([self.is_ascii(),
                                     (from).spec_lt((self.view()).len()),
                                     (to).spec_le((self.view()).len())]);
                ::builtin::ensures(|ret: StrSlice<'a>|
                                       [::builtin::equal((ret.view()),
                                                         (self.view()).subrange(::builtin::spec_cast_integer::<_,
                                                                                                               int>(from),
                                                                                ::builtin::spec_cast_integer::<_,
                                                                                                               int>(to))),
                                        ::builtin::equal(ret.is_ascii(),
                                                         self.is_ascii())]);
                StrSlice{inner: &self.inner[from..to],}
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn substring_char(&self, from: usize, to: usize)
             -> StrSlice<'a> {
                ::builtin::requires([(from).spec_lt((self.view()).len()),
                                     (to).spec_le((self.view()).len())]);
                ::builtin::ensures(|ret: StrSlice<'a>|
                                       [::builtin::equal((ret.view()),
                                                         (self.view()).subrange(::builtin::spec_cast_integer::<_,
                                                                                                               int>(from),
                                                                                ::builtin::spec_cast_integer::<_,
                                                                                                               int>(to))),
                                        ::builtin::equal(ret.is_ascii(),
                                                         self.is_ascii())]);
                let mut char_pos = 0;
                let mut byte_start = None;
                let mut byte_end = None;
                let mut byte_pos = 0;
                let mut it = self.inner.chars();
                loop {
                    if char_pos == from { byte_start = Some(byte_pos); }
                    if char_pos == to { byte_end = Some(byte_pos); break ; }
                    if let Some(c) = it.next() {
                        char_pos += 1;
                        byte_pos += c.len_utf8();
                    } else { break ; }
                }
                let byte_start = byte_start.unwrap();
                let byte_end = byte_end.unwrap();
                StrSlice{inner: &self.inner[byte_start..byte_end],}
            }
            #[verifier(verus_macro)]
            pub fn to_string(self) -> String {
                ::builtin::ensures(|ret: String|
                                       [::builtin::equal((self.view()),
                                                         (ret.view())),
                                        ::builtin::equal(self.is_ascii(),
                                                         ret.is_ascii())]);
                String::from_str(self)
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn get_ascii(&self, i: usize) -> u8 {
                ::builtin::requires([self.is_ascii()]);
                ::builtin::ensures(|b: u8|
                                       [::builtin::equal(::builtin::spec_cast_integer::<_,
                                                                                        u8>(self.view().index(::builtin::spec_cast_integer::<_,
                                                                                                                                             int>(i))),
                                                         b)]);
                self.inner.as_bytes()[i]
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn as_bytes(&self) -> Vec<u8> {
                ::builtin::requires([self.is_ascii()]);
                ::builtin::ensures(|ret: Vec<u8>|
                                       [::builtin::equal(ret.view(),
                                                         Seq::new(self.view().len(),
                                                                  ::builtin::closure_to_fn_spec(|i|
                                                                                                    ::builtin::spec_cast_integer::<_,
                                                                                                                                   u8>(self.view().index(i)))))]);
                let mut v = Vec::new();
                for c in self.inner.as_bytes().iter() { v.push(*c); }
                v
            }
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_str_literal_is_ascii<'a>(s: StrSlice<'a>) {
            ::builtin::ensures([::builtin::equal(#[trigger] s.is_ascii(),
                                                 builtin::strslice_is_ascii(s))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_str_literal_len<'a>(s: StrSlice<'a>) {
            ::builtin::ensures([::builtin::equal(#[trigger] (s.view()).len(),
                                                 builtin::strslice_len(s))]);
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_str_literal_get_char<'a>(s: StrSlice<'a>, i: int) {
            ::builtin::ensures([::builtin::equal(#[trigger] (s.view()).index(i),
                                                 builtin::strslice_get_char(s,
                                                                            i))]);
        }
        impl String {
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn view(&self) -> Seq<char> {
                ::core::panicking::panic("not implemented")
            }
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn is_ascii(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn from_str<'a>(s: StrSlice<'a>) -> String {
                ::builtin::ensures(|ret: String|
                                       [::builtin::equal((s.view()),
                                                         (ret.view())),
                                        ::builtin::equal(s.is_ascii(),
                                                         ret.is_ascii())]);
                String{inner: s.inner.to_string(),}
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn as_str<'a>(&'a self) -> StrSlice<'a> {
                ::builtin::ensures(|ret: StrSlice<'a>|
                                       [::builtin::equal((self.view()),
                                                         (ret.view())),
                                        ::builtin::equal(self.is_ascii(),
                                                         ret.is_ascii())]);
                let inner = self.inner.as_str();
                StrSlice{inner,}
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn append<'a, 'b>(&'a mut self, other: StrSlice<'b>) {
                ::builtin::ensures([::builtin::equal((self.view()),
                                                     ((old(self).view())).spec_add((other.view()))),
                                    ::builtin::equal(self.is_ascii(),
                                                     old(self).is_ascii()) &&
                                        other.is_ascii()]);
                self.inner += other.inner;
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn concat<'b>(self, other: StrSlice<'b>) -> String {
                ::builtin::ensures(|ret: String|
                                       [::builtin::equal((ret.view()),
                                                         ((self.view())).spec_add((other.view()))),
                                        ::builtin::equal(ret.is_ascii(),
                                                         self.is_ascii()) &&
                                            other.is_ascii()]);
                String{inner: self.inner + other.inner,}
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn eq(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                                       [::builtin::spec_eq(b,
                                                           (::builtin::equal(self.view(),
                                                                             other.view())))]);
                self.inner == other.inner
            }
        }
    }
    #[cfg(not(feature = "no_global_allocator"))]
    pub mod vec {
        #[allow(unused_imports)]
        use builtin::*;
        #[allow(unused_imports)]
        use builtin_macros::*;
        #[allow(unused_imports)]
        use crate::pervasive::*;
        #[allow(unused_imports)]
        use crate::pervasive::seq::*;
        extern crate alloc;
        use alloc::vec;
        #[allow(unused_imports)]
        use crate::pervasive::slice::*;
        #[verifier(external_body)]
        pub struct Vec<#[verifier(strictly_positive)] A> {
            pub vec: vec::Vec<A>,
        }
        impl <A> Vec<A> {
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn view(&self) -> Seq<A> {
                ::core::panicking::panic("not implemented")
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn new() -> Self {
                ::builtin::ensures(|v: Self|
                                       [::builtin::equal((v.view()),
                                                         Seq::empty())]);
                Vec{vec: vec::Vec::new(),}
            }
            #[verifier(verus_macro)]
            pub fn empty() -> Self {
                ::builtin::ensures(|v: Self|
                                       [::builtin::equal((v.view()),
                                                         Seq::empty())]);
                Vec::new()
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn push(&mut self, value: A) {
                ::builtin::ensures([::builtin::equal((self.view()),
                                                     (old(self).view()).push(value))]);
                self.vec.push(value);
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn pop(&mut self) -> A {
                ::builtin::requires([(old(self).len()).spec_gt(::builtin::spec_literal_nat("0"))]);
                ::builtin::ensures(|value: A|
                                       [::builtin::equal(value,
                                                         old(self).spec_index((old(self).len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                        ::builtin::equal((self.view()),
                                                         (old(self).view()).subrange(::builtin::spec_literal_integer("0"),
                                                                                     (old(self).len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                unsafe { self.vec.pop().unwrap_unchecked() }
            }
            #[verifier(inline)]
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn spec_index(self, i: int) -> A {
                (self.view()).spec_index(i)
            }
            #[verifier(external_body)]
            #[verifier(autoview)]
            #[verifier(verus_macro)]
            pub fn index(&self, i: usize) -> &A {
                ::builtin::requires([(i).spec_lt(self.len())]);
                ::builtin::ensures(|r: &A|
                                       [::builtin::equal(*r,
                                                         self.spec_index(::builtin::spec_cast_integer::<_,
                                                                                                        int>(i)))]);
                &self.vec[i]
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn set(&mut self, i: usize, a: A) {
                ::builtin::requires([(i).spec_lt(old(self).len())]);
                ::builtin::ensures([::builtin::equal((self.view()),
                                                     (old(self).view()).update(::builtin::spec_cast_integer::<_,
                                                                                                              int>(i),
                                                                               a))]);
                self.vec[i] = a;
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn swap(&mut self, i: usize, a: &mut A) {
                ::builtin::requires([(i).spec_lt(old(self).len())]);
                ::builtin::ensures([::builtin::equal((self.view()),
                                                     (old(self).view()).update(::builtin::spec_cast_integer::<_,
                                                                                                              int>(i),
                                                                               *old(a))),
                                    ::builtin::equal(*a,
                                                     (old(self).view()).index(::builtin::spec_cast_integer::<_,
                                                                                                             int>(i)))]);
                core::mem::swap(&mut self.vec[i], a);
            }
            #[verifier(verus_macro)]
            #[spec]
            #[verifier(external_body)]
            pub fn spec_len(&self) -> usize {
                ::core::panicking::panic("not implemented")
            }
            #[verifier(external_body)]
            #[verifier(when_used_as_spec(spec_len))]
            #[verifier(autoview)]
            #[verifier(verus_macro)]
            pub fn len(&self) -> usize {
                ::builtin::ensures(|l: usize|
                                       [::builtin::spec_eq(l, self.len())]);
                self.vec.len()
            }
            #[verifier(external_body)]
            #[verifier(verus_macro)]
            pub fn as_slice(&self) -> &[A] {
                ::builtin::ensures(|slice: &[A]|
                                       [::builtin::equal((slice.view()),
                                                         (self.view()))]);
                self.vec.as_slice()
            }
        }
        #[verifier(external_body)]
        #[verifier(broadcast_forall)]
        #[verifier(verus_macro)]
        #[proof]
        pub fn axiom_spec_len<A>(v: Vec<A>) {
            ::builtin::ensures([::builtin::spec_eq(#[trigger] v.spec_len(),
                                                   v.view().len())]);
        }
    }
    #[allow(unused_imports)]
    use builtin::*;
    #[allow(unused_imports)]
    use builtin_macros::*;
    #[verifier(verus_macro)]
    #[proof]
    pub fn assume(b: bool) { ::builtin::ensures([b]); admit(); }
    #[verifier(custom_req_err("assertion failure"))]
    #[verifier(verus_macro)]
    #[proof]
    pub fn assert(b: bool) {
        ::builtin::requires([b]);
        ::builtin::ensures([b]);
    }
    #[verifier(verus_macro)]
    #[proof]
    pub fn affirm(b: bool) { ::builtin::requires([b]); }
    #[verifier(custom_req_err("Call to non-static function fails to satisfy `callee.requires(args)`"))]
    #[doc(hidden)]
    #[verifier(external_body)]
    #[verifier(verus_macro)]
    fn exec_nonstatic_call<Args, Output, F>(f: F, args: Args) -> Output where
     F: FnOnce<Args, Output = Output> {
        ::builtin::requires([f.requires(args)]);
        ::builtin::ensures(|output: Output| [f.ensures(args, output)]);
        ::core::panicking::panic("not implemented");
    }
    #[doc =
      " A tool to check one\'s reasoning while writing complex spec functions."]
    #[doc =
      " Not intended to be used as a mechanism for instantiating quantifiers, `spec_affirm` should"]
    #[doc = " be removed from spec functions once they are complete."]
    #[doc = ""]
    #[doc = " ## Example"]
    #[doc = ""]
    #[doc = " ```rust"]
    #[doc = " #[spec(checked)] fn some_predicate(a: nat) -> bool {"]
    #[doc = "     recommends(a < 100);"]
    #[doc = "     if (a >= 50) {"]
    #[doc = "         let _ = spec_affirm(50 <= a && a < 100);"]
    #[doc = "         a >= 75"]
    #[doc = "     } else {"]
    #[doc = "         let _ = spec_affirm(a < 50);"]
    #[doc =
      "         // let _ = spec_affirm(a < 40); would raise a recommends note here"]
    #[doc = "         a < 25"]
    #[doc = "     }"]
    #[doc = " }"]
    #[doc = " ```"]
    #[verifier(verus_macro)]
    #[spec]
    pub fn spec_affirm(b: bool) -> bool { ::builtin::recommends([b]); b }
    #[doc = " In spec, all types are inhabited"]
    #[verifier(external_body)]
    #[allow(dead_code)]
    #[verifier(verus_macro)]
    #[spec]
    pub fn arbitrary<A>() -> A { ::core::panicking::panic("not implemented") }
    #[verifier(external_body)]
    #[allow(dead_code)]
    #[verifier(verus_macro)]
    #[verifier(returns(proof))]
    #[proof]
    pub fn proof_from_false<A>() -> A {
        requires(false);
        ::core::panicking::panic("not implemented")
    }
    #[verifier(external_body)]
    #[allow(dead_code)]
    #[verifier(verus_macro)]
    pub fn unreached<A>() -> A {
        ::builtin::requires([false]);
        { ::std::rt::begin_panic("unreached_external") }
    }
    #[verifier(external_body)]
    #[verifier(verus_macro)]
    pub fn print_u64(i: u64) {
        {
            ::std::io::_print(::core::fmt::Arguments::new_v1(&["", "\n"],
                                                             &match (&i,) {
                                                                  _args =>
                                                                  [::core::fmt::ArgumentV1::new(_args.0,
                                                                                                ::core::fmt::Display::fmt)],
                                                              }));
        };
    }
    /// Allows you to prove a boolean predicate by assuming its negation and proving
    /// a contradiction.
    ///
    /// `assert_by_contradiction!(b, { /* proof */ });`
    /// Equivalent to writing `if !b { /* proof */; assert(false); }`
    /// but is more concise and documents intent.
    ///
    /// ```rust
    /// assert_by_contradiction!(b, {
    ///     // assume !b here
    ///     // prove `false`
    /// });
    /// ```
    #[macro_export]
    macro_rules! assert_by_contradiction {
        ($($a : tt) *) =>
        {
            verus_proof_macro_exprs!
            (assert_by_contradiction_internal! ($($a) *))
        }
    }
    #[doc(hidden)]
    #[macro_export]
    macro_rules! assert_by_contradiction_internal {
        ($predicate : expr, $bblock : block) =>
        {
            :: builtin ::
            assert_by($predicate,
                      {
                          if! $predicate
                          { $bblock crate :: pervasive :: assert(false) ; }
                      }) ;
        }
    }
    /// Macro to help set up boilerplate for specifying invariants when using
    /// invariant-based datatypes.
    ///
    /// This currently supports the `AtomicInvariant` and `LocalInvariant`
    /// types, as well as all the `atomic_ghost` types (e.g., `AtomicU64`, `AtomicBool`, and so on).
    /// It is important to first understand how these types work.
    /// In particular, `LocalInvariant` (for example) takes three type parameters,
    /// `K`, `V`, and `Pred: InvariantPredicate`.
    /// The `InvariantPredicate` trait lets the user specify an invariant at the static type
    /// level, while `K` allows the user to configure the invariant upon construction.
    /// `AtomicInvariant` uses the same system, and the `atomic_ghost` types are similar
    /// but use a different trait (`AtomicInvariantPredicate`).
    ///
    /// However, setting all this up in a typical application tends to involve a bit
    /// of boilerplate. That's where this macro comes in.
    ///
    /// # Usage
    ///
    /// The `struct_with_invariants!` macro is used at the item level, and it should contains
    /// a single struct declaration followed by a single declaration of a `spec` function
    /// returning `bool`. However, this spec function should not contain a boolean predicate
    /// as usual, but instead a series of _invariant declarations_.
    /// Each invariant declaration applies to a single field of the struct.
    ///
    /// ```rust
    /// struct_with_invariants!{
    ///     (pub)? struct $struct_name (<...>)? (where ...)? {
    ///         ( (pub)? $field_name: $type, )*
    ///     }
    /// 
    ///     (pub)? (open|closed)? spec fn(&self (, ...)?) $fn_name {
    ///         ( InvariantDecl | BoolPredicateDecl )*
    ///     }
    /// }
    /// ```
    ///
    /// A field of the struct, if it uses a supported type, may leave the type _incomplete_ by
    /// omitting some of its type parameters.
    /// The following are valid incomplete types:
    ///
    ///  * `LocalInvariant<_, V, _>`
    ///  * `AtomicInvariant<_, V, _>`
    ///  * `AtomicBool<_, G, _>`
    ///  * `AtomicU64<_, G, _>`
    ///    * ... and so on for the other `atomic_ghost` types.
    ///
    /// There must be exactly one invariant declaration for each incomplete type used in the
    /// struct declaration. The macro uses invariant declarations to fill in the type parameters.
    ///
    /// The user can also provide boolean predicate declarations, which are copied verbatim
    /// into the `$fn_name` definition. This is a convenience, since it is common to want
    /// to add extra conditions, and it is fairly straightforward.
    /// The complex part of the macro expansion in the invariant declarations.
    ///
    /// ```rust
    /// BoolPredicateDecl  :=  predicate { $bool_expr }
    /// 
    /// InvariantDecl  :=
    ///     invariant on $field_name
    ///         ( with ($dependencies) )?
    ///         ( forall | ($ident: $type, )* | )?
    ///         ( where ($where_expr) )?
    ///         ( specifically ($specifically_expr) )?
    ///         is ($params) {
    ///             $bool_expr
    ///         }
    /// ```
    ///
    /// In the `InvariantDecl`, the user always needs to provide the following data:
    ///
    ///  * The `$field_name` is the field that this invariant applies to
    ///     (which must have an incomplete type as described above)
    ///  * The `$params` are the values constrained by the invariant.
    ///      * For a `LocalInvariant<V>` or `AtomicInvariant<V>`, this should be a single
    ///        parameter of type `V`.
    ///      * For an `atomic_ghost` type, this should consist of two parameters,
    ///        first the primitive type stored by the atomic, and secondly one of the ghost type, `G`.
    ///        (For example, the type `AtomicBool<_, G, _>` should have two parameters
    ///        here, `b: bool, g: G`.)
    ///  * Finally, the `$bool_expr` is the invariant predicate, which may reference any of
    ///     the fields declared in `$dependencies`, or any of the params.
    ///
    /// The other input clauses handle additional complexities that often comes up.
    /// For example, it is often necessary for the invariant to refer to the values of other fields
    /// in the struct.
    ///
    ///  * The `with` input gives the list of field names (other fields
    ///     from the struct definition) that may be referenced from
    ///     the body of this invariant.
    ///     The graph of dependencies across all fields must be acyclic.
    ///
    /// Finally, when the field is a _container_ type, e.g., `vec: Vec<AtomicU64<_, G, _>>` or
    /// `opt: Option<AtomicU64<_, G, _>>`, there are some additional complexities.
    /// We might need the invariant to be conditional (e.g., for an optional, the invariant would only
    /// exist if `opt.is_Some()`).
    /// We might need to quantify over a variable (e.g., in a vector, we want to specify an invariant
    /// for each element, element `i` where `0 <= i < vec.len()`).
    /// Finally, we need to indicate the value actually getting the invariant (e.g., `self.vec[i]`).
    ///
    /// * The `forall` lets you specify additional bound variables. Everything after the `forall`---the
    ///   `where`, the `specifically`, and finally the `$bool_expr$`---can all reference these bound variables.
    /// * The `where` lets you specify an additional hypothesis that the invariant is dependent on.
    /// * The `specifically` lets you indicate the value getting the invariant.
    ///
    /// This all roughly means, "forall instantiations of the quantified variables, if the condition `$where_expr` holds,
    /// then the value given by `$specifically_expr` has the invariant given by `$bool_expr`.
    /// See the detailed information on the macro-expansion below for more details.
    ///
    /// Given all the information from the `InvariantDecl`, the macro fills in the `_` placeholders as follows:
    ///
    ///  * The macro fills in the `K` type as the types of the fields marked as dependencies and
    ///    the quantified variables in the forall (packing all these types into a tuple if necessary).
    ///  * The macro fills in the `Pred` type by creating a new type and implementing the appropriate
    ///    trait with the user-provided predicate.
    ///
    /// # Example (TODO)
    ///
    /// # Example using a container type (TODO)
    ///
    /// # Macro Expansion (TODO)
    pub use builtin_macros::struct_with_invariants;
}
mod spec {
    pub mod Option_t {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        pub enum Option<T> { None, Some(T), }
        #[automatically_derived]
        impl <T> Option<T> {
            #[spec]
            #[verifier(is_variant("None"))]
            #[allow(non_snake_case)]
            pub fn is_None(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[verifier(is_variant("Some"))]
            #[allow(non_snake_case)]
            pub fn is_Some(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant("Some", 0))]
            pub fn get_Some_0(self) -> T {
                ::core::panicking::panic("not implemented")
            }
        }
    }
    pub mod FloatingSeq_t {
        #![allow(unused_imports)]
        use builtin_macros::*;
        use builtin::*;
        use crate::pervasive::{*, seq::*};
        pub struct FloatingSeq<T> {
            pub start: nat,
            pub entries: Seq<T>,
        }
        impl <T> FloatingSeq<T> {
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn len(self) -> int {
                (::builtin::spec_cast_integer::<_,
                                                int>(self.start)).spec_add(self.entries.len())
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn first_active_index(self) -> int {
                ::builtin::spec_cast_integer::<_, int>(self.start)
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn is_active(self, i: int) -> bool {
                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(self.start),
                                                                                                  i),
                                                                       self.len()))
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn get(self, i: int) -> T {
                ::builtin::recommends([self.is_active(i)]);
                self.entries.spec_index((i).spec_sub(::builtin::spec_cast_integer::<_,
                                                                                    int>(self.start)))
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn spec_index(self, i: int) -> T {
                ::builtin::recommends([self.is_active(i)]);
                self.entries.spec_index((i).spec_sub(self.start))
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn get_prefix(self, count: int) -> FloatingSeq<T> {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                         count),
                                                                                              self.len()))]);
                if (count).spec_le(self.start) {
                    FloatingSeq{start:
                                    ::builtin::spec_cast_integer::<_,
                                                                   nat>(count),
                                entries: Seq::empty(),}
                } else {
                    FloatingSeq{start: self.start,
                                entries:
                                    self.entries.subrange(::builtin::spec_literal_integer("0"),
                                                          (count).spec_sub(self.start)),}
                }
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn get_suffix(self, newStart: int) -> FloatingSeq<T> {
                ::builtin::recommends([self.is_active(newStart) ||
                                           ::builtin::spec_eq(newStart,
                                                              self.len())]);
                FloatingSeq{start:
                                ::builtin::spec_cast_integer::<_,
                                                               nat>(newStart),
                            entries:
                                self.entries.subrange((newStart).spec_sub(self.start),
                                                      ::builtin::spec_cast_integer::<_,
                                                                                     int>(self.entries.len())),}
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn append(self, elts: Seq<T>) -> FloatingSeq<T> {
                FloatingSeq{start: self.start,
                            entries: (self.entries).spec_add(elts),}
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn last(self) -> T {
                ::builtin::recommends([(self.len()).spec_gt(::builtin::spec_literal_nat("0")),
                                       self.is_active((self.len()).spec_sub(::builtin::spec_literal_nat("1")))]);
                self.spec_index((self.len()).spec_sub(::builtin::spec_literal_nat("1")))
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn drop_last(self) -> FloatingSeq<T> {
                ::builtin::recommends([(self.len()).spec_gt(::builtin::spec_literal_nat("0"))]);
                self.get_prefix((self.len()).spec_sub(::builtin::spec_literal_nat("1")))
            }
            #[verifier(verus_macro)]
            #[proof]
            fn extensionality(self, b: FloatingSeq<T>) {
                ::builtin::requires([::builtin::spec_eq(self.start, b.start),
                                     ::builtin::equal(self.len(), b.len()),
                                     ::builtin::forall(|i|
                                                           ::builtin::imply(self.is_active(i),
                                                                            ::builtin::equal(self.spec_index(i),
                                                                                             b.spec_index(i))))]);
                ::builtin::ensures([::builtin::equal(self, b)]);
                {
                    ::builtin::assert_forall_by(|i|
                                                    {
                                                        ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                                                              i),
                                                                                                                                   self.entries.len())));
                                                        ::builtin::ensures(::builtin::equal(self.entries.spec_index(i),
                                                                                            b.entries.spec_index(i)));
                                                        ::builtin::assert_(::builtin::equal(b.spec_index(((self.start).spec_add(i))),
                                                                                            b.entries.spec_index(i)));
                                                    });
                }
                ::builtin::assert_(self.entries.ext_equal(b.entries));
            }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn floating_seq<T>(start: nat, length: nat,
                               f: ::builtin::FnSpec<(int,), T>)
         -> FloatingSeq<T> {
            ::builtin::recommends([(start).spec_le(length)]);
            FloatingSeq{start: start,
                        entries:
                            Seq::new(::builtin::spec_cast_integer::<_,
                                                                    nat>(((length).spec_sub(start))),
                                     ::builtin::closure_to_fn_spec(|i: int|
                                                                       f((i).spec_add(start)))),}
        }
    }
    pub mod MapSpec_t {
        #![allow(unused_imports)]
        use builtin_macros::*;
        use builtin::*;
        use crate::pervasive::{*, map::*, set::*};
        use crate::spec::Messages_t::*;
        use crate::spec::FloatingSeq_t::*;
        use crate::spec::TotalKMMap_t::*;
        use state_machines_macros::state_machine;
        pub enum Input {
            GetInput {
                key: Key,
            },
            PutInput {
                key: Key,
                value: Value,
            },
            NoopInput,
        }
        #[automatically_derived]
        impl Input {
            #[spec]
            #[verifier(is_variant("GetInput"))]
            #[allow(non_snake_case)]
            pub fn is_GetInput(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant(GetInput, key))]
            pub fn get_GetInput_key(self) -> Key {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[verifier(is_variant("PutInput"))]
            #[allow(non_snake_case)]
            pub fn is_PutInput(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant(PutInput, key))]
            pub fn get_PutInput_key(self) -> Key {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant(PutInput, value))]
            pub fn get_PutInput_value(self) -> Value {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[verifier(is_variant("NoopInput"))]
            #[allow(non_snake_case)]
            pub fn is_NoopInput(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
        }
        pub enum Output {
            GetOutput {
                value: Value,
            },
            PutOutput,
            NoopOutput,
        }
        #[automatically_derived]
        impl Output {
            #[spec]
            #[verifier(is_variant("GetOutput"))]
            #[allow(non_snake_case)]
            pub fn is_GetOutput(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant(GetOutput, value))]
            pub fn get_GetOutput_value(self) -> Value {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[verifier(is_variant("PutOutput"))]
            #[allow(non_snake_case)]
            pub fn is_PutOutput(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[verifier(is_variant("NoopOutput"))]
            #[allow(non_snake_case)]
            pub fn is_NoopOutput(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
        }
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn my_init() -> MapSpec::State {
            MapSpec::State{kmmap: empty_total_map(),}
        }
        #[allow(unused_parens)]
        pub mod MapSpec {
            use super::*;
            pub struct State {
                pub kmmap: TotalKMMap,
            }
            #[allow(non_camel_case_types)]
            pub enum Step {
                query(Input, Output),
                put(Key, Value),
                dummy_to_use_type_params(State),
            }
            #[allow(non_camel_case_types)]
            pub enum Config { my_init_2(), dummy_to_use_type_params(State), }
            pub mod show {
                use super::*;
                #[verifier(external_body)]
                #[proof]
                pub fn query(pre: super::State, post: super::State,
                             input: Input, output: Output) {
                    ::builtin::requires(super::State::query(pre, post, input,
                                                            output));
                    ::builtin::ensures(super::State::next(pre, post));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn put(pre: super::State, post: super::State, key: Key,
                           value: Value) {
                    ::builtin::requires(super::State::put(pre, post, key,
                                                          value));
                    ::builtin::ensures(super::State::next(pre, post));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn my_init_2(post: super::State) {
                    ::builtin::requires(super::State::my_init_2(post));
                    ::builtin::ensures(super::State::init(post));
                }
            }
            impl State {
                #[spec]
                #[verifier(publish)]
                pub fn my_init_2(post: Self) -> ::core::primitive::bool {
                    {
                        let update_tmp_kmmap: TotalKMMap = my_init().kmmap;
                        (::builtin::equal(post.kmmap, update_tmp_kmmap))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn query(pre: Self, post: Self, input: Input,
                             output: Output) -> ::core::primitive::bool {
                    {
                        let update_tmp_kmmap: TotalKMMap = pre.kmmap;
                        ((input.is_GetInput()) &&
                             ((output.is_GetOutput()) &&
                                  ({
                                       let tmp_for_match_0 = input;
                                       ((match tmp_for_match_0 {
                                             Input::GetInput { key } => true,
                                             _ => false,
                                         }) &&
                                            {
                                                let key =
                                                    match tmp_for_match_0 {
                                                        Input::GetInput { key
                                                        } => key,
                                                        _ =>
                                                        crate::pervasive::arbitrary(),
                                                    };
                                                let tmp_for_match_1 = output;
                                                ((match tmp_for_match_1 {
                                                      Output::GetOutput {
                                                      value } => true,
                                                      _ => false,
                                                  }) &&
                                                     {
                                                         let value =
                                                             match tmp_for_match_1
                                                                 {
                                                                 Output::GetOutput {
                                                                 value } =>
                                                                 value,
                                                                 _ =>
                                                                 crate::pervasive::arbitrary(),
                                                             };
                                                         (::builtin::equal(pre.kmmap.spec_index(key).get_Define_value(),
                                                                           value))
                                                     })
                                            })
                                   } &&
                                       (::builtin::equal(post.kmmap,
                                                         update_tmp_kmmap)))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn query_strong(pre: Self, post: Self, input: Input,
                                    output: Output)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_kmmap: TotalKMMap = pre.kmmap;
                        ((input.is_GetInput()) &&
                             ((output.is_GetOutput()) &&
                                  ({
                                       let tmp_for_match_0 = input;
                                       ((match tmp_for_match_0 {
                                             Input::GetInput { key } => true,
                                             _ => false,
                                         }) &&
                                            {
                                                let key =
                                                    match tmp_for_match_0 {
                                                        Input::GetInput { key
                                                        } => key,
                                                        _ =>
                                                        crate::pervasive::arbitrary(),
                                                    };
                                                let tmp_for_match_1 = output;
                                                ((match tmp_for_match_1 {
                                                      Output::GetOutput {
                                                      value } => true,
                                                      _ => false,
                                                  }) &&
                                                     {
                                                         let value =
                                                             match tmp_for_match_1
                                                                 {
                                                                 Output::GetOutput {
                                                                 value } =>
                                                                 value,
                                                                 _ =>
                                                                 crate::pervasive::arbitrary(),
                                                             };
                                                         (::builtin::equal(pre.kmmap.spec_index(key).get_Define_value(),
                                                                           value))
                                                     })
                                            })
                                   } &&
                                       (::builtin::equal(post.kmmap,
                                                         update_tmp_kmmap)))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn put(pre: Self, post: Self, key: Key, value: Value)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_kmmap: TotalKMMap =
                            pre.kmmap.insert(key, Message::Define{value,});
                        (::builtin::equal(post.kmmap, update_tmp_kmmap))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn put_strong(pre: Self, post: Self, key: Key,
                                  value: Value) -> ::core::primitive::bool {
                    {
                        let update_tmp_kmmap: TotalKMMap =
                            pre.kmmap.insert(key, Message::Define{value,});
                        (::builtin::equal(post.kmmap, update_tmp_kmmap))
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_by(pre: State, post: State, step: Step)
                 -> ::core::primitive::bool {
                    match step {
                        Step::query(input, output) =>
                        Self::query(pre, post, input, output),
                        Step::put(key, value) =>
                        Self::put(pre, post, key, value),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next(pre: State, post: State)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong_by(pre: State, post: State, step: Step)
                 -> ::core::primitive::bool {
                    match step {
                        Step::query(input, output) =>
                        Self::query_strong(pre, post, input, output),
                        Step::put(key, value) =>
                        Self::put_strong(pre, post, key, value),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong(pre: State, post: State)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init_by(post: State, step: Config)
                 -> ::core::primitive::bool {
                    match step {
                        Config::my_init_2() => Self::my_init_2(post),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config|
                                          Self::init_by(post, step))
                }
                #[spec]
                #[verifier(publish)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
            }
        }
        type ID = int;
        pub struct Request {
            pub input: Input,
            pub id: ID,
        }
        pub struct Reply {
            pub output: Output,
            pub id: ID,
        }
        pub struct PersistentState {
            pub appv: MapSpec::State,
        }
        pub struct EphemeralState {
            pub requests: Set<Request>,
            pub replies: Set<Reply>,
        }
        pub enum AsyncUILabel {
            RequestOp {
                req: Request,
            },
            ExecuteOp {
                req: Request,
                reply: Reply,
            },
            ReplyOp {
                reply: Reply,
            },
        }
        #[automatically_derived]
        impl AsyncUILabel {
            #[spec]
            #[verifier(is_variant("RequestOp"))]
            #[allow(non_snake_case)]
            pub fn is_RequestOp(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant(RequestOp, req))]
            pub fn get_RequestOp_req(self) -> Request {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[verifier(is_variant("ExecuteOp"))]
            #[allow(non_snake_case)]
            pub fn is_ExecuteOp(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant(ExecuteOp, req))]
            pub fn get_ExecuteOp_req(self) -> Request {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant(ExecuteOp, reply))]
            pub fn get_ExecuteOp_reply(self) -> Reply {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[verifier(is_variant("ReplyOp"))]
            #[allow(non_snake_case)]
            pub fn is_ReplyOp(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant(ReplyOp, reply))]
            pub fn get_ReplyOp_reply(self) -> Reply {
                ::core::panicking::panic("not implemented")
            }
        }
        type SyncReqId = nat;
        type Version = PersistentState;
        #[allow(unused_parens)]
        pub mod AsyncMap {
            use super::*;
            pub struct State {
                pub persistent: PersistentState,
                pub ephemeral: EphemeralState,
            }
            #[allow(non_camel_case_types)]
            pub enum Step {
                do_request(Request),
                do_execute(Request, Reply),
                do_reply(Reply),
                dummy_to_use_type_params(State),
            }
            #[allow(non_camel_case_types)]
            pub enum Config { dummy_to_use_type_params(State), }
            pub mod show {
                use super::*;
                #[verifier(external_body)]
                #[proof]
                pub fn do_request(pre: super::State, post: super::State,
                                  req: Request) {
                    ::builtin::requires(super::State::do_request(pre, post,
                                                                 req));
                    ::builtin::ensures(super::State::next(pre, post));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn do_execute(pre: super::State, post: super::State,
                                  req: Request, reply: Reply) {
                    ::builtin::requires(super::State::do_execute(pre, post,
                                                                 req, reply));
                    ::builtin::ensures(super::State::next(pre, post));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn do_reply(pre: super::State, post: super::State,
                                reply: Reply) {
                    ::builtin::requires(super::State::do_reply(pre, post,
                                                               reply));
                    ::builtin::ensures(super::State::next(pre, post));
                }
            }
            impl State {
                #[spec]
                #[verifier(publish)]
                pub fn do_request(pre: Self, post: Self, req: Request)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: PersistentState =
                            pre.persistent;
                        ((!pre.ephemeral.requests.contains(req)) &&
                             {
                                 let update_tmp_ephemeral: EphemeralState =
                                     EphemeralState{requests:
                                                        pre.ephemeral.requests.insert(req),
                                                                                              ..pre.ephemeral};
                                 ((::builtin::equal(post.ephemeral,
                                                    update_tmp_ephemeral)) &&
                                      (::builtin::equal(post.persistent,
                                                        update_tmp_persistent)))
                             })
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn do_request_strong(pre: Self, post: Self, req: Request)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: PersistentState =
                            pre.persistent;
                        ((!pre.ephemeral.requests.contains(req)) &&
                             {
                                 let update_tmp_ephemeral: EphemeralState =
                                     EphemeralState{requests:
                                                        pre.ephemeral.requests.insert(req),
                                                                                              ..pre.ephemeral};
                                 ((::builtin::equal(post.ephemeral,
                                                    update_tmp_ephemeral)) &&
                                      (::builtin::equal(post.persistent,
                                                        update_tmp_persistent)))
                             })
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn do_execute(pre: Self, post: Self, req: Request,
                                  reply: Reply) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: PersistentState =
                            pre.persistent;
                        let update_tmp_ephemeral: EphemeralState =
                            pre.ephemeral;
                        ((::builtin::equal(post.ephemeral,
                                           update_tmp_ephemeral)) &&
                             (::builtin::equal(post.persistent,
                                               update_tmp_persistent)))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn do_execute_strong(pre: Self, post: Self, req: Request,
                                         reply: Reply)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: PersistentState =
                            pre.persistent;
                        let update_tmp_ephemeral: EphemeralState =
                            pre.ephemeral;
                        ((::builtin::equal(post.ephemeral,
                                           update_tmp_ephemeral)) &&
                             (::builtin::equal(post.persistent,
                                               update_tmp_persistent)))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn do_reply(pre: Self, post: Self, reply: Reply)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: PersistentState =
                            pre.persistent;
                        ((pre.ephemeral.replies.contains(reply)) &&
                             {
                                 let update_tmp_ephemeral: EphemeralState =
                                     EphemeralState{replies:
                                                        pre.ephemeral.replies.remove(reply),
                                                                                               ..pre.ephemeral};
                                 ((::builtin::equal(post.ephemeral,
                                                    update_tmp_ephemeral)) &&
                                      (::builtin::equal(post.persistent,
                                                        update_tmp_persistent)))
                             })
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn do_reply_strong(pre: Self, post: Self, reply: Reply)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: PersistentState =
                            pre.persistent;
                        ((pre.ephemeral.replies.contains(reply)) &&
                             {
                                 let update_tmp_ephemeral: EphemeralState =
                                     EphemeralState{replies:
                                                        pre.ephemeral.replies.remove(reply),
                                                                                               ..pre.ephemeral};
                                 ((::builtin::equal(post.ephemeral,
                                                    update_tmp_ephemeral)) &&
                                      (::builtin::equal(post.persistent,
                                                        update_tmp_persistent)))
                             })
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_by(pre: State, post: State, step: Step)
                 -> ::core::primitive::bool {
                    match step {
                        Step::do_request(req) =>
                        Self::do_request(pre, post, req),
                        Step::do_execute(req, reply) =>
                        Self::do_execute(pre, post, req, reply),
                        Step::do_reply(reply) =>
                        Self::do_reply(pre, post, reply),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next(pre: State, post: State)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong_by(pre: State, post: State, step: Step)
                 -> ::core::primitive::bool {
                    match step {
                        Step::do_request(req) =>
                        Self::do_request_strong(pre, post, req),
                        Step::do_execute(req, reply) =>
                        Self::do_execute_strong(pre, post, req, reply),
                        Step::do_reply(reply) =>
                        Self::do_reply_strong(pre, post, reply),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong(pre: State, post: State)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init_by(post: State, step: Config)
                 -> ::core::primitive::bool {
                    match step {
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config|
                                          Self::init_by(post, step))
                }
                #[spec]
                #[verifier(publish)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
                #[verifier(verus_macro)]
                #[verifier(publish)]
                #[spec]
                pub fn init_persistent_state() -> PersistentState {
                    PersistentState{appv: my_init(),}
                }
                #[verifier(verus_macro)]
                #[verifier(publish)]
                #[spec]
                pub fn init_ephemeral_state() -> EphemeralState {
                    EphemeralState{requests: Set::empty(),
                                   replies: Set::empty(),}
                }
            }
        }
        #[allow(unused_parens)]
        pub mod CrashTolerantAsyncMap {
            use super::*;
            pub struct State {
                pub versions: FloatingSeq<Version>,
                pub async_ephemeral: EphemeralState,
                pub sync_requests: Map<SyncReqId, nat>,
            }
            #[allow(non_camel_case_types)]
            pub enum Step {
                operate(AsyncUILabel, FloatingSeq<Version>, EphemeralState,
                        AsyncMap::Step),
                crash(),
                sync(int),
                req_sync(SyncReqId),
                dummy_to_use_type_params(State),
            }
            #[allow(non_camel_case_types)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            pub mod show {
                use super::*;
                #[verifier(external_body)]
                #[proof]
                pub fn operate(pre: super::State, post: super::State,
                               op: AsyncUILabel,
                               new_versions: FloatingSeq<Version>,
                               new_async_ephemeral: EphemeralState,
                               async_step: AsyncMap::Step) {
                    ::builtin::requires(super::State::operate(pre, post, op,
                                                              new_versions,
                                                              new_async_ephemeral,
                                                              async_step));
                    ::builtin::ensures(super::State::next(pre, post));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn crash(pre: super::State, post: super::State) {
                    ::builtin::requires(super::State::crash(pre, post));
                    ::builtin::ensures(super::State::next(pre, post));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn sync(pre: super::State, post: super::State,
                            new_stable_index: int) {
                    ::builtin::requires(super::State::sync(pre, post,
                                                           new_stable_index));
                    ::builtin::ensures(super::State::next(pre, post));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn req_sync(pre: super::State, post: super::State,
                                sync_req_id: SyncReqId) {
                    ::builtin::requires(super::State::req_sync(pre, post,
                                                               sync_req_id));
                    ::builtin::ensures(super::State::next(pre, post));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn initialize(post: super::State) {
                    ::builtin::requires(super::State::initialize(post));
                    ::builtin::ensures(super::State::init(post));
                }
            }
            impl State {
                #[spec]
                #[verifier(publish)]
                pub fn initialize(post: Self) -> ::core::primitive::bool {
                    {
                        let update_tmp_versions: FloatingSeq<Version> =
                            floating_seq(::builtin::spec_literal_integer("0"),
                                         ::builtin::spec_literal_integer("1"),
                                         ::builtin::closure_to_fn_spec(|i|
                                                                           AsyncMap::State::init_persistent_state()));
                        let update_tmp_async_ephemeral: EphemeralState =
                            AsyncMap::State::init_ephemeral_state();
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            Map::empty();
                        ((::builtin::equal(post.sync_requests,
                                           update_tmp_sync_requests)) &&
                             ((::builtin::equal(post.async_ephemeral,
                                                update_tmp_async_ephemeral))
                                  &&
                                  (::builtin::equal(post.versions,
                                                    update_tmp_versions))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn operate(pre: Self, post: Self, op: AsyncUILabel,
                               new_versions: FloatingSeq<Version>,
                               new_async_ephemeral: EphemeralState,
                               async_step: AsyncMap::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            pre.sync_requests;
                        ((State::optionally_append_version(pre.versions,
                                                           new_versions)) &&
                             ((AsyncMap::State::next_by(AsyncMap::State{persistent:
                                                                            pre.versions.last(),
                                                                        ephemeral:
                                                                            pre.async_ephemeral,},
                                                        AsyncMap::State{persistent:
                                                                            new_versions.last(),
                                                                        ephemeral:
                                                                            new_async_ephemeral,},
                                                        async_step)) &&
                                  {
                                      let update_tmp_versions:
                                              FloatingSeq<Version> =
                                          new_versions;
                                      let update_tmp_async_ephemeral:
                                              EphemeralState =
                                          new_async_ephemeral;
                                      ((::builtin::equal(post.async_ephemeral,
                                                         update_tmp_async_ephemeral))
                                           &&
                                           ((::builtin::equal(post.versions,
                                                              update_tmp_versions))
                                                &&
                                                (::builtin::equal(post.sync_requests,
                                                                  update_tmp_sync_requests))))
                                  }))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn operate_strong(pre: Self, post: Self, op: AsyncUILabel,
                                      new_versions: FloatingSeq<Version>,
                                      new_async_ephemeral: EphemeralState,
                                      async_step: AsyncMap::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            pre.sync_requests;
                        ((State::optionally_append_version(pre.versions,
                                                           new_versions)) &&
                             ((AsyncMap::State::next_by(AsyncMap::State{persistent:
                                                                            pre.versions.last(),
                                                                        ephemeral:
                                                                            pre.async_ephemeral,},
                                                        AsyncMap::State{persistent:
                                                                            new_versions.last(),
                                                                        ephemeral:
                                                                            new_async_ephemeral,},
                                                        async_step)) &&
                                  {
                                      let update_tmp_versions:
                                              FloatingSeq<Version> =
                                          new_versions;
                                      let update_tmp_async_ephemeral:
                                              EphemeralState =
                                          new_async_ephemeral;
                                      ((::builtin::equal(post.async_ephemeral,
                                                         update_tmp_async_ephemeral))
                                           &&
                                           ((::builtin::equal(post.versions,
                                                              update_tmp_versions))
                                                &&
                                                (::builtin::equal(post.sync_requests,
                                                                  update_tmp_sync_requests))))
                                  }))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn crash(pre: Self, post: Self)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_versions: FloatingSeq<Version> =
                            pre.versions.get_prefix((pre.stable_index()).spec_add(::builtin::spec_literal_nat("1")));
                        let update_tmp_async_ephemeral: EphemeralState =
                            AsyncMap::State::init_ephemeral_state();
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            Map::empty();
                        ((::builtin::equal(post.sync_requests,
                                           update_tmp_sync_requests)) &&
                             ((::builtin::equal(post.async_ephemeral,
                                                update_tmp_async_ephemeral))
                                  &&
                                  (::builtin::equal(post.versions,
                                                    update_tmp_versions))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn crash_strong(pre: Self, post: Self)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_versions: FloatingSeq<Version> =
                            pre.versions.get_prefix((pre.stable_index()).spec_add(::builtin::spec_literal_nat("1")));
                        let update_tmp_async_ephemeral: EphemeralState =
                            AsyncMap::State::init_ephemeral_state();
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            Map::empty();
                        ((::builtin::equal(post.sync_requests,
                                           update_tmp_sync_requests)) &&
                             ((::builtin::equal(post.async_ephemeral,
                                                update_tmp_async_ephemeral))
                                  &&
                                  (::builtin::equal(post.versions,
                                                    update_tmp_versions))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn sync(pre: Self, post: Self, new_stable_index: int)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_async_ephemeral: EphemeralState =
                            pre.async_ephemeral;
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            pre.sync_requests;
                        ((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(pre.stable_index()),
                                                                                                            new_stable_index),
                                                                                 pre.versions.len())))
                             &&
                             {
                                 let update_tmp_versions:
                                         FloatingSeq<Version> =
                                     pre.versions.get_suffix(new_stable_index);
                                 ((::builtin::equal(post.versions,
                                                    update_tmp_versions)) &&
                                      ((::builtin::equal(post.sync_requests,
                                                         update_tmp_sync_requests))
                                           &&
                                           (::builtin::equal(post.async_ephemeral,
                                                             update_tmp_async_ephemeral))))
                             })
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn sync_strong(pre: Self, post: Self,
                                   new_stable_index: int)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_async_ephemeral: EphemeralState =
                            pre.async_ephemeral;
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            pre.sync_requests;
                        ((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(pre.stable_index()),
                                                                                                            new_stable_index),
                                                                                 pre.versions.len())))
                             &&
                             {
                                 let update_tmp_versions:
                                         FloatingSeq<Version> =
                                     pre.versions.get_suffix(new_stable_index);
                                 ((::builtin::equal(post.versions,
                                                    update_tmp_versions)) &&
                                      ((::builtin::equal(post.sync_requests,
                                                         update_tmp_sync_requests))
                                           &&
                                           (::builtin::equal(post.async_ephemeral,
                                                             update_tmp_async_ephemeral))))
                             })
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn req_sync(pre: Self, post: Self, sync_req_id: SyncReqId)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_versions: FloatingSeq<Version> =
                            pre.versions;
                        let update_tmp_async_ephemeral: EphemeralState =
                            pre.async_ephemeral;
                        ((pre.sync_requests.dom().contains(sync_req_id)) &&
                             (((pre.sync_requests.spec_index(sync_req_id)).spec_le(pre.stable_index()))
                                  &&
                                  {
                                      let update_tmp_sync_requests:
                                              Map<SyncReqId, nat> =
                                          pre.sync_requests.remove(sync_req_id);
                                      ((::builtin::equal(post.sync_requests,
                                                         update_tmp_sync_requests))
                                           &&
                                           ((::builtin::equal(post.async_ephemeral,
                                                              update_tmp_async_ephemeral))
                                                &&
                                                (::builtin::equal(post.versions,
                                                                  update_tmp_versions))))
                                  }))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn req_sync_strong(pre: Self, post: Self,
                                       sync_req_id: SyncReqId)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_versions: FloatingSeq<Version> =
                            pre.versions;
                        let update_tmp_async_ephemeral: EphemeralState =
                            pre.async_ephemeral;
                        ((pre.sync_requests.dom().contains(sync_req_id)) &&
                             (((pre.sync_requests.spec_index(sync_req_id)).spec_le(pre.stable_index()))
                                  &&
                                  {
                                      let update_tmp_sync_requests:
                                              Map<SyncReqId, nat> =
                                          pre.sync_requests.remove(sync_req_id);
                                      ((::builtin::equal(post.sync_requests,
                                                         update_tmp_sync_requests))
                                           &&
                                           ((::builtin::equal(post.async_ephemeral,
                                                              update_tmp_async_ephemeral))
                                                &&
                                                (::builtin::equal(post.versions,
                                                                  update_tmp_versions))))
                                  }))
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_by(pre: State, post: State, step: Step)
                 -> ::core::primitive::bool {
                    match step {
                        Step::operate(op, new_versions, new_async_ephemeral,
                                      async_step) =>
                        Self::operate(pre, post, op, new_versions,
                                      new_async_ephemeral, async_step),
                        Step::crash() => Self::crash(pre, post),
                        Step::sync(new_stable_index) =>
                        Self::sync(pre, post, new_stable_index),
                        Step::req_sync(sync_req_id) =>
                        Self::req_sync(pre, post, sync_req_id),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next(pre: State, post: State)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong_by(pre: State, post: State, step: Step)
                 -> ::core::primitive::bool {
                    match step {
                        Step::operate(op, new_versions, new_async_ephemeral,
                                      async_step) =>
                        Self::operate_strong(pre, post, op, new_versions,
                                             new_async_ephemeral, async_step),
                        Step::crash() => Self::crash_strong(pre, post),
                        Step::sync(new_stable_index) =>
                        Self::sync_strong(pre, post, new_stable_index),
                        Step::req_sync(sync_req_id) =>
                        Self::req_sync_strong(pre, post, sync_req_id),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong(pre: State, post: State)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init_by(post: State, step: Config)
                 -> ::core::primitive::bool {
                    match step {
                        Config::initialize() => Self::initialize(post),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config|
                                          Self::init_by(post, step))
                }
                #[spec]
                #[verifier(publish)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
                #[verifier(verus_macro)]
                #[verifier(publish)]
                #[spec]
                pub fn the_inv(self) -> bool {
                    ((::builtin::spec_literal_nat("0")).spec_lt(self.versions.len()))
                        &&
                        (self.versions.is_active((self.versions.len()).spec_sub(::builtin::spec_literal_nat("1"))))
                }
                #[verifier(verus_macro)]
                #[verifier(publish)]
                #[spec]
                pub fn stable_index(self) -> int {
                    self.versions.first_active_index()
                }
                #[verifier(verus_macro)]
                #[verifier(publish)]
                #[spec]
                pub fn optionally_append_version(versions:
                                                     FloatingSeq<Version>,
                                                 versions_prime:
                                                     FloatingSeq<Version>)
                 -> bool {
                    (((::builtin::spec_literal_nat("0")).spec_lt(versions_prime.len())
                          &&
                          ::builtin::equal(versions_prime.drop_last(),
                                           versions))) ||
                        (::builtin::equal(versions_prime, versions))
                }
            }
        }
        fn main() { }
    }
    pub mod TotalKMMap_t {
        #![allow(unused_imports)]
        use builtin_macros::*;
        use builtin::*;
        use crate::pervasive::{*, map::*};
        use crate::spec::Messages_t::*;
        pub type Key = int;
        pub type TotalKMMap = Map<Key, Message>;
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn empty_total_map() -> Map<Key, Message> {
            Map::new(::builtin::closure_to_fn_spec(|i: int| true),
                     ::builtin::closure_to_fn_spec(|i: int| Message::empty()))
        }
    }
    pub mod Messages_t {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        pub type Value = int;
        pub type Delta = int;
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn default_value() -> Value {
            ::builtin::spec_literal_integer("0")
        }
        pub enum Message {
            Define {
                value: Value,
            },
            Update {
                delta: Delta,
            },
        }
        #[automatically_derived]
        impl Message {
            #[spec]
            #[verifier(is_variant("Define"))]
            #[allow(non_snake_case)]
            pub fn is_Define(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant(Define, value))]
            pub fn get_Define_value(self) -> Value {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[verifier(is_variant("Update"))]
            #[allow(non_snake_case)]
            pub fn is_Update(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant(Update, delta))]
            pub fn get_Update_delta(self) -> Delta {
                ::core::panicking::panic("not implemented")
            }
        }
        impl Message {
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn merge(self, new: Message) -> Message { self }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn empty() -> Message {
                Message::Define{value: ::builtin::spec_literal_integer("0"),}
            }
        }
    }
}
mod coordination_layer {
    pub mod StampedMap_v {
        #![allow(unused_imports)]
        use builtin_macros::*;
        use builtin::*;
        use crate::spec::FloatingSeq_t::*;
        use crate::spec::MapSpec_t::*;
        use crate::spec::TotalKMMap_t::*;
        pub type LSN = nat;
        pub struct Stamped<T> {
            pub value: T,
            pub seq_end: LSN,
        }
        pub type StampedMap = Stamped<TotalKMMap>;
        #[verifier(verus_macro)]
        #[verifier(publish)]
        #[spec]
        pub fn empty() -> StampedMap {
            Stamped{value: empty_total_map(),
                    seq_end: ::builtin::spec_literal_integer("0"),}
        }
        fn main() { }
    }
    pub mod MessageHistory_v {
        #![allow(unused_imports)]
        use builtin_macros::*;
        use builtin::*;
        use crate::pervasive::{*, map::*, set::*};
        use crate::spec::Messages_t::*;
        use crate::spec::TotalKMMap_t::*;
        use crate::coordination_layer::StampedMap_v::*;
        pub struct KeyedMessage {
            pub key: Key,
            pub message: Message,
        }
        pub struct MsgHistory {
            pub msgs: Map<LSN, KeyedMessage>,
            pub seq_start: LSN,
            pub seq_end: LSN,
        }
        impl MsgHistory {
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn wf(self) -> bool {
                ((self.seq_start).spec_le(self.seq_end)) &&
                    (self.contains_exactly(self.msgs.dom()))
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn contains(self, lsn: LSN) -> bool {
                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(self.seq_start),
                                                                                                  lsn),
                                                                       self.seq_end))
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn contains_exactly(self, lsns: Set<LSN>) -> bool {
                ::builtin::forall(|lsn|
                                      ::builtin::spec_eq((lsns.contains(lsn)),
                                                         (self.contains(lsn))))
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn is_empty(self) -> bool {
                ::builtin::spec_eq(self.seq_start, self.seq_end)
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn len(self) -> int {
                (self.seq_end).spec_sub(self.seq_start)
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn can_follow(self, lsn: LSN) -> bool {
                ::builtin::spec_eq(self.seq_start, lsn)
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn can_concat(self, other: MsgHistory) -> bool {
                other.can_follow(self.seq_end)
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn concat(self, other: MsgHistory) -> MsgHistory {
                ::builtin::recommends([self.can_concat(other)]);
                MsgHistory{msgs: self.msgs.union_prefer_right(other.msgs),
                           seq_start: self.seq_start,
                           seq_end: other.seq_end,}
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn can_discard_to(self, lsn: LSN) -> bool {
                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(self.seq_start),
                                                                                                  lsn),
                                                                       self.seq_end))
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn discard_recent(self, lsn: LSN) -> MsgHistory {
                ::builtin::recommends([self.can_discard_to(lsn)]);
                let keepMap =
                    Map::new(::builtin::closure_to_fn_spec(|k: nat|
                                                               ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(self.seq_start),
                                                                                                                                                 k),
                                                                                                                      lsn))),
                             ::builtin::closure_to_fn_spec(|k: nat|
                                                               self.msgs.spec_index(k)));
                MsgHistory{msgs: keepMap,
                           seq_start: self.seq_start,
                           seq_end: lsn,}
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn apply_to_stamped_map(self, orig: StampedMap)
             -> StampedMap {
                ::builtin::recommends([self.wf(),
                                       self.can_follow(orig.seq_end)]);
                ::builtin::decreases((self.len()));
                decreases_when(self.wf());
                if self.is_empty() {
                    orig
                } else {
                    let last_lsn =
                        ::builtin::spec_cast_integer::<_,
                                                       nat>(((self.seq_end).spec_sub(::builtin::spec_literal_nat("1"))));
                    let sub_map =
                        self.discard_recent(last_lsn).apply_to_stamped_map(orig);
                    let key = self.msgs.spec_index(last_lsn).key;
                    let new_message = self.msgs.spec_index(last_lsn).message;
                    let old_message = sub_map.value.spec_index(key);
                    let new_value =
                        sub_map.value.insert(key,
                                             old_message.merge(new_message));
                    Stamped{value: new_value,
                            seq_end:
                                (sub_map.seq_end).spec_add(::builtin::spec_literal_nat("1")),}
                }
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn discard_old(self, lsn: LSN) -> MsgHistory {
                ::builtin::recommends([self.can_discard_to(lsn)]);
                let keepMap =
                    Map::new(::builtin::closure_to_fn_spec(|k: nat|
                                                               ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(lsn),
                                                                                                                                                 k),
                                                                                                                      self.seq_end))),
                             ::builtin::closure_to_fn_spec(|k: nat|
                                                               self.msgs.spec_index(k)));
                MsgHistory{msgs: keepMap,
                           seq_start: lsn,
                           seq_end: self.seq_end,}
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn maybe_discard_old(self, lsn: LSN) -> MsgHistory {
                ::builtin::recommends([(lsn).spec_le(self.seq_end)]);
                if (self.seq_start).spec_le(lsn) {
                    self.discard_old(lsn)
                } else { self }
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn includes_subseq(self, subseq: MsgHistory) -> bool {
                (((self.seq_start).spec_le(subseq.seq_start)) &&
                     ((subseq.seq_end).spec_le(self.seq_end))) &&
                    (::builtin::forall(|lsn|
                                           #[auto_trigger] (::builtin::imply(subseq.contains(lsn),
                                                                             self.contains(lsn)
                                                                                 &&
                                                                                 ::builtin::equal(self.msgs.spec_index(lsn),
                                                                                                  subseq.msgs.spec_index(lsn))))))
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn empty_history_at(lsn: LSN) -> MsgHistory {
                MsgHistory{msgs: Map::empty(), seq_start: lsn, seq_end: lsn,}
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn singleton_at(lsn: LSN, msg: KeyedMessage) -> MsgHistory {
                MsgHistory{msgs: Map::empty(), seq_start: lsn, seq_end: lsn,}
            }
            #[verifier(verus_macro)]
            #[verifier(publish)]
            #[spec]
            pub fn map_plus_history(stamped_map: StampedMap,
                                    history: MsgHistory) -> StampedMap {
                ::builtin::recommends([history.can_follow(stamped_map.seq_end)]);
                history.apply_to_stamped_map(stamped_map)
            }
        }
    }
    pub mod AbstractJournal_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use crate::coordination_layer::StampedMap_v::*;
        use crate::coordination_layer::MessageHistory_v::*;
        #[allow(unused_parens)]
        pub mod AbstractJournal {
            use super::*;
            pub struct State {
                pub journal: MsgHistory,
            }
            #[allow(non_camel_case_types)]
            pub enum Step {
                read_for_recovery(),
                freeze_for_commit(),
                observe_fresh_journal(),
                put(),
                discard_old(),
                internal(),
                dummy_to_use_type_params(State),
            }
            #[allow(non_camel_case_types)]
            pub enum Config {
                initialize(MsgHistory),
                dummy_to_use_type_params(State),
            }
            pub enum Label {
                ReadForRecoveryLabel {
                    messages: MsgHistory,
                },
                FreezeForCommitLabel {
                    frozen_journal: MsgHistory,
                },
                QueryEndLsnLabel {
                    end_lsn: LSN,
                },
                PutLabel {
                    messages: MsgHistory,
                },
                DiscardOldLabel {
                    start_lsn: LSN,
                    require_end: LSN,
                },
                InternalLabel,
            }
            #[automatically_derived]
            impl Label {
                #[spec]
                #[verifier(is_variant("ReadForRecoveryLabel"))]
                #[allow(non_snake_case)]
                pub fn is_ReadForRecoveryLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(ReadForRecoveryLabel, messages))]
                pub fn get_ReadForRecoveryLabel_messages(self) -> MsgHistory {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("FreezeForCommitLabel"))]
                #[allow(non_snake_case)]
                pub fn is_FreezeForCommitLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(FreezeForCommitLabel, frozen_journal))]
                pub fn get_FreezeForCommitLabel_frozen_journal(self)
                 -> MsgHistory {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("QueryEndLsnLabel"))]
                #[allow(non_snake_case)]
                pub fn is_QueryEndLsnLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(QueryEndLsnLabel, end_lsn))]
                pub fn get_QueryEndLsnLabel_end_lsn(self) -> LSN {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("PutLabel"))]
                #[allow(non_snake_case)]
                pub fn is_PutLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(PutLabel, messages))]
                pub fn get_PutLabel_messages(self) -> MsgHistory {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("DiscardOldLabel"))]
                #[allow(non_snake_case)]
                pub fn is_DiscardOldLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(DiscardOldLabel, start_lsn))]
                pub fn get_DiscardOldLabel_start_lsn(self) -> LSN {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(DiscardOldLabel, require_end))]
                pub fn get_DiscardOldLabel_require_end(self) -> LSN {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("InternalLabel"))]
                #[allow(non_snake_case)]
                pub fn is_InternalLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
            }
            pub mod show {
                use super::*;
                #[verifier(external_body)]
                #[proof]
                pub fn read_for_recovery(pre: super::State,
                                         post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::read_for_recovery(pre,
                                                                        post,
                                                                        lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn freeze_for_commit(pre: super::State,
                                         post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::freeze_for_commit(pre,
                                                                        post,
                                                                        lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn observe_fresh_journal(pre: super::State,
                                             post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::observe_fresh_journal(pre,
                                                                            post,
                                                                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn put(pre: super::State, post: super::State,
                           lbl: Label) {
                    ::builtin::requires(super::State::put(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn discard_old(pre: super::State, post: super::State,
                                   lbl: Label) {
                    ::builtin::requires(super::State::discard_old(pre, post,
                                                                  lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn internal(pre: super::State, post: super::State,
                                lbl: Label) {
                    ::builtin::requires(super::State::internal(pre, post,
                                                               lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn initialize(post: super::State,
                                  persistent_journal: MsgHistory) {
                    ::builtin::requires(super::State::initialize(post,
                                                                 persistent_journal));
                    ::builtin::ensures(super::State::init(post));
                }
            }
            impl State {
                #[spec]
                #[verifier(publish)]
                pub fn initialize(post: Self, persistent_journal: MsgHistory)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory =
                            persistent_journal;
                        (::builtin::equal(post.journal, update_tmp_journal))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn read_for_recovery(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        ((lbl.is_ReadForRecoveryLabel()) &&
                             ((pre.journal.includes_subseq(lbl.get_ReadForRecoveryLabel_messages()))
                                  &&
                                  (::builtin::equal(post.journal,
                                                    update_tmp_journal))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn read_for_recovery_strong(pre: Self, post: Self,
                                                lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        ((lbl.is_ReadForRecoveryLabel()) &&
                             ((pre.journal.includes_subseq(lbl.get_ReadForRecoveryLabel_messages()))
                                  &&
                                  (::builtin::equal(post.journal,
                                                    update_tmp_journal))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn freeze_for_commit(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        ((lbl.is_FreezeForCommitLabel()) &&
                             ((pre.journal.includes_subseq(lbl.get_FreezeForCommitLabel_frozen_journal()))
                                  &&
                                  (::builtin::equal(post.journal,
                                                    update_tmp_journal))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn freeze_for_commit_strong(pre: Self, post: Self,
                                                lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        ((lbl.is_FreezeForCommitLabel()) &&
                             ((pre.journal.includes_subseq(lbl.get_FreezeForCommitLabel_frozen_journal()))
                                  &&
                                  (::builtin::equal(post.journal,
                                                    update_tmp_journal))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn observe_fresh_journal(pre: Self, post: Self,
                                             lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        ((lbl.is_QueryEndLsnLabel()) &&
                             ((pre.can_end_at(lbl.get_QueryEndLsnLabel_end_lsn()))
                                  &&
                                  (::builtin::equal(post.journal,
                                                    update_tmp_journal))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn observe_fresh_journal_strong(pre: Self, post: Self,
                                                    lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        ((lbl.is_QueryEndLsnLabel()) &&
                             ((pre.can_end_at(lbl.get_QueryEndLsnLabel_end_lsn()))
                                  &&
                                  (::builtin::equal(post.journal,
                                                    update_tmp_journal))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn put(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        ((lbl.is_PutLabel()) &&
                             ((::builtin::spec_eq(pre.journal.seq_end,
                                                  lbl.get_PutLabel_messages().seq_start))
                                  &&
                                  {
                                      let update_tmp_journal: MsgHistory =
                                          pre.journal.concat(lbl.get_PutLabel_messages());
                                      (::builtin::equal(post.journal,
                                                        update_tmp_journal))
                                  }))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        ((lbl.is_PutLabel()) &&
                             ((::builtin::spec_eq(pre.journal.seq_end,
                                                  lbl.get_PutLabel_messages().seq_start))
                                  &&
                                  {
                                      let update_tmp_journal: MsgHistory =
                                          pre.journal.concat(lbl.get_PutLabel_messages());
                                      (::builtin::equal(post.journal,
                                                        update_tmp_journal))
                                  }))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn discard_old(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        ((lbl.is_DiscardOldLabel()) &&
                             ((::builtin::spec_eq(pre.journal.seq_end,
                                                  lbl.get_DiscardOldLabel_require_end()))
                                  &&
                                  ((pre.journal.can_discard_to(lbl.get_DiscardOldLabel_start_lsn()))
                                       &&
                                       {
                                           let update_tmp_journal:
                                                   MsgHistory =
                                               pre.journal.discard_old(lbl.get_DiscardOldLabel_start_lsn());
                                           (::builtin::equal(post.journal,
                                                             update_tmp_journal))
                                       })))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn discard_old_strong(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        ((lbl.is_DiscardOldLabel()) &&
                             ((::builtin::spec_eq(pre.journal.seq_end,
                                                  lbl.get_DiscardOldLabel_require_end()))
                                  &&
                                  ((pre.journal.can_discard_to(lbl.get_DiscardOldLabel_start_lsn()))
                                       &&
                                       {
                                           let update_tmp_journal:
                                                   MsgHistory =
                                               pre.journal.discard_old(lbl.get_DiscardOldLabel_start_lsn());
                                           (::builtin::equal(post.journal,
                                                             update_tmp_journal))
                                       })))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn internal(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        ((lbl.is_InternalLabel()) &&
                             (::builtin::equal(post.journal,
                                               update_tmp_journal)))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn internal_strong(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        ((lbl.is_InternalLabel()) &&
                             (::builtin::equal(post.journal,
                                               update_tmp_journal)))
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_by(pre: State, post: State, label: Label,
                               step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::read_for_recovery() =>
                        Self::read_for_recovery(pre, post, label),
                        Step::freeze_for_commit() =>
                        Self::freeze_for_commit(pre, post, label),
                        Step::observe_fresh_journal() =>
                        Self::observe_fresh_journal(pre, post, label),
                        Step::put() => Self::put(pre, post, label),
                        Step::discard_old() =>
                        Self::discard_old(pre, post, label),
                        Step::internal() => Self::internal(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next(pre: State, post: State, label: Label)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, label,
                                                        step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                                      step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::read_for_recovery() =>
                        Self::read_for_recovery_strong(pre, post, label),
                        Step::freeze_for_commit() =>
                        Self::freeze_for_commit_strong(pre, post, label),
                        Step::observe_fresh_journal() =>
                        Self::observe_fresh_journal_strong(pre, post, label),
                        Step::put() => Self::put_strong(pre, post, label),
                        Step::discard_old() =>
                        Self::discard_old_strong(pre, post, label),
                        Step::internal() =>
                        Self::internal_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, label,
                                                        step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init_by(post: State, step: Config)
                 -> ::core::primitive::bool {
                    match step {
                        Config::initialize(persistent_journal) =>
                        Self::initialize(post, persistent_journal),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config|
                                          Self::init_by(post, step))
                }
                #[spec]
                #[verifier(publish)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
                #[verifier(verus_macro)]
                #[verifier(publish)]
                #[spec]
                pub fn can_end_at(self, lsn: LSN) -> bool {
                    ::builtin::spec_eq(self.journal.seq_end, lsn)
                }
            }
        }
    }
    pub mod AbstractMap_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use crate::spec::Messages_t::*;
        use crate::spec::TotalKMMap_t::*;
        use crate::coordination_layer::StampedMap_v::*;
        use crate::coordination_layer::MessageHistory_v::*;
        #[allow(unused_parens)]
        pub mod AbstractMap {
            use super::*;
            pub struct State {
                pub stamped_map: StampedMap,
            }
            #[allow(non_camel_case_types)]
            pub enum Step {
                query(),
                put(),
                freeze_as(),
                internal(),
                dummy_to_use_type_params(State),
            }
            #[allow(non_camel_case_types)]
            pub enum Config {
                initialize(StampedMap),
                dummy_to_use_type_params(State),
            }
            pub enum Label {
                QueryLabel {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },
                PutLabel {
                    puts: MsgHistory,
                },
                FreezeAsLabel {
                    stamped_map: StampedMap,
                },
                InternalLabel,
            }
            #[automatically_derived]
            impl Label {
                #[spec]
                #[verifier(is_variant("QueryLabel"))]
                #[allow(non_snake_case)]
                pub fn is_QueryLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(QueryLabel, end_lsn))]
                pub fn get_QueryLabel_end_lsn(self) -> LSN {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(QueryLabel, key))]
                pub fn get_QueryLabel_key(self) -> Key {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(QueryLabel, value))]
                pub fn get_QueryLabel_value(self) -> Value {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("PutLabel"))]
                #[allow(non_snake_case)]
                pub fn is_PutLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(PutLabel, puts))]
                pub fn get_PutLabel_puts(self) -> MsgHistory {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("FreezeAsLabel"))]
                #[allow(non_snake_case)]
                pub fn is_FreezeAsLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(FreezeAsLabel, stamped_map))]
                pub fn get_FreezeAsLabel_stamped_map(self) -> StampedMap {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("InternalLabel"))]
                #[allow(non_snake_case)]
                pub fn is_InternalLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
            }
            pub mod show {
                use super::*;
                #[verifier(external_body)]
                #[proof]
                pub fn query(pre: super::State, post: super::State,
                             lbl: Label) {
                    ::builtin::requires(super::State::query(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn put(pre: super::State, post: super::State,
                           lbl: Label) {
                    ::builtin::requires(super::State::put(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn freeze_as(pre: super::State, post: super::State,
                                 lbl: Label) {
                    ::builtin::requires(super::State::freeze_as(pre, post,
                                                                lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn internal(pre: super::State, post: super::State,
                                lbl: Label) {
                    ::builtin::requires(super::State::internal(pre, post,
                                                               lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn initialize(post: super::State,
                                  persistent_map: StampedMap) {
                    ::builtin::requires(super::State::initialize(post,
                                                                 persistent_map));
                    ::builtin::ensures(super::State::init(post));
                }
            }
            impl State {
                #[spec]
                #[verifier(publish)]
                pub fn initialize(post: Self, persistent_map: StampedMap)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap =
                            persistent_map;
                        (::builtin::equal(post.stamped_map,
                                          update_tmp_stamped_map))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn query(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap =
                            pre.stamped_map;
                        ((lbl.is_QueryLabel()) &&
                             ((::builtin::spec_eq(lbl.get_QueryLabel_end_lsn(),
                                                  pre.stamped_map.seq_end)) &&
                                  ((::builtin::equal(lbl.get_QueryLabel_value(),
                                                     pre.stamped_map.value.spec_index(lbl.get_QueryLabel_key()).get_Define_value()))
                                       &&
                                       (::builtin::equal(post.stamped_map,
                                                         update_tmp_stamped_map)))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn query_strong(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap =
                            pre.stamped_map;
                        ((lbl.is_QueryLabel()) &&
                             ((::builtin::spec_eq(lbl.get_QueryLabel_end_lsn(),
                                                  pre.stamped_map.seq_end)) &&
                                  ((::builtin::equal(lbl.get_QueryLabel_value(),
                                                     pre.stamped_map.value.spec_index(lbl.get_QueryLabel_key()).get_Define_value()))
                                       &&
                                       (::builtin::equal(post.stamped_map,
                                                         update_tmp_stamped_map)))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn put(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        ((lbl.is_PutLabel()) &&
                             ((lbl.get_PutLabel_puts().can_follow(pre.stamped_map.seq_end))
                                  &&
                                  {
                                      let update_tmp_stamped_map: StampedMap =
                                          MsgHistory::map_plus_history(pre.stamped_map,
                                                                       lbl.get_PutLabel_puts());
                                      (::builtin::equal(post.stamped_map,
                                                        update_tmp_stamped_map))
                                  }))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        ((lbl.is_PutLabel()) &&
                             ((lbl.get_PutLabel_puts().can_follow(pre.stamped_map.seq_end))
                                  &&
                                  {
                                      let update_tmp_stamped_map: StampedMap =
                                          MsgHistory::map_plus_history(pre.stamped_map,
                                                                       lbl.get_PutLabel_puts());
                                      (::builtin::equal(post.stamped_map,
                                                        update_tmp_stamped_map))
                                  }))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn freeze_as(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap =
                            pre.stamped_map;
                        ((lbl.is_FreezeAsLabel()) &&
                             ((::builtin::equal(lbl.get_FreezeAsLabel_stamped_map(),
                                                pre.stamped_map)) &&
                                  (::builtin::equal(post.stamped_map,
                                                    update_tmp_stamped_map))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn freeze_as_strong(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap =
                            pre.stamped_map;
                        ((lbl.is_FreezeAsLabel()) &&
                             ((::builtin::equal(lbl.get_FreezeAsLabel_stamped_map(),
                                                pre.stamped_map)) &&
                                  (::builtin::equal(post.stamped_map,
                                                    update_tmp_stamped_map))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn internal(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap =
                            pre.stamped_map;
                        ((lbl.is_InternalLabel()) &&
                             (::builtin::equal(post.stamped_map,
                                               update_tmp_stamped_map)))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn internal_strong(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap =
                            pre.stamped_map;
                        ((lbl.is_InternalLabel()) &&
                             (::builtin::equal(post.stamped_map,
                                               update_tmp_stamped_map)))
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_by(pre: State, post: State, label: Label,
                               step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query() => Self::query(pre, post, label),
                        Step::put() => Self::put(pre, post, label),
                        Step::freeze_as() =>
                        Self::freeze_as(pre, post, label),
                        Step::internal() => Self::internal(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next(pre: State, post: State, label: Label)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, label,
                                                        step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                                      step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query() => Self::query_strong(pre, post, label),
                        Step::put() => Self::put_strong(pre, post, label),
                        Step::freeze_as() =>
                        Self::freeze_as_strong(pre, post, label),
                        Step::internal() =>
                        Self::internal_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, label,
                                                        step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init_by(post: State, step: Config)
                 -> ::core::primitive::bool {
                    match step {
                        Config::initialize(persistent_map) =>
                        Self::initialize(post, persistent_map),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config|
                                          Self::init_by(post, step))
                }
                #[spec]
                #[verifier(publish)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
            }
        }
    }
    pub mod CrashTolerantJournal_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        #[allow(unused_imports)]
        use crate::pervasive::{map::*};
        use crate::spec::Option_t::*;
        use crate::coordination_layer::StampedMap_v::*;
        use crate::coordination_layer::MessageHistory_v::*;
        use crate::coordination_layer::AbstractJournal_v::*;
        pub type StoreImage = MsgHistory;
        pub enum Ephemeral {
            Unknown,
            Known {
                v: AbstractJournal::State,
            },
        }
        #[automatically_derived]
        impl Ephemeral {
            #[spec]
            #[verifier(is_variant("Unknown"))]
            #[allow(non_snake_case)]
            pub fn is_Unknown(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[verifier(is_variant("Known"))]
            #[allow(non_snake_case)]
            pub fn is_Known(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant(Known, v))]
            pub fn get_Known_v(self) -> AbstractJournal::State {
                ::core::panicking::panic("not implemented")
            }
        }
        #[allow(unused_parens)]
        pub mod CrashTolerantJournal {
            use super::*;
            pub struct State {
                pub persistent: StoreImage,
                pub ephemeral: Ephemeral,
                pub in_flight: Option<StoreImage>,
            }
            #[allow(non_camel_case_types)]
            pub enum Step {
                load_ephemeral_from_persistent(AbstractJournal::State,
                                               AbstractJournal::Config),
                read_for_recovery(AbstractJournal::State,
                                  AbstractJournal::Step),
                query_end_lsn(AbstractJournal::State, AbstractJournal::Step),
                put(AbstractJournal::State, AbstractJournal::Step),
                internal(AbstractJournal::State, AbstractJournal::Step),
                query_lsn_persistence(),
                commit_start(StoreImage, AbstractJournal::State,
                             AbstractJournal::Step),
                commit_complete(AbstractJournal::State,
                                AbstractJournal::Step),
                crash(),
                dummy_to_use_type_params(State),
            }
            #[allow(non_camel_case_types)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            pub enum Label {
                LoadEphemeralFromPersistentLabel,
                ReadForRecoveryLabel {
                    records: MsgHistory,
                },
                QueryEndLsnLabel {
                    end_lsn: LSN,
                },
                PutLabel {
                    records: MsgHistory,
                },
                InternalLabel,
                QueryLsnPersistenceLabel {
                    sync_lsn: LSN,
                },
                CommitStartLabel {
                    new_boundary_lsn: LSN,
                    max_lsn: LSN,
                },
                CommitCompleteLabel {
                    require_end: LSN,
                },
                CrashLabel,
            }
            #[automatically_derived]
            impl Label {
                #[spec]
                #[verifier(is_variant("LoadEphemeralFromPersistentLabel"))]
                #[allow(non_snake_case)]
                pub fn is_LoadEphemeralFromPersistentLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("ReadForRecoveryLabel"))]
                #[allow(non_snake_case)]
                pub fn is_ReadForRecoveryLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(ReadForRecoveryLabel, records))]
                pub fn get_ReadForRecoveryLabel_records(self) -> MsgHistory {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("QueryEndLsnLabel"))]
                #[allow(non_snake_case)]
                pub fn is_QueryEndLsnLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(QueryEndLsnLabel, end_lsn))]
                pub fn get_QueryEndLsnLabel_end_lsn(self) -> LSN {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("PutLabel"))]
                #[allow(non_snake_case)]
                pub fn is_PutLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(PutLabel, records))]
                pub fn get_PutLabel_records(self) -> MsgHistory {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("InternalLabel"))]
                #[allow(non_snake_case)]
                pub fn is_InternalLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("QueryLsnPersistenceLabel"))]
                #[allow(non_snake_case)]
                pub fn is_QueryLsnPersistenceLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(QueryLsnPersistenceLabel, sync_lsn))]
                pub fn get_QueryLsnPersistenceLabel_sync_lsn(self) -> LSN {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("CommitStartLabel"))]
                #[allow(non_snake_case)]
                pub fn is_CommitStartLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(CommitStartLabel, new_boundary_lsn))]
                pub fn get_CommitStartLabel_new_boundary_lsn(self) -> LSN {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(CommitStartLabel, max_lsn))]
                pub fn get_CommitStartLabel_max_lsn(self) -> LSN {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("CommitCompleteLabel"))]
                #[allow(non_snake_case)]
                pub fn is_CommitCompleteLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(CommitCompleteLabel, require_end))]
                pub fn get_CommitCompleteLabel_require_end(self) -> LSN {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("CrashLabel"))]
                #[allow(non_snake_case)]
                pub fn is_CrashLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
            }
            pub mod show {
                use super::*;
                #[verifier(external_body)]
                #[proof]
                pub fn load_ephemeral_from_persistent(pre: super::State,
                                                      post: super::State,
                                                      lbl: Label,
                                                      new_journal:
                                                          AbstractJournal::State,
                                                      journal_config:
                                                          AbstractJournal::Config) {
                    ::builtin::requires(super::State::load_ephemeral_from_persistent(pre,
                                                                                     post,
                                                                                     lbl,
                                                                                     new_journal,
                                                                                     journal_config));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn read_for_recovery(pre: super::State,
                                         post: super::State, lbl: Label,
                                         new_journal: AbstractJournal::State,
                                         journal_step:
                                             AbstractJournal::Step) {
                    ::builtin::requires(super::State::read_for_recovery(pre,
                                                                        post,
                                                                        lbl,
                                                                        new_journal,
                                                                        journal_step));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn query_end_lsn(pre: super::State, post: super::State,
                                     lbl: Label,
                                     new_journal: AbstractJournal::State,
                                     journal_step: AbstractJournal::Step) {
                    ::builtin::requires(super::State::query_end_lsn(pre, post,
                                                                    lbl,
                                                                    new_journal,
                                                                    journal_step));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn put(pre: super::State, post: super::State, lbl: Label,
                           new_journal: AbstractJournal::State,
                           journal_step: AbstractJournal::Step) {
                    ::builtin::requires(super::State::put(pre, post, lbl,
                                                          new_journal,
                                                          journal_step));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn internal(pre: super::State, post: super::State,
                                lbl: Label,
                                new_journal: AbstractJournal::State,
                                journal_step: AbstractJournal::Step) {
                    ::builtin::requires(super::State::internal(pre, post, lbl,
                                                               new_journal,
                                                               journal_step));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn query_lsn_persistence(pre: super::State,
                                             post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::query_lsn_persistence(pre,
                                                                            post,
                                                                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn commit_start(pre: super::State, post: super::State,
                                    lbl: Label, frozen_journal: StoreImage,
                                    new_journal: AbstractJournal::State,
                                    journal_step: AbstractJournal::Step) {
                    ::builtin::requires(super::State::commit_start(pre, post,
                                                                   lbl,
                                                                   frozen_journal,
                                                                   new_journal,
                                                                   journal_step));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn commit_complete(pre: super::State, post: super::State,
                                       lbl: Label,
                                       new_journal: AbstractJournal::State,
                                       journal_step: AbstractJournal::Step) {
                    ::builtin::requires(super::State::commit_complete(pre,
                                                                      post,
                                                                      lbl,
                                                                      new_journal,
                                                                      journal_step));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn crash(pre: super::State, post: super::State,
                             lbl: Label) {
                    ::builtin::requires(super::State::crash(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn initialize(post: super::State) {
                    ::builtin::requires(super::State::initialize(post));
                    ::builtin::ensures(super::State::init(post));
                }
            }
            impl State {
                #[spec]
                #[verifier(publish)]
                pub fn initialize(post: Self) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            MsgHistory{msgs: Map::empty(),
                                       seq_start:
                                           ::builtin::spec_literal_integer("0"),
                                       seq_end:
                                           ::builtin::spec_literal_integer("0"),};
                        let update_tmp_ephemeral: Ephemeral =
                            Ephemeral::Unknown;
                        let update_tmp_in_flight: Option<StoreImage> =
                            Option::None;
                        ((::builtin::equal(post.in_flight,
                                           update_tmp_in_flight)) &&
                             ((::builtin::equal(post.ephemeral,
                                                update_tmp_ephemeral)) &&
                                  (::builtin::equal(post.persistent,
                                                    update_tmp_persistent))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn load_ephemeral_from_persistent(pre: Self, post: Self,
                                                      lbl: Label,
                                                      new_journal:
                                                          AbstractJournal::State,
                                                      journal_config:
                                                          AbstractJournal::Config)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_LoadEphemeralFromPersistentLabel()) &&
                             ((pre.ephemeral.is_Unknown()) &&
                                  ((::builtin::equal(journal_config,
                                                     AbstractJournal::Config::initialize(pre.persistent)))
                                       &&
                                       ((AbstractJournal::State::init_by(new_journal,
                                                                         journal_config))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_journal,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn load_ephemeral_from_persistent_strong(pre: Self,
                                                             post: Self,
                                                             lbl: Label,
                                                             new_journal:
                                                                 AbstractJournal::State,
                                                             journal_config:
                                                                 AbstractJournal::Config)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_LoadEphemeralFromPersistentLabel()) &&
                             ((pre.ephemeral.is_Unknown()) &&
                                  ((::builtin::equal(journal_config,
                                                     AbstractJournal::Config::initialize(pre.persistent)))
                                       &&
                                       ((AbstractJournal::State::init_by(new_journal,
                                                                         journal_config))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_journal,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn read_for_recovery(pre: Self, post: Self, lbl: Label,
                                         new_journal: AbstractJournal::State,
                                         journal_step: AbstractJournal::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_ReadForRecoveryLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(journal_step,
                                                     AbstractJournal::Step::read_for_recovery()))
                                       &&
                                       ((AbstractJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                                                         new_journal,
                                                                         AbstractJournal::Label::ReadForRecoveryLabel{messages:
                                                                                                                          lbl.get_ReadForRecoveryLabel_records(),},
                                                                         journal_step))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_journal,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn read_for_recovery_strong(pre: Self, post: Self,
                                                lbl: Label,
                                                new_journal:
                                                    AbstractJournal::State,
                                                journal_step:
                                                    AbstractJournal::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_ReadForRecoveryLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(journal_step,
                                                     AbstractJournal::Step::read_for_recovery()))
                                       &&
                                       ((AbstractJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                                                         new_journal,
                                                                         AbstractJournal::Label::ReadForRecoveryLabel{messages:
                                                                                                                          lbl.get_ReadForRecoveryLabel_records(),},
                                                                         journal_step))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_journal,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn query_end_lsn(pre: Self, post: Self, lbl: Label,
                                     new_journal: AbstractJournal::State,
                                     journal_step: AbstractJournal::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_QueryEndLsnLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(journal_step,
                                                     AbstractJournal::Step::observe_fresh_journal()))
                                       &&
                                       ((AbstractJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                                                         new_journal,
                                                                         AbstractJournal::Label::QueryEndLsnLabel{end_lsn:
                                                                                                                      lbl.get_QueryEndLsnLabel_end_lsn(),},
                                                                         journal_step))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_journal,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn query_end_lsn_strong(pre: Self, post: Self, lbl: Label,
                                            new_journal:
                                                AbstractJournal::State,
                                            journal_step:
                                                AbstractJournal::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_QueryEndLsnLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(journal_step,
                                                     AbstractJournal::Step::observe_fresh_journal()))
                                       &&
                                       ((AbstractJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                                                         new_journal,
                                                                         AbstractJournal::Label::QueryEndLsnLabel{end_lsn:
                                                                                                                      lbl.get_QueryEndLsnLabel_end_lsn(),},
                                                                         journal_step))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_journal,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn put(pre: Self, post: Self, lbl: Label,
                           new_journal: AbstractJournal::State,
                           journal_step: AbstractJournal::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_PutLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(journal_step,
                                                     AbstractJournal::Step::put()))
                                       &&
                                       ((AbstractJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                                                         new_journal,
                                                                         AbstractJournal::Label::PutLabel{messages:
                                                                                                              lbl.get_PutLabel_records(),},
                                                                         journal_step))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_journal,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label,
                                  new_journal: AbstractJournal::State,
                                  journal_step: AbstractJournal::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_PutLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(journal_step,
                                                     AbstractJournal::Step::put()))
                                       &&
                                       ((AbstractJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                                                         new_journal,
                                                                         AbstractJournal::Label::PutLabel{messages:
                                                                                                              lbl.get_PutLabel_records(),},
                                                                         journal_step))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_journal,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn internal(pre: Self, post: Self, lbl: Label,
                                new_journal: AbstractJournal::State,
                                journal_step: AbstractJournal::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_InternalLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(journal_step,
                                                     AbstractJournal::Step::internal()))
                                       &&
                                       ((AbstractJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                                                         new_journal,
                                                                         AbstractJournal::Label::InternalLabel,
                                                                         journal_step))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_journal,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn internal_strong(pre: Self, post: Self, lbl: Label,
                                       new_journal: AbstractJournal::State,
                                       journal_step: AbstractJournal::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_InternalLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(journal_step,
                                                     AbstractJournal::Step::internal()))
                                       &&
                                       ((AbstractJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                                                         new_journal,
                                                                         AbstractJournal::Label::InternalLabel,
                                                                         journal_step))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_journal,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn query_lsn_persistence(pre: Self, post: Self,
                                             lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_QueryLsnPersistenceLabel()) &&
                             (((lbl.get_QueryLsnPersistenceLabel_sync_lsn()).spec_le(pre.persistent.seq_end))
                                  &&
                                  ((::builtin::equal(post.in_flight,
                                                     update_tmp_in_flight)) &&
                                       ((::builtin::equal(post.ephemeral,
                                                          update_tmp_ephemeral))
                                            &&
                                            (::builtin::equal(post.persistent,
                                                              update_tmp_persistent))))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn query_lsn_persistence_strong(pre: Self, post: Self,
                                                    lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_QueryLsnPersistenceLabel()) &&
                             (((lbl.get_QueryLsnPersistenceLabel_sync_lsn()).spec_le(pre.persistent.seq_end))
                                  &&
                                  ((::builtin::equal(post.in_flight,
                                                     update_tmp_in_flight)) &&
                                       ((::builtin::equal(post.ephemeral,
                                                          update_tmp_ephemeral))
                                            &&
                                            (::builtin::equal(post.persistent,
                                                              update_tmp_persistent))))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn commit_start(pre: Self, post: Self, lbl: Label,
                                    frozen_journal: StoreImage,
                                    new_journal: AbstractJournal::State,
                                    journal_step: AbstractJournal::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        ((lbl.is_CommitStartLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((pre.in_flight.is_None()) &&
                                       ((::builtin::spec_eq(frozen_journal.seq_start,
                                                            lbl.get_CommitStartLabel_new_boundary_lsn()))
                                            &&
                                            (((pre.persistent.seq_end).spec_le(frozen_journal.seq_end))
                                                 &&
                                                 (((frozen_journal.seq_start).spec_le(lbl.get_CommitStartLabel_max_lsn()))
                                                      &&
                                                      ((::builtin::equal(journal_step,
                                                                         AbstractJournal::Step::freeze_for_commit()))
                                                           &&
                                                           ((AbstractJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                                                                             new_journal,
                                                                                             AbstractJournal::Label::FreezeForCommitLabel{frozen_journal:
                                                                                                                                              frozen_journal,},
                                                                                             journal_step))
                                                                &&
                                                                {
                                                                    let update_tmp_ephemeral:
                                                                            Ephemeral =
                                                                        Ephemeral::Known{v:
                                                                                             new_journal,};
                                                                    let update_tmp_in_flight:
                                                                            Option<StoreImage> =
                                                                        Option::Some(frozen_journal);
                                                                    ((::builtin::equal(post.in_flight,
                                                                                       update_tmp_in_flight))
                                                                         &&
                                                                         ((::builtin::equal(post.ephemeral,
                                                                                            update_tmp_ephemeral))
                                                                              &&
                                                                              (::builtin::equal(post.persistent,
                                                                                                update_tmp_persistent))))
                                                                }))))))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn commit_start_strong(pre: Self, post: Self, lbl: Label,
                                           frozen_journal: StoreImage,
                                           new_journal:
                                               AbstractJournal::State,
                                           journal_step:
                                               AbstractJournal::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        ((lbl.is_CommitStartLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((pre.in_flight.is_None()) &&
                                       ((::builtin::spec_eq(frozen_journal.seq_start,
                                                            lbl.get_CommitStartLabel_new_boundary_lsn()))
                                            &&
                                            (((pre.persistent.seq_end).spec_le(frozen_journal.seq_end))
                                                 &&
                                                 (((frozen_journal.seq_start).spec_le(lbl.get_CommitStartLabel_max_lsn()))
                                                      &&
                                                      ((::builtin::equal(journal_step,
                                                                         AbstractJournal::Step::freeze_for_commit()))
                                                           &&
                                                           ((AbstractJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                                                                             new_journal,
                                                                                             AbstractJournal::Label::FreezeForCommitLabel{frozen_journal:
                                                                                                                                              frozen_journal,},
                                                                                             journal_step))
                                                                &&
                                                                {
                                                                    let update_tmp_ephemeral:
                                                                            Ephemeral =
                                                                        Ephemeral::Known{v:
                                                                                             new_journal,};
                                                                    let update_tmp_in_flight:
                                                                            Option<StoreImage> =
                                                                        Option::Some(frozen_journal);
                                                                    ((::builtin::equal(post.in_flight,
                                                                                       update_tmp_in_flight))
                                                                         &&
                                                                         ((::builtin::equal(post.ephemeral,
                                                                                            update_tmp_ephemeral))
                                                                              &&
                                                                              (::builtin::equal(post.persistent,
                                                                                                update_tmp_persistent))))
                                                                }))))))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn commit_complete(pre: Self, post: Self, lbl: Label,
                                       new_journal: AbstractJournal::State,
                                       journal_step: AbstractJournal::Step)
                 -> ::core::primitive::bool {
                    {
                        ((lbl.is_CommitCompleteLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((pre.in_flight.is_Some()) &&
                                       ((::builtin::equal(journal_step,
                                                          AbstractJournal::Step::discard_old()))
                                            &&
                                            ((AbstractJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                                                              new_journal,
                                                                              AbstractJournal::Label::DiscardOldLabel{start_lsn:
                                                                                                                          pre.in_flight.get_Some_0().seq_start,
                                                                                                                      require_end:
                                                                                                                          lbl.get_CommitCompleteLabel_require_end(),},
                                                                              journal_step))
                                                 &&
                                                 {
                                                     let update_tmp_persistent:
                                                             StoreImage =
                                                         pre.in_flight.get_Some_0();
                                                     let update_tmp_ephemeral:
                                                             Ephemeral =
                                                         Ephemeral::Known{v:
                                                                              new_journal,};
                                                     let update_tmp_in_flight:
                                                             Option<StoreImage> =
                                                         Option::None;
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          ((::builtin::equal(post.ephemeral,
                                                                             update_tmp_ephemeral))
                                                               &&
                                                               (::builtin::equal(post.persistent,
                                                                                 update_tmp_persistent))))
                                                 })))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn commit_complete_strong(pre: Self, post: Self,
                                              lbl: Label,
                                              new_journal:
                                                  AbstractJournal::State,
                                              journal_step:
                                                  AbstractJournal::Step)
                 -> ::core::primitive::bool {
                    {
                        ((lbl.is_CommitCompleteLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((pre.in_flight.is_Some()) &&
                                       ((::builtin::equal(journal_step,
                                                          AbstractJournal::Step::discard_old()))
                                            &&
                                            ((AbstractJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                                                              new_journal,
                                                                              AbstractJournal::Label::DiscardOldLabel{start_lsn:
                                                                                                                          pre.in_flight.get_Some_0().seq_start,
                                                                                                                      require_end:
                                                                                                                          lbl.get_CommitCompleteLabel_require_end(),},
                                                                              journal_step))
                                                 &&
                                                 {
                                                     let update_tmp_persistent:
                                                             StoreImage =
                                                         pre.in_flight.get_Some_0();
                                                     let update_tmp_ephemeral:
                                                             Ephemeral =
                                                         Ephemeral::Known{v:
                                                                              new_journal,};
                                                     let update_tmp_in_flight:
                                                             Option<StoreImage> =
                                                         Option::None;
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          ((::builtin::equal(post.ephemeral,
                                                                             update_tmp_ephemeral))
                                                               &&
                                                               (::builtin::equal(post.persistent,
                                                                                 update_tmp_persistent))))
                                                 })))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn crash(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        ((lbl.is_CrashLabel()) &&
                             {
                                 let update_tmp_ephemeral: Ephemeral =
                                     Ephemeral::Unknown;
                                 let update_tmp_in_flight:
                                         Option<StoreImage> = Option::None;
                                 ((::builtin::equal(post.in_flight,
                                                    update_tmp_in_flight)) &&
                                      ((::builtin::equal(post.ephemeral,
                                                         update_tmp_ephemeral))
                                           &&
                                           (::builtin::equal(post.persistent,
                                                             update_tmp_persistent))))
                             })
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn crash_strong(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        ((lbl.is_CrashLabel()) &&
                             {
                                 let update_tmp_ephemeral: Ephemeral =
                                     Ephemeral::Unknown;
                                 let update_tmp_in_flight:
                                         Option<StoreImage> = Option::None;
                                 ((::builtin::equal(post.in_flight,
                                                    update_tmp_in_flight)) &&
                                      ((::builtin::equal(post.ephemeral,
                                                         update_tmp_ephemeral))
                                           &&
                                           (::builtin::equal(post.persistent,
                                                             update_tmp_persistent))))
                             })
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_by(pre: State, post: State, label: Label,
                               step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent(new_journal,
                                                             journal_config)
                        =>
                        Self::load_ephemeral_from_persistent(pre, post, label,
                                                             new_journal,
                                                             journal_config),
                        Step::read_for_recovery(new_journal, journal_step) =>
                        Self::read_for_recovery(pre, post, label, new_journal,
                                                journal_step),
                        Step::query_end_lsn(new_journal, journal_step) =>
                        Self::query_end_lsn(pre, post, label, new_journal,
                                            journal_step),
                        Step::put(new_journal, journal_step) =>
                        Self::put(pre, post, label, new_journal,
                                  journal_step),
                        Step::internal(new_journal, journal_step) =>
                        Self::internal(pre, post, label, new_journal,
                                       journal_step),
                        Step::query_lsn_persistence() =>
                        Self::query_lsn_persistence(pre, post, label),
                        Step::commit_start(frozen_journal, new_journal,
                                           journal_step) =>
                        Self::commit_start(pre, post, label, frozen_journal,
                                           new_journal, journal_step),
                        Step::commit_complete(new_journal, journal_step) =>
                        Self::commit_complete(pre, post, label, new_journal,
                                              journal_step),
                        Step::crash() => Self::crash(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next(pre: State, post: State, label: Label)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, label,
                                                        step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                                      step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent(new_journal,
                                                             journal_config)
                        =>
                        Self::load_ephemeral_from_persistent_strong(pre, post,
                                                                    label,
                                                                    new_journal,
                                                                    journal_config),
                        Step::read_for_recovery(new_journal, journal_step) =>
                        Self::read_for_recovery_strong(pre, post, label,
                                                       new_journal,
                                                       journal_step),
                        Step::query_end_lsn(new_journal, journal_step) =>
                        Self::query_end_lsn_strong(pre, post, label,
                                                   new_journal, journal_step),
                        Step::put(new_journal, journal_step) =>
                        Self::put_strong(pre, post, label, new_journal,
                                         journal_step),
                        Step::internal(new_journal, journal_step) =>
                        Self::internal_strong(pre, post, label, new_journal,
                                              journal_step),
                        Step::query_lsn_persistence() =>
                        Self::query_lsn_persistence_strong(pre, post, label),
                        Step::commit_start(frozen_journal, new_journal,
                                           journal_step) =>
                        Self::commit_start_strong(pre, post, label,
                                                  frozen_journal, new_journal,
                                                  journal_step),
                        Step::commit_complete(new_journal, journal_step) =>
                        Self::commit_complete_strong(pre, post, label,
                                                     new_journal,
                                                     journal_step),
                        Step::crash() => Self::crash_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, label,
                                                        step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init_by(post: State, step: Config)
                 -> ::core::primitive::bool {
                    match step {
                        Config::initialize() => Self::initialize(post),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config|
                                          Self::init_by(post, step))
                }
                #[spec]
                #[verifier(publish)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
            }
        }
    }
    pub mod CrashTolerantMap_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        #[allow(unused_imports)]
        use crate::pervasive::{map::*};
        use crate::spec::Option_t::*;
        use crate::spec::TotalKMMap_t::*;
        use crate::spec::Messages_t::*;
        use crate::coordination_layer::StampedMap_v::*;
        use crate::coordination_layer::MessageHistory_v::*;
        use crate::coordination_layer::AbstractMap_v::*;
        type StoreImage = StampedMap;
        pub enum Ephemeral {
            Unknown,
            Known {
                v: AbstractMap::State,
            },
        }
        #[automatically_derived]
        impl Ephemeral {
            #[spec]
            #[verifier(is_variant("Unknown"))]
            #[allow(non_snake_case)]
            pub fn is_Unknown(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[verifier(is_variant("Known"))]
            #[allow(non_snake_case)]
            pub fn is_Known(&self) -> bool {
                ::core::panicking::panic("not implemented")
            }
            #[spec]
            #[allow(non_snake_case)]
            #[verifier(get_variant(Known, v))]
            pub fn get_Known_v(self) -> AbstractMap::State {
                ::core::panicking::panic("not implemented")
            }
        }
        #[allow(unused_parens)]
        pub mod CrashTolerantMap {
            use super::*;
            pub struct State {
                pub persistent: StoreImage,
                pub ephemeral: Ephemeral,
                pub in_flight: Option<StoreImage>,
            }
            #[allow(non_camel_case_types)]
            pub enum Step {
                load_ephemeral_from_persistent(AbstractMap::State,
                                               AbstractMap::Config),
                put_records(AbstractMap::State, AbstractMap::Step),
                query(AbstractMap::State, AbstractMap::Step),
                freeze_map_internal(StampedMap, AbstractMap::State,
                                    AbstractMap::Step),
                ephemeral_internal(AbstractMap::State, AbstractMap::Step),
                commit_start(),
                commit_complete(),
                crash(),
                dummy_to_use_type_params(State),
            }
            #[allow(non_camel_case_types)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            pub enum Label {
                LoadEphemeralFromPersistentLabel {
                    end_lsn: LSN,
                },
                PutRecordsLabel {
                    records: MsgHistory,
                },
                QueryLabel {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },
                InternalLabel,
                CommitStartLabel {
                    new_boundary_lsn: LSN,
                },
                CommitCompleteLabel,
                CrashLabel,
            }
            #[automatically_derived]
            impl Label {
                #[spec]
                #[verifier(is_variant("LoadEphemeralFromPersistentLabel"))]
                #[allow(non_snake_case)]
                pub fn is_LoadEphemeralFromPersistentLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(LoadEphemeralFromPersistentLabel,
                                       end_lsn))]
                pub fn get_LoadEphemeralFromPersistentLabel_end_lsn(self)
                 -> LSN {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("PutRecordsLabel"))]
                #[allow(non_snake_case)]
                pub fn is_PutRecordsLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(PutRecordsLabel, records))]
                pub fn get_PutRecordsLabel_records(self) -> MsgHistory {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("QueryLabel"))]
                #[allow(non_snake_case)]
                pub fn is_QueryLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(QueryLabel, end_lsn))]
                pub fn get_QueryLabel_end_lsn(self) -> LSN {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(QueryLabel, key))]
                pub fn get_QueryLabel_key(self) -> Key {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(QueryLabel, value))]
                pub fn get_QueryLabel_value(self) -> Value {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("InternalLabel"))]
                #[allow(non_snake_case)]
                pub fn is_InternalLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("CommitStartLabel"))]
                #[allow(non_snake_case)]
                pub fn is_CommitStartLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[allow(non_snake_case)]
                #[verifier(get_variant(CommitStartLabel, new_boundary_lsn))]
                pub fn get_CommitStartLabel_new_boundary_lsn(self) -> LSN {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("CommitCompleteLabel"))]
                #[allow(non_snake_case)]
                pub fn is_CommitCompleteLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
                #[spec]
                #[verifier(is_variant("CrashLabel"))]
                #[allow(non_snake_case)]
                pub fn is_CrashLabel(&self) -> bool {
                    ::core::panicking::panic("not implemented")
                }
            }
            pub mod show {
                use super::*;
                #[verifier(external_body)]
                #[proof]
                pub fn load_ephemeral_from_persistent(pre: super::State,
                                                      post: super::State,
                                                      lbl: Label,
                                                      new_map:
                                                          AbstractMap::State,
                                                      map_config:
                                                          AbstractMap::Config) {
                    ::builtin::requires(super::State::load_ephemeral_from_persistent(pre,
                                                                                     post,
                                                                                     lbl,
                                                                                     new_map,
                                                                                     map_config));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn put_records(pre: super::State, post: super::State,
                                   lbl: Label, new_map: AbstractMap::State,
                                   map_step: AbstractMap::Step) {
                    ::builtin::requires(super::State::put_records(pre, post,
                                                                  lbl,
                                                                  new_map,
                                                                  map_step));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn query(pre: super::State, post: super::State,
                             lbl: Label, new_map: AbstractMap::State,
                             map_step: AbstractMap::Step) {
                    ::builtin::requires(super::State::query(pre, post, lbl,
                                                            new_map,
                                                            map_step));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn freeze_map_internal(pre: super::State,
                                           post: super::State, lbl: Label,
                                           frozen_map: StampedMap,
                                           new_map: AbstractMap::State,
                                           map_step: AbstractMap::Step) {
                    ::builtin::requires(super::State::freeze_map_internal(pre,
                                                                          post,
                                                                          lbl,
                                                                          frozen_map,
                                                                          new_map,
                                                                          map_step));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn ephemeral_internal(pre: super::State,
                                          post: super::State, lbl: Label,
                                          new_map: AbstractMap::State,
                                          map_step: AbstractMap::Step) {
                    ::builtin::requires(super::State::ephemeral_internal(pre,
                                                                         post,
                                                                         lbl,
                                                                         new_map,
                                                                         map_step));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn commit_start(pre: super::State, post: super::State,
                                    lbl: Label) {
                    ::builtin::requires(super::State::commit_start(pre, post,
                                                                   lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn commit_complete(pre: super::State, post: super::State,
                                       lbl: Label) {
                    ::builtin::requires(super::State::commit_complete(pre,
                                                                      post,
                                                                      lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn crash(pre: super::State, post: super::State,
                             lbl: Label) {
                    ::builtin::requires(super::State::crash(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                #[verifier(external_body)]
                #[proof]
                pub fn initialize(post: super::State) {
                    ::builtin::requires(super::State::initialize(post));
                    ::builtin::ensures(super::State::init(post));
                }
            }
            impl State {
                #[spec]
                #[verifier(publish)]
                pub fn initialize(post: Self) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = empty();
                        let update_tmp_ephemeral: Ephemeral =
                            Ephemeral::Unknown;
                        let update_tmp_in_flight: Option<StoreImage> =
                            Option::None;
                        ((::builtin::equal(post.in_flight,
                                           update_tmp_in_flight)) &&
                             ((::builtin::equal(post.ephemeral,
                                                update_tmp_ephemeral)) &&
                                  (::builtin::equal(post.persistent,
                                                    update_tmp_persistent))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn load_ephemeral_from_persistent(pre: Self, post: Self,
                                                      lbl: Label,
                                                      new_map:
                                                          AbstractMap::State,
                                                      map_config:
                                                          AbstractMap::Config)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_LoadEphemeralFromPersistentLabel()) &&
                             ((pre.ephemeral.is_Unknown()) &&
                                  ((::builtin::spec_eq(lbl.get_LoadEphemeralFromPersistentLabel_end_lsn(),
                                                       pre.persistent.seq_end))
                                       &&
                                       ((::builtin::equal(map_config,
                                                          AbstractMap::Config::initialize(pre.persistent)))
                                            &&
                                            ((AbstractMap::State::init_by(new_map,
                                                                          map_config))
                                                 &&
                                                 {
                                                     let update_tmp_ephemeral:
                                                             Ephemeral =
                                                         Ephemeral::Known{v:
                                                                              new_map,};
                                                     ((::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral))
                                                          &&
                                                          ((::builtin::equal(post.in_flight,
                                                                             update_tmp_in_flight))
                                                               &&
                                                               (::builtin::equal(post.persistent,
                                                                                 update_tmp_persistent))))
                                                 })))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn load_ephemeral_from_persistent_strong(pre: Self,
                                                             post: Self,
                                                             lbl: Label,
                                                             new_map:
                                                                 AbstractMap::State,
                                                             map_config:
                                                                 AbstractMap::Config)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_LoadEphemeralFromPersistentLabel()) &&
                             ((pre.ephemeral.is_Unknown()) &&
                                  ((::builtin::spec_eq(lbl.get_LoadEphemeralFromPersistentLabel_end_lsn(),
                                                       pre.persistent.seq_end))
                                       &&
                                       ((::builtin::equal(map_config,
                                                          AbstractMap::Config::initialize(pre.persistent)))
                                            &&
                                            ((AbstractMap::State::init_by(new_map,
                                                                          map_config))
                                                 &&
                                                 {
                                                     let update_tmp_ephemeral:
                                                             Ephemeral =
                                                         Ephemeral::Known{v:
                                                                              new_map,};
                                                     ((::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral))
                                                          &&
                                                          ((::builtin::equal(post.in_flight,
                                                                             update_tmp_in_flight))
                                                               &&
                                                               (::builtin::equal(post.persistent,
                                                                                 update_tmp_persistent))))
                                                 })))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn put_records(pre: Self, post: Self, lbl: Label,
                                   new_map: AbstractMap::State,
                                   map_step: AbstractMap::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_PutRecordsLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(map_step,
                                                     AbstractMap::Step::put()))
                                       &&
                                       ((AbstractMap::State::next_by(pre.ephemeral.get_Known_v(),
                                                                     new_map,
                                                                     AbstractMap::Label::PutLabel{puts:
                                                                                                      lbl.get_PutRecordsLabel_records(),},
                                                                     map_step))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_map,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn put_records_strong(pre: Self, post: Self, lbl: Label,
                                          new_map: AbstractMap::State,
                                          map_step: AbstractMap::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_PutRecordsLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(map_step,
                                                     AbstractMap::Step::put()))
                                       &&
                                       ((AbstractMap::State::next_by(pre.ephemeral.get_Known_v(),
                                                                     new_map,
                                                                     AbstractMap::Label::PutLabel{puts:
                                                                                                      lbl.get_PutRecordsLabel_records(),},
                                                                     map_step))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_map,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn query(pre: Self, post: Self, lbl: Label,
                             new_map: AbstractMap::State,
                             map_step: AbstractMap::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_QueryLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(map_step,
                                                     AbstractMap::Step::query()))
                                       &&
                                       ((AbstractMap::State::next_by(pre.ephemeral.get_Known_v(),
                                                                     new_map,
                                                                     AbstractMap::Label::QueryLabel{end_lsn:
                                                                                                        lbl.get_QueryLabel_end_lsn(),
                                                                                                    key:
                                                                                                        lbl.get_QueryLabel_key(),
                                                                                                    value:
                                                                                                        lbl.get_QueryLabel_value(),},
                                                                     map_step))
                                            &&
                                            ((::builtin::equal(post.in_flight,
                                                               update_tmp_in_flight))
                                                 &&
                                                 ((::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral))
                                                      &&
                                                      (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent))))))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn query_strong(pre: Self, post: Self, lbl: Label,
                                    new_map: AbstractMap::State,
                                    map_step: AbstractMap::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_QueryLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(map_step,
                                                     AbstractMap::Step::query()))
                                       &&
                                       ((AbstractMap::State::next_by(pre.ephemeral.get_Known_v(),
                                                                     new_map,
                                                                     AbstractMap::Label::QueryLabel{end_lsn:
                                                                                                        lbl.get_QueryLabel_end_lsn(),
                                                                                                    key:
                                                                                                        lbl.get_QueryLabel_key(),
                                                                                                    value:
                                                                                                        lbl.get_QueryLabel_value(),},
                                                                     map_step))
                                            &&
                                            ((::builtin::equal(post.in_flight,
                                                               update_tmp_in_flight))
                                                 &&
                                                 ((::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral))
                                                      &&
                                                      (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent))))))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn freeze_map_internal(pre: Self, post: Self, lbl: Label,
                                           frozen_map: StampedMap,
                                           new_map: AbstractMap::State,
                                           map_step: AbstractMap::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        ((lbl.is_InternalLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((pre.in_flight.is_None()) &&
                                       ((::builtin::equal(map_step,
                                                          AbstractMap::Step::freeze_as()))
                                            &&
                                            ((AbstractMap::State::next_by(pre.ephemeral.get_Known_v(),
                                                                          new_map,
                                                                          AbstractMap::Label::FreezeAsLabel{stamped_map:
                                                                                                                frozen_map,},
                                                                          map_step))
                                                 &&
                                                 {
                                                     let update_tmp_ephemeral:
                                                             Ephemeral =
                                                         Ephemeral::Known{v:
                                                                              new_map,};
                                                     let update_tmp_in_flight:
                                                             Option<StoreImage> =
                                                         Option::Some(frozen_map);
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          ((::builtin::equal(post.ephemeral,
                                                                             update_tmp_ephemeral))
                                                               &&
                                                               (::builtin::equal(post.persistent,
                                                                                 update_tmp_persistent))))
                                                 })))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn freeze_map_internal_strong(pre: Self, post: Self,
                                                  lbl: Label,
                                                  frozen_map: StampedMap,
                                                  new_map: AbstractMap::State,
                                                  map_step: AbstractMap::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        ((lbl.is_InternalLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((pre.in_flight.is_None()) &&
                                       ((::builtin::equal(map_step,
                                                          AbstractMap::Step::freeze_as()))
                                            &&
                                            ((AbstractMap::State::next_by(pre.ephemeral.get_Known_v(),
                                                                          new_map,
                                                                          AbstractMap::Label::FreezeAsLabel{stamped_map:
                                                                                                                frozen_map,},
                                                                          map_step))
                                                 &&
                                                 {
                                                     let update_tmp_ephemeral:
                                                             Ephemeral =
                                                         Ephemeral::Known{v:
                                                                              new_map,};
                                                     let update_tmp_in_flight:
                                                             Option<StoreImage> =
                                                         Option::Some(frozen_map);
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          ((::builtin::equal(post.ephemeral,
                                                                             update_tmp_ephemeral))
                                                               &&
                                                               (::builtin::equal(post.persistent,
                                                                                 update_tmp_persistent))))
                                                 })))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn ephemeral_internal(pre: Self, post: Self, lbl: Label,
                                          new_map: AbstractMap::State,
                                          map_step: AbstractMap::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_InternalLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(map_step,
                                                     AbstractMap::Step::internal()))
                                       &&
                                       ((AbstractMap::State::next_by(pre.ephemeral.get_Known_v(),
                                                                     new_map,
                                                                     AbstractMap::Label::InternalLabel,
                                                                     map_step))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_map,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn ephemeral_internal_strong(pre: Self, post: Self,
                                                 lbl: Label,
                                                 new_map: AbstractMap::State,
                                                 map_step: AbstractMap::Step)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_InternalLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((::builtin::equal(map_step,
                                                     AbstractMap::Step::internal()))
                                       &&
                                       ((AbstractMap::State::next_by(pre.ephemeral.get_Known_v(),
                                                                     new_map,
                                                                     AbstractMap::Label::InternalLabel,
                                                                     map_step))
                                            &&
                                            {
                                                let update_tmp_ephemeral:
                                                        Ephemeral =
                                                    Ephemeral::Known{v:
                                                                         new_map,};
                                                ((::builtin::equal(post.ephemeral,
                                                                   update_tmp_ephemeral))
                                                     &&
                                                     ((::builtin::equal(post.in_flight,
                                                                        update_tmp_in_flight))
                                                          &&
                                                          (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                            }))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn commit_start(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_CommitStartLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((pre.in_flight.is_Some()) &&
                                       (((pre.persistent.seq_end).spec_le(lbl.get_CommitStartLabel_new_boundary_lsn()))
                                            &&
                                            ((::builtin::spec_eq(lbl.get_CommitStartLabel_new_boundary_lsn(),
                                                                 pre.in_flight.get_Some_0().seq_end))
                                                 &&
                                                 ((::builtin::equal(post.in_flight,
                                                                    update_tmp_in_flight))
                                                      &&
                                                      ((::builtin::equal(post.ephemeral,
                                                                         update_tmp_ephemeral))
                                                           &&
                                                           (::builtin::equal(post.persistent,
                                                                             update_tmp_persistent)))))))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn commit_start_strong(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        ((lbl.is_CommitStartLabel()) &&
                             ((pre.ephemeral.is_Known()) &&
                                  ((pre.in_flight.is_Some()) &&
                                       (((pre.persistent.seq_end).spec_le(lbl.get_CommitStartLabel_new_boundary_lsn()))
                                            &&
                                            ((::builtin::spec_eq(lbl.get_CommitStartLabel_new_boundary_lsn(),
                                                                 pre.in_flight.get_Some_0().seq_end))
                                                 &&
                                                 ((::builtin::equal(post.in_flight,
                                                                    update_tmp_in_flight))
                                                      &&
                                                      ((::builtin::equal(post.ephemeral,
                                                                         update_tmp_ephemeral))
                                                           &&
                                                           (::builtin::equal(post.persistent,
                                                                             update_tmp_persistent)))))))))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn commit_complete(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        ((lbl.is_CommitCompleteLabel()) &&
                             ((pre.in_flight.is_Some()) &&
                                  {
                                      let update_tmp_persistent: StoreImage =
                                          pre.in_flight.get_Some_0();
                                      let update_tmp_in_flight:
                                              Option<StoreImage> =
                                          Option::None;
                                      ((::builtin::equal(post.in_flight,
                                                         update_tmp_in_flight))
                                           &&
                                           ((::builtin::equal(post.persistent,
                                                              update_tmp_persistent))
                                                &&
                                                (::builtin::equal(post.ephemeral,
                                                                  update_tmp_ephemeral))))
                                  }))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn commit_complete_strong(pre: Self, post: Self,
                                              lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        ((lbl.is_CommitCompleteLabel()) &&
                             ((pre.in_flight.is_Some()) &&
                                  {
                                      let update_tmp_persistent: StoreImage =
                                          pre.in_flight.get_Some_0();
                                      let update_tmp_in_flight:
                                              Option<StoreImage> =
                                          Option::None;
                                      ((::builtin::equal(post.in_flight,
                                                         update_tmp_in_flight))
                                           &&
                                           ((::builtin::equal(post.persistent,
                                                              update_tmp_persistent))
                                                &&
                                                (::builtin::equal(post.ephemeral,
                                                                  update_tmp_ephemeral))))
                                  }))
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn crash(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        ((lbl.is_CrashLabel()) &&
                             {
                                 let update_tmp_ephemeral: Ephemeral =
                                     Ephemeral::Unknown;
                                 let update_tmp_in_flight:
                                         Option<StoreImage> = Option::None;
                                 ((::builtin::equal(post.in_flight,
                                                    update_tmp_in_flight)) &&
                                      ((::builtin::equal(post.ephemeral,
                                                         update_tmp_ephemeral))
                                           &&
                                           (::builtin::equal(post.persistent,
                                                             update_tmp_persistent))))
                             })
                    }
                }
                #[spec]
                #[verifier(publish)]
                pub fn crash_strong(pre: Self, post: Self, lbl: Label)
                 -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            pre.persistent;
                        ((lbl.is_CrashLabel()) &&
                             {
                                 let update_tmp_ephemeral: Ephemeral =
                                     Ephemeral::Unknown;
                                 let update_tmp_in_flight:
                                         Option<StoreImage> = Option::None;
                                 ((::builtin::equal(post.in_flight,
                                                    update_tmp_in_flight)) &&
                                      ((::builtin::equal(post.ephemeral,
                                                         update_tmp_ephemeral))
                                           &&
                                           (::builtin::equal(post.persistent,
                                                             update_tmp_persistent))))
                             })
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_by(pre: State, post: State, label: Label,
                               step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent(new_map,
                                                             map_config) =>
                        Self::load_ephemeral_from_persistent(pre, post, label,
                                                             new_map,
                                                             map_config),
                        Step::put_records(new_map, map_step) =>
                        Self::put_records(pre, post, label, new_map,
                                          map_step),
                        Step::query(new_map, map_step) =>
                        Self::query(pre, post, label, new_map, map_step),
                        Step::freeze_map_internal(frozen_map, new_map,
                                                  map_step) =>
                        Self::freeze_map_internal(pre, post, label,
                                                  frozen_map, new_map,
                                                  map_step),
                        Step::ephemeral_internal(new_map, map_step) =>
                        Self::ephemeral_internal(pre, post, label, new_map,
                                                 map_step),
                        Step::commit_start() =>
                        Self::commit_start(pre, post, label),
                        Step::commit_complete() =>
                        Self::commit_complete(pre, post, label),
                        Step::crash() => Self::crash(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next(pre: State, post: State, label: Label)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, label,
                                                        step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                                      step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent(new_map,
                                                             map_config) =>
                        Self::load_ephemeral_from_persistent_strong(pre, post,
                                                                    label,
                                                                    new_map,
                                                                    map_config),
                        Step::put_records(new_map, map_step) =>
                        Self::put_records_strong(pre, post, label, new_map,
                                                 map_step),
                        Step::query(new_map, map_step) =>
                        Self::query_strong(pre, post, label, new_map,
                                           map_step),
                        Step::freeze_map_internal(frozen_map, new_map,
                                                  map_step) =>
                        Self::freeze_map_internal_strong(pre, post, label,
                                                         frozen_map, new_map,
                                                         map_step),
                        Step::ephemeral_internal(new_map, map_step) =>
                        Self::ephemeral_internal_strong(pre, post, label,
                                                        new_map, map_step),
                        Step::commit_start() =>
                        Self::commit_start_strong(pre, post, label),
                        Step::commit_complete() =>
                        Self::commit_complete_strong(pre, post, label),
                        Step::crash() => Self::crash_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                 -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                                          Self::next_by(pre, post, label,
                                                        step))
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init_by(post: State, step: Config)
                 -> ::core::primitive::bool {
                    match step {
                        Config::initialize() => Self::initialize(post),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[verifier(opaque)]
                #[verifier(publish)]
                #[spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config|
                                          Self::init_by(post, step))
                }
                #[spec]
                #[verifier(publish)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
            }
        }
    }
    pub mod CoordinationSystem_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use crate::pervasive::{map::*};
    }
}
fn main() { }
