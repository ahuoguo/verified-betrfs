function min(a: int, b: int) : int
{
	if a < b
		then a
	else
		b
}

function max(a: int, b: int) : int
{
	if a < b
		then b
	else
		a
}


datatype Endpoint = Open(point: int) | Closed(point: int)

predicate IsAbove_Low(ep: Endpoint, point: int) {
	match ep {
		case Open(epp) => epp < point
		case Closed(epp) => epp <= point
	}
}

predicate IsBelow_High(point: int, ep: Endpoint) {
	match ep {
		case Open(epp) => point < epp
		case Closed(epp) => point <= epp
	}
}

function EndpointValue(ep: Endpoint) : int {
	match ep {
		case Open(v) => v
		case Closed(v) => v
	}
}

predicate EndpointIsLessThanOrEqualTo_High(a: Endpoint, b: Endpoint) {
	EndpointValue(a) <= EndpointValue(b) && a.Closed? ==> b.Closed?
}
	
function MinEndpoint(a: Endpoint, b: Endpoint) : Endpoint {
	var pnt := min(EndpointValue(a), EndpointValue(b));
	if a.Closed? || b.Closed? then Closed(pnt) else Open(pnt)
}

function MaxEndpoint(a: Endpoint, b: Endpoint) : Endpoint {
	var pnt := max(EndpointValue(a), EndpointValue(b));
	if a.Closed? || b.Closed? then Closed(pnt) else Open(pnt)
}

datatype Interval = Interval(low: Endpoint, high: Endpoint)

predicate IntervalIsNonEmpty(ival: Interval) {
	EndpointValue(ival.low) <= EndpointValue(ival.high)
}
	
function IntervalUnion(a: Interval, b: Interval) : Interval
	requires IntervalIsNonEmpty(a);
	requires IntervalIsNonEmpty(b);
	ensures IntervalIsNonEmpty(IntervalUnion(a,b));
{
	Interval(MinEndpoint(a.low, b.low), MaxEndpoint(a.high, b.high))
}

predicate IntervalContains(ival: Interval, value: int)
	requires(IntervalIsNonEmpty(ival));
{
	IsAbove(ival.low, value) && IsBelow(value, ival.high)
}

datatype Node =
	Leaf(value: Interval) |
	TwoNode(left: Node, pivot: int, povit: Endpoint,
	        right: Node) |
	ThreeNode(left: Node, pivota: int, povita: Endpoint,
	          middle: Node, pivotb: int, povitb: Endpoint,
						right: Node)

function SubtreeContents(tree: Node) : set<Interval>
{
	if tree.Leaf?
		then {tree.value}
	else if tree.TwoNode?
    then SubtreeContents(tree.left) + SubtreeContents(tree.right)
	else 
		SubtreeContents(tree.left) + SubtreeContents(tree.middle) + SubtreeContents(tree.right)
}

predicate ContainsOnlyNonEmptyIntervals(tree: Node) {
	forall intrvl :: intrvl in SubtreeContents(tree) ==> IntervalIsNonEmpty(intrvl)
}

predicate IntervalsStartBefore(tree: Node, pivot: int)
	requires(ContainsOnlyNonEmptyIntervals(tree));
{
	forall lv :: lv in SubtreeContents(tree) ==> EndpointValue(lv.low) < pivot
}

predicate IntervalsStartAfter(pivot: int, tree: Node)
	requires(ContainsOnlyNonEmptyIntervals(tree));
{
	forall lv :: lv in SubtreeContents(tree) ==> EndpointValue(lv.low) >= pivot
}

function SummaryInterval(tree: Node) : Interval
	requires(ContainsOnlyNonEmptyIntervals(tree));
{
	match tree {
		case Leaf(i) => i
		case TwoNode(left, pivot, povit, right) =>
			IntervalUnion(SummaryInterval(left), SummaryInterval(right))
		case ThreeNode(left, pivota, povita, middle, pivotb, povitb, right) =>
			IntervalUnion(IntervalUnion(SummaryInterval(left), SummaryInterval(middle)), SummaryInterval(right))
	}
}

predicate OrderedTree(tree: Node)
{
    if tree.Leaf?
			then ContainsOnlyNonEmptyIntervals(tree)
		else if tree.TwoNode?
      then
			ContainsOnlyNonEmptyIntervals(tree) &&
			IntervalsStartBefore(tree.left, tree.pivot) &&
			IntervalsStartAfter(tree.pivot, tree.right) &&
			(forall intrvl: Interval :: intrvl in SubtreeContents(tree.left) ==>
			EndpointIsLessThanOrEqualTo_High(intrvl.high, tree.povit)) &&
			SummaryInterval(tree.left).high == tree.povit &&
			OrderedTree(tree.left) &&
			OrderedTree(tree.right)
		else
			tree.pivota < tree.pivotb &&
			ContainsOnlyNonEmptyIntervals(tree) &&
			IntervalsStartBefore(tree.left, tree.pivota) &&
			IntervalsStartAfter(tree.pivota, tree.middle) &&
			IntervalsStartBefore(tree.middle, tree.pivotb) &&
			IntervalsStartAfter(tree.pivotb, tree.right) &&
			(forall intrvl: Interval :: intrvl in SubtreeContents(tree.left) ==>
			EndpointIsLessThanOrEqualTo_High(intrvl.high, tree.povita)) &&
			(forall intrvl: Interval :: intrvl in SubtreeContents(tree.middle) ==>
			EndpointIsLessThanOrEqualTo_High(intrvl.high, tree.povitb)) &&
			SummaryInterval(tree.left).high == tree.povita &&
			SummaryInterval(tree.middle).high == tree.povitb &&
			OrderedTree(tree.left) &&
			OrderedTree(tree.middle) &&
			OrderedTree(tree.right)
}

function StabbingQuery(tree: Node, value: int) : set<Interval>
  requires OrderedTree(tree);
	ensures StabbingQuery(tree, value) ==
	 	set ival : Interval | ival in SubtreeContents(tree) && IntervalContains(ival, value)
{
	match tree {
		case Leaf(ival) =>
			if IntervalContains(ival, value) then {ival} else {}
		case TwoNode(left, pivot, povit, right) =>
			assert(forall intrvl: Interval ::
			intrvl in SubtreeContents(tree) &&
			IntervalContains(intrvl, value) &&
			EndpointValue(intrvl.low) < pivot &&
			value >= pivot
			==>
			IsBelow(value, povit));
			StabbingQuery(left, value) + 
		 	// (if value < pivot || IsBelow(value, povit) then StabbingQuery(left, value) else {})
			// +
			(if value >= pivot then StabbingQuery(right, value) else {})
		case ThreeNode(left, pivota, povita, middle, pivotb, povitb, right) =>
			set ival : Interval | ival in SubtreeContents(tree) && IntervalContains(ival, value)
			// if value < pivota || IsBelow(value, povita) then StabbingQuery(left, value) else {} +
			// if value >= pivota && (value < pivotb || IsBelow(value, povitb)) then StabbingQuery(middle, value) else {} +
		 	// if value >= pivotb then StabbingQuery(right, value) else {}
	}
}

function minHeight(tree: Node) : int
{
	if tree.Leaf?
		then 0
	else if tree.TwoNode?
		then 1 + min(minHeight(tree.left), minHeight(tree.right))
	else 
		1 + min(minHeight(tree.left), min(minHeight(tree.middle), minHeight(tree.right)))
}

function maxHeight(tree: Node) : int
{
	if tree.Leaf?
		then 0
	else if tree.TwoNode?
		then 1 + max(maxHeight(tree.left), maxHeight(tree.right))
	else
		1 + max(maxHeight(tree.left), max(maxHeight(tree.middle), maxHeight(tree.right)))
}

predicate balanced(tree: Node) {
	minHeight(tree) == maxHeight(tree)
}

predicate ITTSubtree(tree: Node) {

	if tree.Leaf?
		then OrderedTree(tree) &&
		balanced(tree) &&
		SubtreeContents(tree) != {}
	else if tree.TwoNode?
		then OrderedTree(tree) &&
		balanced(tree) &&
		SubtreeContents(tree) != {} &&
		ITTSubtree(tree.left) &&
		ITTSubtree(tree.right)
	else
		OrderedTree(tree) &&
		balanced(tree) &&
		SubtreeContents(tree) != {} &&
		ITTSubtree(tree.left) &&
		ITTSubtree(tree.middle) &&
		ITTSubtree(tree.right)
}

function Height(tree: Node) : int
	requires(balanced(tree));
{
	if tree.Leaf? then 0 else 1 + Height(tree.left)
}

// method NodeContains(tree: Node, value: int) returns (present: bool)
//     requires OrderedTree(tree);
//     ensures present == (value in SubtreeContents(tree));
// {
// 	if tree.Leaf? {
// 		present := value == tree.value;
// 	} else if tree.TwoNode? {
// 		if value < tree.pivot {
// 			present := NodeContains(tree.left, value);
// 		} else {
// 			present := NodeContains(tree.right, value);
// 		}
// 	} else {
// 		if value < tree.pivota {
// 			present := NodeContains(tree.left, value);
// 		} else if value < tree.pivotb {
// 			present := NodeContains(tree.middle, value);
// 		} else {
// 			present := NodeContains(tree.right, value);
// 		}
// 	}
// }

// datatype InsertionResult = InsertionResult(tree: Node, split: bool)
	
// method InternalInsert(tree: Node, value: int) returns (result: InsertionResult)
// 	requires TTSubtree(tree);
// 	ensures TTSubtree(result.tree);
// 	ensures SubtreeContents(result.tree) == SubtreeContents(tree) + {value};
// 	ensures result.split ==> Height(result.tree) == Height(tree) + 1;
// 	ensures result.split ==> result.tree.TwoNode?;
// 	ensures !result.split ==> Height(result.tree) == Height(tree);
// {
// 	if tree.Leaf? {
// 		if tree.value == value {
// 			result := InsertionResult(tree, false);
// 		} else if tree.value < value {
// 			var newright := Leaf(value);
// 			var newtree := TwoNode(tree, value, newright);
// 			assert(Height(newright) == Height(tree));
// 			assert(Height(newtree) == Height(tree) + 1);
// 			result := InsertionResult(newtree, true);
// 		} else {
// 			var newleft := Leaf(value);
// 			var newtree := TwoNode(newleft, tree.value, tree);
// 			assert(Height(newleft) == Height(tree));
// 			assert(Height(newtree) == Height(tree) + 1);
// 			result := InsertionResult(newtree, true);
// 		}
// 	} else if tree.TwoNode? {
// 		if value < tree.pivot {
// 			var subresult := InternalInsert(tree.left, value);
// 			if !subresult.split {
// 				result := InsertionResult(TwoNode(subresult.tree, tree.pivot, tree.right), false);
// 			} else {
// 				result := InsertionResult(ThreeNode(subresult.tree.left, subresult.tree.pivot,
// 					                                 subresult.tree.right, tree.pivot,
// 																					 tree.right), false);
// 			}
// 		} else {
// 			var subresult := InternalInsert(tree.right, value);
// 			if !subresult.split {
// 				result := InsertionResult(TwoNode(tree.left, tree.pivot, subresult.tree), false);
// 			} else {
// 				result := InsertionResult(ThreeNode(tree.left, tree.pivot,
// 			                		                  subresult.tree.left, subresult.tree.pivot,
// 																						subresult.tree.right), false);
// 			}
// 		}
// 	} else if tree.ThreeNode? {
// 		if value < tree.pivota {
// 			var subresult := InternalInsert(tree.left, value);
// 			if !subresult.split {
// 				result := InsertionResult(ThreeNode(subresult.tree, tree.pivota,
// 					                                  tree.middle, tree.pivotb,
// 																						tree.right), false);
// 			} else {
// 				var newright := TwoNode(tree.middle, tree.pivotb, tree.right);
// 				assert(Height(newright) == Height(tree));
// 				var newtree := TwoNode(subresult.tree, tree.pivota, newright);
// 				assert(Height(newtree) == Height(tree) + 1);
// 				result := InsertionResult(newtree, true);
// 			}
// 		} else if value < tree.pivotb {
// 			var subresult := InternalInsert(tree.middle, value);
// 			if !subresult.split {
// 				result := InsertionResult(ThreeNode(tree.left, tree.pivota,
// 					                                  subresult.tree, tree.pivotb,
// 																						tree.right), false);
// 			} else {
// 				var newleft := TwoNode(tree.left, tree.pivota, subresult.tree.left);
// 				var newright := TwoNode(subresult.tree.right, tree.pivotb, tree.right);
// 				var newtree := TwoNode(newleft, subresult.tree.pivot, newright);
// 				assert(Height(newleft) == Height(tree));
// 				assert(Height(newright) == Height(tree));
// 				assert(Height(newtree) == Height(tree) + 1);
// 				result := InsertionResult(newtree, true);
// 				}
// 		} else {
// 			var subresult := InternalInsert(tree.right, value);
// 			if !subresult.split {
// 				result := InsertionResult(ThreeNode(tree.left, tree.pivota,
// 					                                  tree.middle, tree.pivotb,
// 																						subresult.tree), false);
// 			} else {
// 				var newleft := TwoNode(tree.left, tree.pivota, tree.middle);
// 				var newtree := TwoNode(newleft, tree.pivotb, subresult.tree);
// 				assert(Height(newleft) == Height(tree));
// 				assert(Height(newtree) == Height(tree) + 1);
// 				result := InsertionResult(newtree, true);
// 			}
// 		}
// 	} 
// }

// datatype Tree = EmptyTree | NonEmptyTree(root: Node)

// predicate TTTree(tree: Tree) {
// 	tree.EmptyTree? || TTSubtree(tree.root)
// }

// function Contents(tree: Tree) : set<int>
// {
// 	if tree.EmptyTree?
// 		then {}
// 	else
// 		SubtreeContents(tree.root)
// }

// method Contains(tree: Tree, value: int) returns (present: bool)
// 	requires(TTTree(tree));
// 	ensures(present == (value in Contents(tree)));
// {
// 	if tree.EmptyTree? {
// 		present := false;
// 	} else { 
// 		present := NodeContains(tree.root, value);
// 	}
// }

// method Insert(tree: Tree, value: int) returns (newtree: Tree)
// 	requires(TTTree(tree));
// 	ensures(TTTree(newtree));
// 	ensures(Contents(newtree) == Contents(tree) + {value});
// 	ensures(newtree.NonEmptyTree?);
// {
// 	if tree.EmptyTree? {
// 		newtree := NonEmptyTree(Leaf(value));
// 	} else {
// 		var result := InternalInsert(tree.root, value);
// 		newtree := NonEmptyTree(result.tree);
// 	}
// }
