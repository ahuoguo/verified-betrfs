// Dafny program MutableBtree.i.dfy compiled into Cpp
#include "DafnyRuntime.h"
#include "Lang/LinearExtern.h"
#include "framework/Framework.h"
#include "MutableBtree.i.h"
namespace _System  {












}// end of namespace _System 
namespace NativeTypes_Compile  {



  typedef int16 int16;

  typedef uint16 uint16;

  typedef int32 int32;

  typedef uint32 uint32;

  typedef int64 int64;

  typedef uint64 uint64;

  typedef int8 nat8;

  typedef int16 nat16;

  typedef int32 nat32;

  typedef int64 nat64;

  uint64 __default::Uint64Size()
  {
    return (uint64)8;
  }
  uint64 __default::Uint32Size()
  {
    return (uint64)4;
  }
  uint64 __default::Uint16Size()
  {
    return (uint64)2;
  }
}// end of namespace NativeTypes_Compile 
namespace LinearMaybe  {


}// end of namespace LinearMaybe 
namespace LinearExtern  {




}// end of namespace LinearExtern 
namespace LinearSequence__i_Compile  {





  template <typename A>
as__linear<A>::as__linear() {
    a = get_default<A>::call();
  }
  template <typename A>
bool operator==(const as__linear<A> &left, const as__linear<A> &right)  {
    	return true 		&& left.a == right.a
    ;
  }

  template <typename A>
  LinearExtern::linear_seq<A> __default::seq__alloc__init__iterate(uint64 length, A a, uint64 i, LinearExtern::linear_seq<A> sofar)
  {
    TAIL_CALL_START:
    if ((i) == (length)) {
      return sofar;
    } else  {
      auto _in0 = length;
      auto _in1 = a;
      auto _in2 = (i) + ((uint64)1);
      auto _in3 = LinearExtern::seq_set <A> (sofar, i, a);
      length = _in0;
      a = _in1;
      i = _in2;
      sofar = _in3;
      goto TAIL_CALL_START;
    }
  }
  template <typename A>
  LinearExtern::linear_seq<A> __default::seq__alloc__init(uint64 length, A a)
  {
    return LinearSequence__i_Compile::__default::seq__alloc__init__iterate <A> (length, a, (uint64)0, LinearExtern::seq_alloc <A> (length));
  }
  template <typename A>
  uint64 __default::lseq__length__uint64(LinearExtern::lseq <A>  s)
  {
    return LinearExtern::lseq_length_raw <A> (s);
  }
  template <typename A>
  A __default::lseq__peek(LinearExtern::lseq <A>  s, uint64 i)
  {
    return LinearMaybe::peek <A> (LinearExtern::lseq_share_raw <A> (s, i));
  }
  template <typename A>
  LinearExtern::lseq <A>  __default::lseq__alloc(uint64 length)
  {
    LinearExtern::lseq <A>  s = LinearExtern::get_lseq_default<A>();
    s = LinearExtern::lseq_alloc_raw <A> (length);
    return s;
  }
  template <typename A>
  void __default::lseq__free(LinearExtern::lseq <A>  s)
  {
    { }
    Tuple0 _6766___v0;
    _6766___v0 = LinearExtern::lseq_free_raw <A> (s);
  }
  template <typename A>
  struct Tuple2<LinearExtern::lseq <A> ,A> __default::lseq__swap(LinearExtern::lseq <A>  s1, uint64 i, A a1)
  {
    LinearExtern::lseq <A>  s2 = LinearExtern::get_lseq_default<A>();
    A a2 = get_default<A>::call();
    LinearMaybe::maybe <A>  _6767_x1;
    _6767_x1 = LinearMaybe::give <A> (a1);
    Tuple2 <LinearExtern::lseq <A> ,LinearMaybe::maybe <A> >  _let_tmp_rhs0 = LinearExtern::lseq_swap_raw_fun <A> (s1, i, _6767_x1);
    LinearExtern::lseq <A>  _6768_s2tmp = (_let_tmp_rhs0).get_0();
    LinearMaybe::maybe <A>  _6769_x2 = (_let_tmp_rhs0).get_1();
    s2 = _6768_s2tmp;
    a2 = LinearMaybe::unwrap <A> (_6769_x2);
    return Tuple2<LinearExtern::lseq <A> ,A>(s2,a2);
  }
  template <typename A>
  struct Tuple2<LinearExtern::lseq <A> ,A> __default::lseq__take(LinearExtern::lseq <A>  s1, uint64 i)
  {
    LinearExtern::lseq <A>  s2 = LinearExtern::get_lseq_default<A>();
    A a = get_default<A>::call();
    LinearMaybe::maybe <A>  _6770_x1;
    _6770_x1 = LinearMaybe::empty <A> ();
    Tuple2 <LinearExtern::lseq <A> ,LinearMaybe::maybe <A> >  _let_tmp_rhs1 = LinearExtern::lseq_swap_raw_fun <A> (s1, i, _6770_x1);
    LinearExtern::lseq <A>  _6771_s2tmp = (_let_tmp_rhs1).get_0();
    LinearMaybe::maybe <A>  _6772_x2 = (_let_tmp_rhs1).get_1();
    s2 = _6771_s2tmp;
    a = LinearMaybe::unwrap <A> (_6772_x2);
    return Tuple2<LinearExtern::lseq <A> ,A>(s2,a);
  }
  template <typename A>
  LinearExtern::lseq <A>  __default::lseq__give(LinearExtern::lseq <A>  s1, uint64 i, A a)
  {
    LinearExtern::lseq <A>  s2 = LinearExtern::get_lseq_default<A>();
    LinearMaybe::maybe <A>  _6773_x1;
    _6773_x1 = LinearMaybe::give <A> (a);
    Tuple2 <LinearExtern::lseq <A> ,LinearMaybe::maybe <A> >  _let_tmp_rhs2 = LinearExtern::lseq_swap_raw_fun <A> (s1, i, _6773_x1);
    LinearExtern::lseq <A>  _6774_s2tmp = (_let_tmp_rhs2).get_0();
    LinearMaybe::maybe <A>  _6775_x2 = (_let_tmp_rhs2).get_1();
    s2 = _6774_s2tmp;
    Tuple0 _6776___v1;
    _6776___v1 = LinearMaybe::discard <A> (_6775_x2);
    return s2;
  }
  template <typename A>
  LinearExtern::linear_seq<A> __default::AllocAndCopy(LinearExtern::shared_seq<A> source, uint64 from, uint64 to)
  {
    LinearExtern::linear_seq<A> dest = LinearExtern::linear_seq<A>();
    dest = LinearExtern::seq_alloc <A> ((to) - (from));
    uint64 _6777_i;
    _6777_i = (uint64)0;
    uint64 _6778_count;
    _6778_count = (to) - (from);
    while ((_6777_i) < (_6778_count)) {
      dest = LinearExtern::seq_set <A> (dest, _6777_i, LinearExtern::seq_get <A> (source, (_6777_i) + (from)));
      _6777_i = (_6777_i) + ((uint64)1);
    }
    return dest;
  }
  template <typename A>
  struct Tuple2<LinearExtern::lseq <A> ,LinearExtern::lseq <A> > __default::AllocAndMoveLseq(LinearExtern::lseq <A>  source, uint64 from, uint64 to)
  {
    LinearExtern::lseq <A>  looted = LinearExtern::get_lseq_default<A>();
    LinearExtern::lseq <A>  loot = LinearExtern::get_lseq_default<A>();
    looted = source;
    { }
    LinearExtern::lseq <A>  _out0;
    auto _outcollector0 = LinearSequence__i_Compile::__default::lseq__alloc <A> ((to) - (from));
    _out0 = _outcollector0;
    loot = _out0;
    uint64 _6779_i;
    _6779_i = from;
    { }
    while ((_6779_i) < (to)) {
      A _6780_elt = get_default<A>::call();
      LinearExtern::lseq <A>  _out1;
      A _out2;
      auto _outcollector1 = LinearSequence__i_Compile::__default::lseq__take <A> (looted, _6779_i);
      _out1 = _outcollector1.get_0();
      _out2 = _outcollector1.get_1();
      looted = _out1;
      _6780_elt = _out2;
      LinearExtern::lseq <A>  _out3;
      auto _outcollector2 = LinearSequence__i_Compile::__default::lseq__give <A> (loot, (_6779_i) - (from), _6780_elt);
      _out3 = _outcollector2;
      loot = _out3;
      _6779_i = (_6779_i) + ((uint64)1);
    }
    return Tuple2<LinearExtern::lseq <A> ,LinearExtern::lseq <A> >(looted,loot);
  }
  template <typename A>
  LinearExtern::linear_seq<A> __default::InsertSeq(LinearExtern::linear_seq<A> s, A a, uint64 pos)
  {
    LinearExtern::linear_seq<A> s2 = LinearExtern::linear_seq<A>();
    uint64 _6781_newlen;
    _6781_newlen = (uint64(LinearExtern::seq_length <A> (s))) + ((uint64)1);
    LinearExtern::linear_seq<A> _out4;
    auto _outcollector3 = LinearExtern::TrustedRuntimeSeqResize <A> (s, _6781_newlen);
    _out4 = _outcollector3;
    s2 = _out4;
    uint64 _6782_i;
    _6782_i = (_6781_newlen) - ((uint64)1);
    while ((_6782_i) > (pos)) {
      A _6783_prevElt;
      _6783_prevElt = LinearExtern::seq_get <A> (s2, (_6782_i) - ((uint64)1));
      s2 = LinearExtern::seq_set <A> (s2, _6782_i, _6783_prevElt);
      _6782_i = (_6782_i) - ((uint64)1);
    }
    s2 = LinearExtern::seq_set <A> (s2, pos, a);
    return s2;
  }
  template <typename A>
  LinearExtern::lseq <A>  __default::InsertLSeq(LinearExtern::lseq <A>  s, A a, uint64 pos)
  {
    LinearExtern::lseq <A>  s2 = LinearExtern::get_lseq_default<A>();
    uint64 _6784_newlen;
    _6784_newlen = (LinearExtern::lseq_length_raw <A> (s)) + ((uint64)1);
    LinearExtern::lseq <A>  _out5;
    auto _outcollector4 = LinearExtern::TrustedRuntimeLSeqResize <A> (s, _6784_newlen);
    _out5 = _outcollector4;
    s2 = _out5;
    uint64 _6785_i;
    _6785_i = (_6784_newlen) - ((uint64)1);
    while ((_6785_i) > (pos)) {
      A _6786_prevElt = get_default<A>::call();
      LinearExtern::lseq <A>  _out6;
      A _out7;
      auto _outcollector5 = LinearSequence__i_Compile::__default::lseq__take <A> (s2, (_6785_i) - ((uint64)1));
      _out6 = _outcollector5.get_0();
      _out7 = _outcollector5.get_1();
      s2 = _out6;
      _6786_prevElt = _out7;
      LinearExtern::lseq <A>  _out8;
      auto _outcollector6 = LinearSequence__i_Compile::__default::lseq__give <A> (s2, _6785_i, _6786_prevElt);
      _out8 = _outcollector6;
      s2 = _out8;
      _6785_i = (_6785_i) - ((uint64)1);
    }
    LinearExtern::lseq <A>  _out9;
    auto _outcollector7 = LinearSequence__i_Compile::__default::lseq__give <A> (s2, pos, a);
    _out9 = _outcollector7;
    s2 = _out9;
    return s2;
  }
}// end of namespace LinearSequence__i_Compile 
namespace SeqComparison_Compile  {


}// end of namespace SeqComparison_Compile 
namespace NativeArrays_Compile  {



}// end of namespace NativeArrays_Compile 
namespace Options_Compile  {

  template <typename V>
bool operator==(const Option_None<V> &left, const Option_None<V> &right) {
    (void)left; (void) right;
	return true ;
  }
  template <typename V>
bool operator==(const Option_Some<V> &left, const Option_Some<V> &right) {
    	return true 		&& left.value == right.value
    ;
  }
  template <typename V>
Option<V>::Option() {
    Option_None<V> COMPILER_result_subStruct;
    v = COMPILER_result_subStruct;
  }
  template <typename V>
inline bool is_Option_None(const struct Option<V> d) { return std::holds_alternative<Option_None<V>>(d.v); }
  template <typename V>
inline bool is_Option_Some(const struct Option<V> d) { return std::holds_alternative<Option_Some<V>>(d.v); }

}// end of namespace Options_Compile 
namespace Mathematics_Compile  {

}// end of namespace Mathematics_Compile 
namespace Sequences_Compile  {




  template <typename A>
  DafnySequence<A> __default::Insert(DafnySequence<A> s, A a, uint64 pos)
  {
    DafnySequence<A> res = DafnySequence<A>();
    res = (((s).take(pos)).concatenate((DafnySequence<A>::Create({a})))).concatenate(((s).drop(pos)));
    return res;
    return res;
  }
  template <typename A>
  DafnySequence<A> __default::Replace1with2(DafnySequence<A> s, A a, A b, uint64 pos)
  {
    DafnySequence<A> res = DafnySequence<A>();
    res = (((s).take(pos)).concatenate((DafnySequence<A>::Create({a,b})))).concatenate(((s).drop((pos) + ((uint64)1))));
    return res;
    return res;
  }
  template <typename T>
  DafnySequence<T> __default::SeqIndexUpdate(DafnySequence<T> s, uint64 i, T t)
  {
    return (((s).take(i)).concatenate((DafnySequence<T>::Create({t})))).concatenate(((s).drop((i) + ((uint64)1))));
  }
}// end of namespace Sequences_Compile 
namespace Maps_Compile  {


}// end of namespace Maps_Compile 
namespace Arrays_Compile  {



  template <typename T>
  void __default::Insert(DafnyArray<T> arr, uint64 length, T element, uint64 pos)
  {
    { }
    T _6787_curelement;
    _6787_curelement = (arr).at(pos);
    (arr).at((pos)) = element;
    uint64 _6788_i;
    _6788_i = (pos) + ((uint64)1);
    while ((_6788_i) <= (length)) {
      T _6789_tmp;
      _6789_tmp = (arr).at(_6788_i);
      (arr).at((_6788_i)) = _6787_curelement;
      _6787_curelement = _6789_tmp;
      _6788_i = (_6788_i) + ((uint64)1);
    }
  }
  template <typename T>
  void __default::replace1with2(DafnyArray<T> arr, uint64 length, T element1, T element2, uint64 pos)
  {
    Arrays_Compile::__default::Insert <T> (arr, length, element2, (pos) + ((uint64)1));
    (arr).at((pos)) = element1;
    { }
    { }
    { }
    { }
    { }
  }
}// end of namespace Arrays_Compile 
namespace KeyType_Compile  {



  uint64 __default::MaxLen()
  {
    return (uint64)1024;
  }
}// end of namespace KeyType_Compile 
namespace Byte__Order_Compile  {


  bool __default::lte(uint8 a, uint8 b)
  {
    return (a) <= (b);
  }
  bool __default::ltedef(uint8 a, uint8 b)
  {
    return (a) <= (b);
  }
  int32 __default::cmp(uint8 a, uint8 b)
  {
    int32 c = 0;
    { }
    { }
    c = ((a) < (b)) ? (((int32)0) - ((int32)1)) : (((a) > (b)) ? ((int32)1) : ((int32)0));
    return c;
    return c;
  }






}// end of namespace Byte__Order_Compile 
namespace Lexicographic__Byte__Order_Compile  {





  int32 __default::cmp(DafnySequence<uint8> a, DafnySequence<uint8> b)
  {
    int32 c = 0;
    int32 _out10;
    auto _outcollector8 = NativeArrays_Compile::ByteSeqCmpByteSeq(a, b);
    _out10 = _outcollector8;
    c = _out10;
    return c;
  }
  uint64 __default::ArrayLargestLtePlus1Linear(DafnyArray<DafnySequence<uint8>> run, uint64 start, uint64 end, DafnySequence<uint8> needle)
  {
    uint64 posplus1 = 0;
    uint64 _6790_i;
    _6790_i = start;
    int32 _6791_t = 0;
    if ((_6790_i) < (end)) {
      int32 _out11;
      auto _outcollector9 = Lexicographic__Byte__Order_Compile::__default::cmp((run).at(_6790_i), needle);
      _out11 = _outcollector9;
      _6791_t = _out11;
    }
    while (((_6790_i) < (end)) && ((_6791_t) <= ((int32)0))) {
      _6790_i = (_6790_i) + ((uint64)1);
      if ((_6790_i) < (end)) {
        int32 _out12;
        auto _outcollector10 = Lexicographic__Byte__Order_Compile::__default::cmp((run).at(_6790_i), needle);
        _out12 = _outcollector10;
        _6791_t = _out12;
      }
    }
    { }
    { }
    posplus1 = _6790_i;
    return posplus1;
  }
  uint64 __default::ArrayLargestLtePlus1(DafnyArray<DafnySequence<uint8>> run, uint64 start, uint64 end, DafnySequence<uint8> needle)
  {
    uint64 posplus1 = 0;
    { }
    uint64 _6792_lo;
    _6792_lo = start;
    uint64 _6793_hi;
    _6793_hi = (end) + ((uint64)1);
    while (((uint64)1) < ((_6793_hi) - (_6792_lo))) {
      uint64 _6794_mid;
      _6794_mid = ((_6792_lo) + (_6793_hi)) / ((uint64)2);
      int32 _6795_t;
      int32 _out13;
      auto _outcollector11 = Lexicographic__Byte__Order_Compile::__default::cmp((run).at((_6794_mid) - ((uint64)1)), needle);
      _out13 = _outcollector11;
      _6795_t = _out13;
      if ((_6795_t) <= ((int32)0)) {
        _6792_lo = _6794_mid;
      } else {
        _6793_hi = _6794_mid;
      }
    }
    uint64 _6796_i;
    _6796_i = _6792_lo;
    { }
    posplus1 = _6796_i;
    return posplus1;
  }
  uint64 __default::ArrayLargestLtPlus1(DafnyArray<DafnySequence<uint8>> run, uint64 start, uint64 end, DafnySequence<uint8> needle)
  {
    uint64 posplus1 = 0;
    { }
    uint64 _6797_lo;
    _6797_lo = start;
    uint64 _6798_hi;
    _6798_hi = (end) + ((uint64)1);
    while (((uint64)1) < ((_6798_hi) - (_6797_lo))) {
      uint64 _6799_mid;
      _6799_mid = ((_6797_lo) + (_6798_hi)) / ((uint64)2);
      int32 _6800_t;
      int32 _out14;
      auto _outcollector12 = Lexicographic__Byte__Order_Compile::__default::cmp((run).at((_6799_mid) - ((uint64)1)), needle);
      _out14 = _outcollector12;
      _6800_t = _out14;
      if ((_6800_t) < ((int32)0)) {
        _6797_lo = _6799_mid;
      } else {
        _6798_hi = _6799_mid;
      }
    }
    uint64 _6801_i;
    _6801_i = _6797_lo;
    { }
    posplus1 = _6801_i;
    return posplus1;
  }
  int64 __default::ComputeLargestLte(LinearExtern::shared_seq<DafnySequence<uint8>> run, DafnySequence<uint8> needle)
  {
    int64 res = 0;
    int64 _6802_lo;
    _6802_lo = (int64)0;
    int64 _6803_hi;
    _6803_hi = int64(LinearExtern::seq_length <DafnySequence<uint8>> (run));
    while ((_6802_lo) < (_6803_hi)) {
      int64 _6804_mid;
      _6804_mid = EuclideanDivision_int64((_6802_lo) + (_6803_hi), (int64)2);
      { }
      int32 _6805_c;
      int32 _out15;
      auto _outcollector13 = Lexicographic__Byte__Order_Compile::__default::cmp(LinearExtern::seq_get <DafnySequence<uint8>> (run, uint64(_6804_mid)), needle);
      _out15 = _outcollector13;
      _6805_c = _out15;
      if ((_6805_c) > ((int32)0)) {
        _6803_hi = _6804_mid;
      } else {
        _6802_lo = (_6804_mid) + ((int64)1);
      }
    }
    res = (_6802_lo) - ((int64)1);
    return res;
    return res;
  }
  int64 __default::ComputeLargestLt(DafnySequence<DafnySequence<uint8>> run, DafnySequence<uint8> needle)
  {
    int64 res = 0;
    int64 _6806_lo;
    _6806_lo = (int64)0;
    int64 _6807_hi;
    _6807_hi = (int64)((run).size());
    while ((_6806_lo) < (_6807_hi)) {
      int64 _6808_mid;
      _6808_mid = EuclideanDivision_int64((_6806_lo) + (_6807_hi), (int64)2);
      int32 _6809_c;
      int32 _out16;
      auto _outcollector14 = Lexicographic__Byte__Order_Compile::__default::cmp((run).select(_6808_mid), needle);
      _out16 = _outcollector14;
      _6809_c = _out16;
      if ((_6809_c) < ((int32)0)) {
        _6806_lo = (_6808_mid) + ((int64)1);
      } else {
        _6807_hi = _6808_mid;
      }
    }
    res = (_6806_lo) - ((int64)1);
    return res;
    return res;
  }






}// end of namespace Lexicographic__Byte__Order_Compile 
namespace Integer__Order_Compile  {








}// end of namespace Integer__Order_Compile 
namespace TestBtreeModel_Compile  {












  
bool operator==(const Node_Leaf &left, const Node_Leaf &right) {
    	return true 		&& left.keys == right.keys
    		&& left.values == right.values
    ;
  }
  
bool operator==(const Node_Index &left, const Node_Index &right) {
    	return true 		&& left.pivots == right.pivots
    		&& left.children == right.children
    ;
  }
  
Node::Node() {
    Node_Leaf COMPILER_result_subStruct;
    COMPILER_result_subStruct.keys = LinearExtern::linear_seq<DafnySequence<uint8>>();
    COMPILER_result_subStruct.values = LinearExtern::linear_seq<uint64>();
    v = COMPILER_result_subStruct;
  }
  
inline bool is_Node_Leaf(const struct Node d) { return std::holds_alternative<Node_Leaf>(d.v); }
  
inline bool is_Node_Index(const struct Node d) { return std::holds_alternative<Node_Index>(d.v); }
}// end of namespace TestBtreeModel_Compile 
namespace TestMutableBtree_Compile  {


  uint64 __default::MaxKeysPerLeaf()
  {
    return (uint64)64;
  }
  uint64 __default::MaxChildren()
  {
    return (uint64)64;
  }
  uint64 __default::DefaultValue()
  {
    return (uint64)0;
  }
  DafnySequence<uint8> __default::DefaultKey()
  {
    return DafnySequence<uint8>::Create({(uint8)0});
  }
  uint64 __default::Route(LinearExtern::shared_seq<DafnySequence<uint8>> keys, DafnySequence<uint8> needle)
  {
    uint64 posplus1 = 0;
    int64 _6810_pos;
    int64 _out17;
    auto _outcollector15 = Lexicographic__Byte__Order_Compile::__default::ComputeLargestLte(keys, needle);
    _out17 = _outcollector15;
    _6810_pos = _out17;
    posplus1 = uint64((_6810_pos) + ((int64)1));
    return posplus1;
  }
  Options_Compile::Option <uint64>  __default::QueryLeaf(TestBtreeModel_Compile::Node node, DafnySequence<uint8> needle)
  {
    Options_Compile::Option <uint64>  result = Options_Compile::Option<uint64>();
    { }
    { }
    { }
    uint64 _6811_posplus1;
    uint64 _out18;
    auto _outcollector16 = TestMutableBtree_Compile::__default::Route(((node).dtor_keys()), needle);
    _out18 = _outcollector16;
    _6811_posplus1 = _out18;
    if ((((uint64)1) <= (_6811_posplus1)) && ((LinearExtern::seq_get <DafnySequence<uint8>> (((node).dtor_keys()), (_6811_posplus1) - ((uint64)1))).equals((needle)))) {
      result = Options_Compile::Option <uint64> ::create_Some(LinearExtern::seq_get <uint64> (((node).dtor_values()), (_6811_posplus1) - ((uint64)1)));
    } else {
      result = Options_Compile::Option <uint64> ::create_None();
    }
    return result;
  }
  Options_Compile::Option <uint64>  __default::QueryIndex(TestBtreeModel_Compile::Node node, DafnySequence<uint8> needle)
  {
    Options_Compile::Option <uint64>  result = Options_Compile::Option<uint64>();
    { }
    { }
    uint64 _6812_posplus1;
    uint64 _out19;
    auto _outcollector17 = TestMutableBtree_Compile::__default::Route(((node).dtor_pivots()), needle);
    _out19 = _outcollector17;
    _6812_posplus1 = _out19;
    Options_Compile::Option <uint64>  _out20;
    auto _outcollector18 = TestMutableBtree_Compile::__default::Query(LinearSequence__i_Compile::__default::lseq__peek <TestBtreeModel_Compile::Node> (((node).dtor_children()), _6812_posplus1), needle);
    _out20 = _outcollector18;
    result = _out20;
    { }
    return result;
  }
  Options_Compile::Option <uint64>  __default::Query(TestBtreeModel_Compile::Node node, DafnySequence<uint8> needle)
  {
    Options_Compile::Option <uint64>  result = Options_Compile::Option<uint64>();
    TestBtreeModel_Compile::Node _source0 = node;
    if (is_Node_Leaf(_source0)) {
      LinearExtern::shared_seq<DafnySequence<uint8>> _6813___mcc_h0 = ((_source0).dtor_keys());
      LinearExtern::shared_seq<uint64> _6814___mcc_h1 = ((_source0).dtor_values());
      {
        Options_Compile::Option <uint64>  _out21;
        auto _outcollector19 = TestMutableBtree_Compile::__default::QueryLeaf(node, needle);
        _out21 = _outcollector19;
        result = _out21;
      }
    } else {
      LinearExtern::shared_seq<DafnySequence<uint8>> _6815___mcc_h2 = ((_source0).dtor_pivots());
      LinearExtern::lseq <TestBtreeModel_Compile::Node>  _6816___mcc_h3 = ((_source0).dtor_children());
      {
        Options_Compile::Option <uint64>  _out22;
        auto _outcollector20 = TestMutableBtree_Compile::__default::QueryIndex(node, needle);
        _out22 = _outcollector20;
        result = _out22;
      }
    }
    return result;
  }
  TestBtreeModel_Compile::Node __default::EmptyTree()
  {
    TestBtreeModel_Compile::Node root = TestBtreeModel_Compile::Node();
    LinearExtern::linear_seq<DafnySequence<uint8>> _6817_rootkeys;
    _6817_rootkeys = LinearExtern::seq_alloc <DafnySequence<uint8>> ((uint64)0);
    LinearExtern::linear_seq<uint64> _6818_rootvalues;
    _6818_rootvalues = LinearExtern::seq_alloc <uint64> ((uint64)0);
    root = TestBtreeModel_Compile::Node::create_Leaf(_6817_rootkeys, _6818_rootvalues);
    { }
    return root;
  }
  bool __default::Full(TestBtreeModel_Compile::Node node)
  {
    TestBtreeModel_Compile::Node _source1 = node;
    if (is_Node_Leaf(_source1)) {
      LinearExtern::shared_seq<DafnySequence<uint8>> _6819___mcc_h0 = ((_source1).dtor_keys());
      LinearExtern::shared_seq<uint64> _6820___mcc_h1 = ((_source1).dtor_values());
      LinearExtern::shared_seq<DafnySequence<uint8>> _6821_keys = _6819___mcc_h0;
      return (LinearExtern::seq_length <DafnySequence<uint8>> (_6821_keys)) == (TestMutableBtree_Compile::__default::MaxKeysPerLeaf());
    } else {
      LinearExtern::shared_seq<DafnySequence<uint8>> _6822___mcc_h2 = ((_source1).dtor_pivots());
      LinearExtern::lseq <TestBtreeModel_Compile::Node>  _6823___mcc_h3 = ((_source1).dtor_children());
      LinearExtern::lseq <TestBtreeModel_Compile::Node>  _6824_children = _6823___mcc_h3;
      return (LinearSequence__i_Compile::__default::lseq__length__uint64 <TestBtreeModel_Compile::Node> (_6824_children)) == (TestMutableBtree_Compile::__default::MaxChildren());
    }
  }
  struct Tuple2<TestBtreeModel_Compile::Node,TestBtreeModel_Compile::Node> __default::SplitLeaf(TestBtreeModel_Compile::Node node, uint64 nleft)
  {
    TestBtreeModel_Compile::Node left = TestBtreeModel_Compile::Node();
    TestBtreeModel_Compile::Node right = TestBtreeModel_Compile::Node();
    { }
    { }
    { }
    { }
    { }
    uint64 _6825_nright;
    _6825_nright = (uint64(LinearExtern::seq_length <DafnySequence<uint8>> (((node).dtor_keys())))) - (nleft);
    TestBtreeModel_Compile::Node _let_tmp_rhs3 = node;
    LinearExtern::linear_seq<DafnySequence<uint8>> _6826_keys = ((_let_tmp_rhs3).dtor_keys());
    LinearExtern::linear_seq<uint64> _6827_values = ((_let_tmp_rhs3).dtor_values());
    LinearExtern::linear_seq<DafnySequence<uint8>> _6828_leftKeys;
    LinearExtern::linear_seq<DafnySequence<uint8>> _out23;
    auto _outcollector21 = LinearSequence__i_Compile::__default::AllocAndCopy <DafnySequence<uint8>> (_6826_keys, (uint64)0, nleft);
    _out23 = _outcollector21;
    _6828_leftKeys = _out23;
    LinearExtern::linear_seq<DafnySequence<uint8>> _6829_rightKeys;
    LinearExtern::linear_seq<DafnySequence<uint8>> _out24;
    auto _outcollector22 = LinearSequence__i_Compile::__default::AllocAndCopy <DafnySequence<uint8>> (_6826_keys, nleft, (nleft) + (_6825_nright));
    _out24 = _outcollector22;
    _6829_rightKeys = _out24;
    LinearExtern::linear_seq<uint64> _6830_leftValues;
    LinearExtern::linear_seq<uint64> _out25;
    auto _outcollector23 = LinearSequence__i_Compile::__default::AllocAndCopy <uint64> (_6827_values, (uint64)0, nleft);
    _out25 = _outcollector23;
    _6830_leftValues = _out25;
    LinearExtern::linear_seq<uint64> _6831_rightValues;
    LinearExtern::linear_seq<uint64> _out26;
    auto _outcollector24 = LinearSequence__i_Compile::__default::AllocAndCopy <uint64> (_6827_values, nleft, (nleft) + (_6825_nright));
    _out26 = _outcollector24;
    _6831_rightValues = _out26;
    left = TestBtreeModel_Compile::Node::create_Leaf(_6828_leftKeys, _6830_leftValues);
    right = TestBtreeModel_Compile::Node::create_Leaf(_6829_rightKeys, _6831_rightValues);
    Tuple0 _6832___v6;
    _6832___v6 = LinearExtern::seq_free <DafnySequence<uint8>> (_6826_keys);
    Tuple0 _6833___v7;
    _6833___v7 = LinearExtern::seq_free <uint64> (_6827_values);
    return Tuple2<TestBtreeModel_Compile::Node,TestBtreeModel_Compile::Node>(left,right);
  }
  struct Tuple3<TestBtreeModel_Compile::Node,TestBtreeModel_Compile::Node,DafnySequence<uint8>> __default::SplitIndex(TestBtreeModel_Compile::Node node, uint64 nleft)
  {
    TestBtreeModel_Compile::Node left = TestBtreeModel_Compile::Node();
    TestBtreeModel_Compile::Node right = TestBtreeModel_Compile::Node();
    DafnySequence<uint8> pivot = DafnySequence<uint8>();
    { }
    uint64 _6834_nright;
    _6834_nright = (LinearSequence__i_Compile::__default::lseq__length__uint64 <TestBtreeModel_Compile::Node> (((node).dtor_children()))) - (nleft);
    TestBtreeModel_Compile::Node _let_tmp_rhs4 = node;
    LinearExtern::linear_seq<DafnySequence<uint8>> _6835_pivots = ((_let_tmp_rhs4).dtor_pivots());
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _6836_children = ((_let_tmp_rhs4).dtor_children());
    pivot = LinearExtern::seq_get <DafnySequence<uint8>> (_6835_pivots, (nleft) - ((uint64)1));
    { }
    LinearExtern::linear_seq<DafnySequence<uint8>> _6837_leftPivots;
    LinearExtern::linear_seq<DafnySequence<uint8>> _out27;
    auto _outcollector25 = LinearSequence__i_Compile::__default::AllocAndCopy <DafnySequence<uint8>> (_6835_pivots, (uint64)0, (nleft) - ((uint64)1));
    _out27 = _outcollector25;
    _6837_leftPivots = _out27;
    LinearExtern::linear_seq<DafnySequence<uint8>> _6838_rightPivots;
    LinearExtern::linear_seq<DafnySequence<uint8>> _out28;
    auto _outcollector26 = LinearSequence__i_Compile::__default::AllocAndCopy <DafnySequence<uint8>> (_6835_pivots, nleft, ((nleft) + (_6834_nright)) - ((uint64)1));
    _out28 = _outcollector26;
    _6838_rightPivots = _out28;
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _6839_leftChildren = LinearExtern::get_lseq_default<TestBtreeModel_Compile::Node>();
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _6840_rightChildren = LinearExtern::get_lseq_default<TestBtreeModel_Compile::Node>();
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _out29;
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _out30;
    auto _outcollector27 = LinearSequence__i_Compile::__default::AllocAndMoveLseq <TestBtreeModel_Compile::Node> (_6836_children, (uint64)0, nleft);
    _out29 = _outcollector27.get_0();
    _out30 = _outcollector27.get_1();
    _6836_children = _out29;
    _6839_leftChildren = _out30;
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _out31;
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _out32;
    auto _outcollector28 = LinearSequence__i_Compile::__default::AllocAndMoveLseq <TestBtreeModel_Compile::Node> (_6836_children, nleft, (nleft) + (_6834_nright));
    _out31 = _outcollector28.get_0();
    _out32 = _outcollector28.get_1();
    _6836_children = _out31;
    _6840_rightChildren = _out32;
    left = TestBtreeModel_Compile::Node::create_Index(_6837_leftPivots, _6839_leftChildren);
    right = TestBtreeModel_Compile::Node::create_Index(_6838_rightPivots, _6840_rightChildren);
    { }
    { }
    { }
    { }
    { }
    { }
    Tuple0 _6841___v8;
    _6841___v8 = LinearExtern::seq_free <DafnySequence<uint8>> (_6835_pivots);
    LinearSequence__i_Compile::__default::lseq__free <TestBtreeModel_Compile::Node> (_6836_children);
    { }
    { }
    return Tuple3<TestBtreeModel_Compile::Node,TestBtreeModel_Compile::Node,DafnySequence<uint8>>(left,right,pivot);
  }
  struct Tuple3<TestBtreeModel_Compile::Node,TestBtreeModel_Compile::Node,DafnySequence<uint8>> __default::SplitNode(TestBtreeModel_Compile::Node node)
  {
    TestBtreeModel_Compile::Node left = TestBtreeModel_Compile::Node();
    TestBtreeModel_Compile::Node right = TestBtreeModel_Compile::Node();
    DafnySequence<uint8> pivot = DafnySequence<uint8>();
    if ((node).is_Node_Leaf()) {
      uint64 _6842_boundary;
      _6842_boundary = (LinearExtern::seq_length <DafnySequence<uint8>> (((node).dtor_keys()))) / ((uint64)2);
      pivot = LinearExtern::seq_get <DafnySequence<uint8>> (((node).dtor_keys()), _6842_boundary);
      { }
      TestBtreeModel_Compile::Node _out33;
      TestBtreeModel_Compile::Node _out34;
      auto _outcollector29 = TestMutableBtree_Compile::__default::SplitLeaf(node, _6842_boundary);
      _out33 = _outcollector29.get_0();
      _out34 = _outcollector29.get_1();
      left = _out33;
      right = _out34;
    } else {
      uint64 _6843_boundary;
      _6843_boundary = (LinearSequence__i_Compile::__default::lseq__length__uint64 <TestBtreeModel_Compile::Node> (((node).dtor_children()))) / ((uint64)2);
      TestBtreeModel_Compile::Node _out35;
      TestBtreeModel_Compile::Node _out36;
      DafnySequence<uint8> _out37;
      auto _outcollector30 = TestMutableBtree_Compile::__default::SplitIndex(node, _6843_boundary);
      _out35 = _outcollector30.get_0();
      _out36 = _outcollector30.get_1();
      _out37 = _outcollector30.get_2();
      left = _out35;
      right = _out36;
      pivot = _out37;
    }
    { }
    return Tuple3<TestBtreeModel_Compile::Node,TestBtreeModel_Compile::Node,DafnySequence<uint8>>(left,right,pivot);
  }
  void __default::SplitChildOfIndex(TestBtreeModel_Compile::Node* node, uint64 childidx)
  {
    LinearExtern::linear_seq<DafnySequence<uint8>> _6844_pivots = ((*node).dtor_pivots());
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _6845_children = ((*node).dtor_children());
    TestBtreeModel_Compile::Node _6846_origChild = TestBtreeModel_Compile::Node();
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _out38;
    TestBtreeModel_Compile::Node _out39;
    auto _outcollector31 = LinearSequence__i_Compile::__default::lseq__take <TestBtreeModel_Compile::Node> (_6845_children, childidx);
    _out38 = _outcollector31.get_0();
    _out39 = _outcollector31.get_1();
    _6845_children = _out38;
    _6846_origChild = _out39;
    TestBtreeModel_Compile::Node _6847_left = TestBtreeModel_Compile::Node();
    TestBtreeModel_Compile::Node _6848_right = TestBtreeModel_Compile::Node();
    DafnySequence<uint8> _6849_pivot = DafnySequence<uint8>();
    TestBtreeModel_Compile::Node _out40;
    TestBtreeModel_Compile::Node _out41;
    DafnySequence<uint8> _out42;
    auto _outcollector32 = TestMutableBtree_Compile::__default::SplitNode(_6846_origChild);
    _out40 = _outcollector32.get_0();
    _out41 = _outcollector32.get_1();
    _out42 = _outcollector32.get_2();
    _6847_left = _out40;
    _6848_right = _out41;
    _6849_pivot = _out42;
    LinearExtern::linear_seq<DafnySequence<uint8>> _out43;
    auto _outcollector33 = LinearSequence__i_Compile::__default::InsertSeq <DafnySequence<uint8>> (_6844_pivots, _6849_pivot, childidx);
    _out43 = _outcollector33;
    _6844_pivots = _out43;
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _out44;
    auto _outcollector34 = LinearSequence__i_Compile::__default::lseq__give <TestBtreeModel_Compile::Node> (_6845_children, childidx, _6847_left);
    _out44 = _outcollector34;
    _6845_children = _out44;
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _out45;
    auto _outcollector35 = LinearSequence__i_Compile::__default::InsertLSeq <TestBtreeModel_Compile::Node> (_6845_children, _6848_right, (childidx) + ((uint64)1));
    _out45 = _outcollector35;
    _6845_children = _out45;
    *node = TestBtreeModel_Compile::Node::create_Index(_6844_pivots, _6845_children);
    { }
    { }
    { }
    { }
  }
  struct Options_Compile::Option <uint64> __default::InsertLeaf(TestBtreeModel_Compile::Node* node, DafnySequence<uint8> key, uint64 value)
  {
    Options_Compile::Option <uint64>  oldvalue = Options_Compile::Option<uint64>();
    LinearExtern::linear_seq<DafnySequence<uint8>> _6850_keys = ((*node).dtor_keys());
    LinearExtern::linear_seq<uint64> _6851_values = ((*node).dtor_values());
    int64 _6852_pos;
    int64 _out46;
    auto _outcollector36 = Lexicographic__Byte__Order_Compile::__default::ComputeLargestLte(_6850_keys, key);
    _out46 = _outcollector36;
    _6852_pos = _out46;
    if ((((int64)0) <= (_6852_pos)) && ((LinearExtern::seq_get <DafnySequence<uint8>> (_6850_keys, uint64(_6852_pos))).equals((key)))) {
      oldvalue = Options_Compile::Option <uint64> ::create_Some(LinearExtern::seq_get <uint64> (_6851_values, uint64(_6852_pos)));
      _6851_values = LinearExtern::seq_set <uint64> (_6851_values, uint64(_6852_pos), value);
    } else {
      oldvalue = Options_Compile::Option <uint64> ::create_None();
      LinearExtern::linear_seq<DafnySequence<uint8>> _out47;
      auto _outcollector37 = LinearSequence__i_Compile::__default::InsertSeq <DafnySequence<uint8>> (_6850_keys, key, uint64((_6852_pos) + ((int64)1)));
      _out47 = _outcollector37;
      _6850_keys = _out47;
      LinearExtern::linear_seq<uint64> _out48;
      auto _outcollector38 = LinearSequence__i_Compile::__default::InsertSeq <uint64> (_6851_values, value, uint64((_6852_pos) + ((int64)1)));
      _out48 = _outcollector38;
      _6851_values = _out48;
    }
    *node = TestBtreeModel_Compile::Node::create_Leaf(_6850_keys, _6851_values);
    { }
    { }
    return oldvalue;
  }
  struct Options_Compile::Option <uint64> __default::InsertIndex(TestBtreeModel_Compile::Node* pnode, DafnySequence<uint8> key, uint64 value)
  {
    Options_Compile::Option <uint64>  oldvalue = Options_Compile::Option<uint64>();
    uint64 _6853_childidx;
    uint64 _out49;
    auto _outcollector39 = TestMutableBtree_Compile::__default::Route(((*pnode).dtor_pivots()), key);
    _out49 = _outcollector39;
    _6853_childidx = _out49;
    if (TestMutableBtree_Compile::__default::Full(LinearSequence__i_Compile::__default::lseq__peek <TestBtreeModel_Compile::Node> (((*pnode).dtor_children()), _6853_childidx))) {
      TestBtreeModel_Compile::Node _out50;
      TestMutableBtree_Compile::__default::SplitChildOfIndex(pnode, _6853_childidx);
      { }
      { }
      { }
      { }
      int32 _6854_t;
      int32 _out51;
      auto _outcollector41 = Lexicographic__Byte__Order_Compile::__default::cmp(LinearExtern::seq_get <DafnySequence<uint8>> (((*pnode).dtor_pivots()), _6853_childidx), key);
      _out51 = _outcollector41;
      _6854_t = _out51;
      if ((_6854_t) <= ((int32)0)) {
        _6853_childidx = (_6853_childidx) + ((uint64)1);
        { }
      }
      { }
      { }
    }
    { }
    { }
    { }


// tail-recursive version
    TestBtreeModel_Compile::Node* childNode = &((*pnode->dtor_children())[_6853_childidx].a);
    oldvalue = TestMutableBtree_Compile::__default::InsertNode(childNode, key, value);


// Original take version
//    LinearExtern::linear_seq<DafnySequence<uint8>> _6855_pivots = ((*pnode).dtor_pivots());
//    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _6856_children = ((*pnode).dtor_children());
//    TestBtreeModel_Compile::Node _6857_childNode = TestBtreeModel_Compile::Node();
//    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _out52;
//    TestBtreeModel_Compile::Node _out53;
//    auto _outcollector42 = LinearSequence__i_Compile::__default::lseq__take <TestBtreeModel_Compile::Node> (_6856_children, _6853_childidx);
//    _out52 = _outcollector42.get_0();
//    _out53 = _outcollector42.get_1();
//    _6856_children = _out52;
//    _6857_childNode = _out53;
//    { }
//    { }
//    { }
//    TestBtreeModel_Compile::Node _out54;
//    Options_Compile::Option <uint64>  _out55;
//    oldvalue = TestMutableBtree_Compile::__default::InsertNode(&_6857_childNode, key, value);
//    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _out56;
//    auto _outcollector44 = LinearSequence__i_Compile::__default::lseq__give <TestBtreeModel_Compile::Node> (_6856_children, _6853_childidx, _6857_childNode);
//    _out56 = _outcollector44;
//    _6856_children = _out56;
//    *pnode = TestBtreeModel_Compile::Node::create_Index(_6855_pivots, _6856_children);
    { }
    { }
    return oldvalue;
  }
  struct Options_Compile::Option <uint64> __default::InsertNode(TestBtreeModel_Compile::Node* pnode, DafnySequence<uint8> key, uint64 value)
  {
    TestBtreeModel_Compile::Node n2 = TestBtreeModel_Compile::Node();
    Options_Compile::Option <uint64>  oldvalue = Options_Compile::Option<uint64>();
    if ((*pnode).is_Node_Leaf()) {
      TestBtreeModel_Compile::Node _out57;
      Options_Compile::Option <uint64>  _out58;
      oldvalue = TestMutableBtree_Compile::__default::InsertLeaf(pnode, key, value);
    } else {
      TestBtreeModel_Compile::Node _out59;
      Options_Compile::Option <uint64>  _out60;
      oldvalue = TestMutableBtree_Compile::__default::InsertIndex(pnode, key, value);
    }
    return oldvalue;
  }
  void __default::Grow(TestBtreeModel_Compile::Node* proot)
  {
    LinearExtern::linear_seq<DafnySequence<uint8>> _6858_pivots;
    _6858_pivots = LinearSequence__i_Compile::__default::seq__alloc__init <DafnySequence<uint8>> ((uint64)0, TestMutableBtree_Compile::__default::DefaultKey());
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _6859_children;
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _out61;
    auto _outcollector47 = LinearSequence__i_Compile::__default::lseq__alloc <TestBtreeModel_Compile::Node> ((uint64)1);
    _out61 = _outcollector47;
    _6859_children = _out61;
    LinearExtern::lseq <TestBtreeModel_Compile::Node>  _out62;
    auto _outcollector48 = LinearSequence__i_Compile::__default::lseq__give <TestBtreeModel_Compile::Node> (_6859_children, (uint64)0, *proot);
    { }
    { }
    *proot = TestBtreeModel_Compile::Node::create_Index(_6858_pivots, _outcollector48);
  }
  struct Options_Compile::Option <uint64> __default::Insert(TestBtreeModel_Compile::Node* proot, DafnySequence<uint8> key, uint64 value)
  {
    Options_Compile::Option <uint64>  oldvalue = Options_Compile::Option<uint64>();
    if (TestMutableBtree_Compile::__default::Full(*proot)) {
      { }
      { }
      TestBtreeModel_Compile::Node _out63;
      TestMutableBtree_Compile::__default::Grow(proot);
      { }
    }
    { }
    TestBtreeModel_Compile::Node _out64;
    Options_Compile::Option <uint64>  _out65;
    auto _outcollector50 = TestMutableBtree_Compile::__default::InsertNode(proot, key, value);
    oldvalue = _outcollector50;
    return oldvalue;
  }
  void __default::Free(TestBtreeModel_Compile::Node node)
  {
    TestBtreeModel_Compile::Node _source2 = node;
    if (is_Node_Leaf(_source2)) {
      LinearExtern::linear_seq<DafnySequence<uint8>> _6860___mcc_h0 = ((_source2).dtor_keys());
      LinearExtern::linear_seq<uint64> _6861___mcc_h1 = ((_source2).dtor_values());
      {
        LinearExtern::linear_seq<uint64> _6862_values = _6861___mcc_h1;
        LinearExtern::linear_seq<DafnySequence<uint8>> _6863_keys = _6860___mcc_h0;
        {
          Tuple0 _6864___v9;
          _6864___v9 = LinearExtern::seq_free <DafnySequence<uint8>> (_6863_keys);
          Tuple0 _6865___v10;
          _6865___v10 = LinearExtern::seq_free <uint64> (_6862_values);
        }
      }
    } else {
      LinearExtern::linear_seq<DafnySequence<uint8>> _6866___mcc_h2 = ((_source2).dtor_pivots());
      LinearExtern::lseq <TestBtreeModel_Compile::Node>  _6867___mcc_h3 = ((_source2).dtor_children());
      {
        LinearExtern::lseq <TestBtreeModel_Compile::Node>  _6868_children = _6867___mcc_h3;
        LinearExtern::linear_seq<DafnySequence<uint8>> _6869_pivots = _6866___mcc_h2;
        {
          Tuple0 _6870___v11;
          _6870___v11 = LinearExtern::seq_free <DafnySequence<uint8>> (_6869_pivots);
          uint64 _6871_i;
          _6871_i = (uint64)0;
          LinearExtern::lseq <TestBtreeModel_Compile::Node>  _6872_arr;
          _6872_arr = _6868_children;
          while ((_6871_i) < (LinearSequence__i_Compile::__default::lseq__length__uint64 <TestBtreeModel_Compile::Node> (_6872_arr))) {
            TestBtreeModel_Compile::Node _6873_child = TestBtreeModel_Compile::Node();
            LinearExtern::lseq <TestBtreeModel_Compile::Node>  _out66;
            TestBtreeModel_Compile::Node _out67;
            auto _outcollector51 = LinearSequence__i_Compile::__default::lseq__take <TestBtreeModel_Compile::Node> (_6872_arr, _6871_i);
            _out66 = _outcollector51.get_0();
            _out67 = _outcollector51.get_1();
            _6872_arr = _out66;
            _6873_child = _out67;
            TestMutableBtree_Compile::__default::Free(_6873_child);
            _6871_i = (_6871_i) + ((uint64)1);
          }
          LinearSequence__i_Compile::__default::lseq__free <TestBtreeModel_Compile::Node> (_6872_arr);
        }
      }
    }
  }














}// end of namespace TestMutableBtree_Compile 
namespace MainModule_Compile  {




  DafnySequence<uint8> __default::SeqFor(uint64 i)
  {
    DafnySequence<uint8> result = DafnySequence<uint8>();
    uint8 _6874_b0;
    _6874_b0 = uint8((i) / ((uint64)65536));
    uint64 _6875_r;
    _6875_r = (i) - ((uint64(_6874_b0)) * ((uint64)65536));
    uint8 _6876_b1;
    _6876_b1 = uint8((_6875_r) / ((uint64)256));
    uint8 _6877_b2;
    _6877_b2 = uint8((_6875_r) - ((uint64(_6876_b1)) * ((uint64)256)));
    result = DafnySequence<uint8>::Create({_6874_b0,_6876_b1,_6877_b2});
    return result;
  }
  void __default::Main()
  {
    uint64 _6878_n;
    _6878_n = (uint64)10000000;
    uint64 _6879_p;
    _6879_p = (uint64)3000017;
    TestBtreeModel_Compile::Node _6880_t;
    TestBtreeModel_Compile::Node _out68;
    auto _outcollector52 = TestMutableBtree_Compile::__default::EmptyTree();
    _out68 = _outcollector52;
    _6880_t = _out68;
    uint64 _6881_i;
    _6881_i = (uint64)0;
    while ((_6881_i) < (_6878_n)) {
      Options_Compile::Option <uint64>  _6882_oldvalue = Options_Compile::Option<uint64>();
      uint64 _6883_keyv;
      _6883_keyv = ((_6881_i) * (_6879_p)) % (_6878_n);
      DafnySequence<uint8> _6884_key;
      DafnySequence<uint8> _out69;
      auto _outcollector53 = MainModule_Compile::__default::SeqFor(_6883_keyv);
      _out69 = _outcollector53;
      _6884_key = _out69;
      TestBtreeModel_Compile::Node _out70;
      Options_Compile::Option <uint64>  _out71;
      auto _outcollector54 = TestMutableBtree_Compile::__default::Insert(&_6880_t, _6884_key, _6881_i);
      _6882_oldvalue = _outcollector54;
      if (((_6881_i) % ((uint64)1000000)) == ((uint64)0)) {
        std::cout << (DafnySequenceFromString("i"));
        std::cout << (_6881_i);
        std::cout << (DafnySequenceFromString("\n"));
      }
      /*
      Options_Compile::Option <uint64>  _6885_found;
      Options_Compile::Option <uint64>  _out72;
      auto _outcollector55 = TestMutableBtree_Compile::__default::Query(_6880_t, _6884_key);
      _out72 = _outcollector55;
      _6885_found = _out72;
      if (!((_6885_found).is_Option_Some())) {
        std::cout << (DafnySequenceFromString("lost at "));
        std::cout << (_6881_i);
        std::cout << (DafnySequenceFromString("\n"));
      }
      */
      _6881_i = (_6881_i) + ((uint64)1);
    }
    std::cout << (DafnySequenceFromString("PASSED\n"));
    TestMutableBtree_Compile::__default::Free(_6880_t);
  }
}// end of namespace MainModule_Compile 
namespace Uint32__Order_Compile  {


  bool __default::lte(uint32 a, uint32 b)
  {
    return Uint32__Order_Compile::__default::ltedef(a, b);
  }
  bool __default::ltedef(uint32 a, uint32 b)
  {
    return (a) <= (b);
  }
  int32 __default::cmp(uint32 a, uint32 b)
  {
    int32 c = 0;
    c = ((a) < (b)) ? (((int32)0) - ((int32)1)) : (((a) > (b)) ? ((int32)1) : ((int32)0));
    return c;
    return c;
  }






}// end of namespace Uint32__Order_Compile 
namespace Uint64__Order_Compile  {


  bool __default::lte(uint64 a, uint64 b)
  {
    return Uint64__Order_Compile::__default::ltedef(a, b);
  }
  bool __default::ltedef(uint64 a, uint64 b)
  {
    return (a) <= (b);
  }
  int32 __default::cmp(uint64 a, uint64 b)
  {
    int32 c = 0;
    c = ((a) < (b)) ? (((int32)0) - ((int32)1)) : (((a) > (b)) ? ((int32)1) : ((int32)0));
    return c;
    return c;
  }






}// end of namespace Uint64__Order_Compile 
namespace Char__Order_Compile  {


  bool __default::lte(char a, char b)
  {
    return (a) <= (b);
  }
  bool __default::ltedef(char a, char b)
  {
    return (a) <= (b);
  }
  int32 __default::cmp(char a, char b)
  {
    int32 c = 0;
    c = ((a) < (b)) ? (((int32)0) - ((int32)1)) : (((a) > (b)) ? ((int32)1) : ((int32)0));
    return c;
    return c;
  }






}// end of namespace Char__Order_Compile 
namespace ValueType_Compile  {






  uint64 __default::MaxLen()
  {
    return (uint64)1024;
  }
  DafnySequence<uint8> __default::DefaultValue()
  {
    return DafnySequence<uint8>::Create({});
  }
}// end of namespace ValueType_Compile 
namespace _module  {


























}// end of namespace _module 
template <typename A>
struct get_default<LinearSequence__i_Compile::as__linear<A> > {
  static LinearSequence__i_Compile::as__linear<A> call() {
    return LinearSequence__i_Compile::as__linear<A>();
  }
};
template <typename V>
struct get_default<Options_Compile::Option<V> > {
  static Options_Compile::Option<V> call() {
    return Options_Compile::Option<V>();
  }
};
template <>
struct get_default<TestBtreeModel_Compile::Node > {
  static TestBtreeModel_Compile::Node call() {
    return TestBtreeModel_Compile::Node();
  }
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::class_sbyte > > {
static std::shared_ptr<NativeTypes_Compile::class_sbyte > call() {
return std::shared_ptr<NativeTypes_Compile::class_sbyte >();}
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::class_byte > > {
static std::shared_ptr<NativeTypes_Compile::class_byte > call() {
return std::shared_ptr<NativeTypes_Compile::class_byte >();}
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::class_int16 > > {
static std::shared_ptr<NativeTypes_Compile::class_int16 > call() {
return std::shared_ptr<NativeTypes_Compile::class_int16 >();}
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::class_uint16 > > {
static std::shared_ptr<NativeTypes_Compile::class_uint16 > call() {
return std::shared_ptr<NativeTypes_Compile::class_uint16 >();}
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::class_int32 > > {
static std::shared_ptr<NativeTypes_Compile::class_int32 > call() {
return std::shared_ptr<NativeTypes_Compile::class_int32 >();}
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::class_uint32 > > {
static std::shared_ptr<NativeTypes_Compile::class_uint32 > call() {
return std::shared_ptr<NativeTypes_Compile::class_uint32 >();}
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::class_int64 > > {
static std::shared_ptr<NativeTypes_Compile::class_int64 > call() {
return std::shared_ptr<NativeTypes_Compile::class_int64 >();}
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::class_uint64 > > {
static std::shared_ptr<NativeTypes_Compile::class_uint64 > call() {
return std::shared_ptr<NativeTypes_Compile::class_uint64 >();}
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::class_nat8 > > {
static std::shared_ptr<NativeTypes_Compile::class_nat8 > call() {
return std::shared_ptr<NativeTypes_Compile::class_nat8 >();}
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::class_nat16 > > {
static std::shared_ptr<NativeTypes_Compile::class_nat16 > call() {
return std::shared_ptr<NativeTypes_Compile::class_nat16 >();}
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::class_nat32 > > {
static std::shared_ptr<NativeTypes_Compile::class_nat32 > call() {
return std::shared_ptr<NativeTypes_Compile::class_nat32 >();}
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::class_nat64 > > {
static std::shared_ptr<NativeTypes_Compile::class_nat64 > call() {
return std::shared_ptr<NativeTypes_Compile::class_nat64 >();}
};
template <>
struct get_default<std::shared_ptr<NativeTypes_Compile::__default > > {
static std::shared_ptr<NativeTypes_Compile::__default > call() {
return std::shared_ptr<NativeTypes_Compile::__default >();}
};
template <>
struct get_default<std::shared_ptr<LinearSequence__i_Compile::__default > > {
static std::shared_ptr<LinearSequence__i_Compile::__default > call() {
return std::shared_ptr<LinearSequence__i_Compile::__default >();}
};
template <>
struct get_default<std::shared_ptr<Sequences_Compile::__default > > {
static std::shared_ptr<Sequences_Compile::__default > call() {
return std::shared_ptr<Sequences_Compile::__default >();}
};
template <>
struct get_default<std::shared_ptr<Arrays_Compile::__default > > {
static std::shared_ptr<Arrays_Compile::__default > call() {
return std::shared_ptr<Arrays_Compile::__default >();}
};
template <>
struct get_default<std::shared_ptr<KeyType_Compile::class_Key > > {
static std::shared_ptr<KeyType_Compile::class_Key > call() {
return std::shared_ptr<KeyType_Compile::class_Key >();}
};
template <>
struct get_default<std::shared_ptr<KeyType_Compile::__default > > {
static std::shared_ptr<KeyType_Compile::__default > call() {
return std::shared_ptr<KeyType_Compile::__default >();}
};
template <>
struct get_default<std::shared_ptr<Byte__Order_Compile::__default > > {
static std::shared_ptr<Byte__Order_Compile::__default > call() {
return std::shared_ptr<Byte__Order_Compile::__default >();}
};
template <>
struct get_default<std::shared_ptr<Lexicographic__Byte__Order_Compile::__default > > {
static std::shared_ptr<Lexicographic__Byte__Order_Compile::__default > call() {
return std::shared_ptr<Lexicographic__Byte__Order_Compile::__default >();}
};
template <>
struct get_default<std::shared_ptr<TestMutableBtree_Compile::__default > > {
static std::shared_ptr<TestMutableBtree_Compile::__default > call() {
return std::shared_ptr<TestMutableBtree_Compile::__default >();}
};
template <>
struct get_default<std::shared_ptr<MainModule_Compile::__default > > {
static std::shared_ptr<MainModule_Compile::__default > call() {
return std::shared_ptr<MainModule_Compile::__default >();}
};
template <>
struct get_default<std::shared_ptr<Uint32__Order_Compile::__default > > {
static std::shared_ptr<Uint32__Order_Compile::__default > call() {
return std::shared_ptr<Uint32__Order_Compile::__default >();}
};
template <>
struct get_default<std::shared_ptr<Uint64__Order_Compile::__default > > {
static std::shared_ptr<Uint64__Order_Compile::__default > call() {
return std::shared_ptr<Uint64__Order_Compile::__default >();}
};
template <>
struct get_default<std::shared_ptr<Char__Order_Compile::__default > > {
static std::shared_ptr<Char__Order_Compile::__default > call() {
return std::shared_ptr<Char__Order_Compile::__default >();}
};
template <>
struct get_default<std::shared_ptr<ValueType_Compile::class_Value > > {
static std::shared_ptr<ValueType_Compile::class_Value > call() {
return std::shared_ptr<ValueType_Compile::class_Value >();}
};
template <>
struct get_default<std::shared_ptr<ValueType_Compile::__default > > {
static std::shared_ptr<ValueType_Compile::__default > call() {
return std::shared_ptr<ValueType_Compile::__default >();}
};
int main() {
  try {
    MainModule_Compile::__default::Main();
  }
  catch (DafnyHaltException & e) {
    std::cout << "Program halted: " << e.what() << std::endl;
  }
}
